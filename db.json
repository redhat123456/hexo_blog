{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/first.styl","path":"css/first.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/css/Readme.md","path":"css/Readme.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/search/hexo.js","path":"js/search/hexo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/parallax.js","path":"js/plugins/parallax.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenu.js","path":"js/plugins/rightMenu.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenus.js","path":"js/plugins/rightMenus.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/contributors.js","path":"js/plugins/tags/contributors.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/friends.js","path":"js/plugins/tags/friends.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/sites.js","path":"js/plugins/tags/sites.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"acad91ace80b80295b11a9b7ad4c29a2dcfdd8fb","modified":1749998504174},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"a93d7b3990e45bc7247eecf01888f71674887a63","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1749998531752},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1749998531752},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/blank.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1751763432939},{"_id":"node_modules/hexo-theme-volantis/LICENSE","hash":"13b0862f4ed1914abe887a47df2c3ca5adfa8f3f","modified":1751763432908},{"_id":"node_modules/hexo-theme-volantis/package.json","hash":"c0629039d3f77b26877de48080edf449b3618f57","modified":1751763433149},{"_id":"node_modules/hexo-theme-volantis/README.md","hash":"7c43923ced74698b0dfffb0ff1c53a70ad16e6fb","modified":1751763433153},{"_id":"node_modules/hexo-theme-volantis/languages/zh-CN.yml","hash":"3cf7e00abc512c446f8506887ee02605f7e229dd","modified":1751763433237},{"_id":"node_modules/hexo-theme-volantis/languages/en.yml","hash":"cb84db341aeab91676b603cf47bba07c57474d94","modified":1751763433236},{"_id":"node_modules/hexo-theme-volantis/CHANGELOG.md","hash":"10dd4ec44677baae3cd2e099ba6731be5b97d2b2","modified":1751763433152},{"_id":"node_modules/hexo-theme-volantis/layout/404.ejs","hash":"48e160ad704be637cafc433d2365fc0eb8bab8cb","modified":1751763432919},{"_id":"node_modules/hexo-theme-volantis/_config.yml","hash":"1d3b1d5ee64d9785683a374d58badfce3c769ca2","modified":1751763433235},{"_id":"node_modules/hexo-theme-volantis/languages/zh-TW.yml","hash":"30df1cf6181375c4d05cb6dcfbdc0487ea39369c","modified":1751763433237},{"_id":"node_modules/hexo-theme-volantis/layout/_pre.ejs","hash":"3ac804505c282ff8b16858037c1d2bf9305c3063","modified":1751763432915},{"_id":"node_modules/hexo-theme-volantis/layout/docs.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1751763432959},{"_id":"node_modules/hexo-theme-volantis/layout/index.ejs","hash":"8ea7d49272b068cd1a4037846c72eb37e9823512","modified":1751763433008},{"_id":"node_modules/hexo-theme-volantis/layout/category.ejs","hash":"9ee883e5f73c05b3963770b74b63d7bb7e4e1ed5","modified":1751763432947},{"_id":"node_modules/hexo-theme-volantis/layout/archive.ejs","hash":"f99913b253f8ab22f81280a6ce5145bec3cd3de6","modified":1751763432926},{"_id":"node_modules/hexo-theme-volantis/layout/page.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1751763433025},{"_id":"node_modules/hexo-theme-volantis/layout/post.ejs","hash":"16917af05431c049aa103744a5fb2595d5848d4c","modified":1751763433028},{"_id":"node_modules/hexo-theme-volantis/layout/friends.ejs","hash":"d976c3d2180432319cc4deb503481f0c606811a6","modified":1751763432967},{"_id":"node_modules/hexo-theme-volantis/layout/layout.ejs","hash":"9fa2628f97d59796f15126ad016489d072814637","modified":1751763433016},{"_id":"node_modules/hexo-theme-volantis/layout/tag.ejs","hash":"696e7b1c70b4438e6a8d925f99cbc4222dd4035d","modified":1751763433078},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/author.ejs","hash":"68e8f198c406b6946fbf0a0f756e8a334982ba84","modified":1751763432938},{"_id":"node_modules/hexo-theme-volantis/layout/list.ejs","hash":"a85b2984717ee6d5058ec5635f3f287f45c3d4ba","modified":1751763433020},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/artalkcount.ejs","hash":"94c9e591e38ac00d6beafa44de4d29e70680c673","modified":1751763432932},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/category.ejs","hash":"e95b88bf5f8b11b4f886859cf634a72aa46c8650","modified":1751763432944},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/music.ejs","hash":"2c1884e59131d47a82d2556ac28ef784b4ddaa10","modified":1751763433022},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/share.ejs","hash":"0f3b1db92319734baa8da1636340839ed2d37a7b","modified":1751763433076},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/date.ejs","hash":"ba6c554dbc6c1870debb2b87c5fa25caa089be8f","modified":1751763432957},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/thumbnail.ejs","hash":"60045f2bf695b4be5ad3fd19db46890f1cdee68a","modified":1751763433082},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/updated.ejs","hash":"edf445ad8153419a5dc7c4ec4c8490967cd9d33d","modified":1751763433085},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/walinecount.ejs","hash":"a407ec847c8f0e224efd22b7234e2921cca1d5be","modified":1751763433086},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/counter.ejs","hash":"1bd825605f3dacf685848b93a25269f49269b4d7","modified":1751763432953},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/tags.ejs","hash":"24aae7e64ce05ddb13e793a181bfa74257a830e4","modified":1751763433080},{"_id":"node_modules/hexo-theme-volantis/layout/_meta/wordcount.ejs","hash":"eebaab3821af95ee64d8d56f33ca6c9c60b9b6f0","modified":1751763433088},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/archive.ejs","hash":"d5f776437c108c72c002b11f1d23d30b50e0079a","modified":1751763432925},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/cover.ejs","hash":"b03a268d75dedeb8d6e29e3e352bd6cdf921545a","modified":1751763432954},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/categories.ejs","hash":"c2bc61780cab948ef8ab5076511ebccacab1cd79","modified":1751763432943},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/footer.ejs","hash":"baec06d381d8358ee6762e4b0a67d27cd0c7a511","modified":1751763432966},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/header.ejs","hash":"06ce9cd8ad7e64e83cb52cda555fd73b1c6c2b52","modified":1751763432977},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/meta.ejs","hash":"ced9c966a9f4d84e485c325ef3551be218ddd033","modified":1751763433021},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/side.ejs","hash":"27f9df84585ffb24e2ba2423761f90f690c65787","modified":1751763433077},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/article.ejs","hash":"11d61f5ce1bdc6f1fb1163e5e7a213fb5cbb6b53","modified":1751763432936},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/_pre.ejs","hash":"2f635098c719d9dbf0f23eeead370c6550d1ecff","modified":1751763432918},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/head.ejs","hash":"c514d24e014fbb8b28820c76fe6b3cce7353115d","modified":1751763432975},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/copyright.ejs","hash":"8e4929772970e58482f10e0867692cfcf59dee5d","modified":1751763432951},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/grid.ejs","hash":"7d266197f6037f32c33bd74741730c5558417402","modified":1751763432973},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/category.ejs","hash":"d8e7ad7e1418659208036a0a43cb4db2ee61abd7","modified":1751763432945},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/blogger.ejs","hash":"b1429acdd791cd5f00a0f0303bcd8674cf73ed52","modified":1751763432941},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/header.ejs","hash":"b132e332ddf12d1bb1d99480200561d8c38edd04","modified":1751763432978},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/group.ejs","hash":"2eed9614049441b51e6819f393f80faf5441870b","modified":1751763432974},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/list.ejs","hash":"0c9319e7e81d88c721b3fe9acf6171f81faade68","modified":1751763433019},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/post.ejs","hash":"7d144c80f2980efaab6198512746c0c5d77f03db","modified":1751763433027},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/lastupdate.ejs","hash":"c311ba4c8b255c45313dc1ab7ddafd99ec7fe8af","modified":1751763433009},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/music.ejs","hash":"2f560f3168e3811cd1d8d8a6bad9112932be9b04","modified":1751763433023},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/page.ejs","hash":"e6a20fb75a3e835a404dddd929db4d3762a367c0","modified":1751763433024},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/qrcode.ejs","hash":"128b7c6b4b2191ead4079688e55333bb97df0cdd","modified":1751763433029},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/load.ejs","hash":"b71e0617165d5db546d22297229d7f380091fd83","modified":1751763433020},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/references.ejs","hash":"08f2dbd23fc9835f4c24bdda4cf288593d61c25a","modified":1751763433029},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/related_posts.ejs","hash":"f7a514d1f3f5ae40c6fb55d61f8b2a0bba13401c","modified":1751763433030},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/tagcloud.ejs","hash":"a68ccb41f7b589f9076a750e77e17f178af3e9d0","modified":1751763433080},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/content-visibility.js","hash":"048a8f1b80e8999d5f7a37bb8c4dabdebbebabdc","modified":1751763433110},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/img.js","hash":"160732831bec5baf89fa07a85fec5229c3cb9cd7","modified":1751763433128},{"_id":"node_modules/hexo-theme-volantis/scripts/events/index.js","hash":"af7aaa4431393889671853db03c8b684265eaa50","modified":1751763433128},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/replace.js","hash":"aa6fe807d7b24a60475ce8126a1be7b314cd26ba","modified":1751763433139},{"_id":"node_modules/hexo-theme-volantis/scripts/filters/z-lazyload.js","hash":"df6c5b0a6eff5e655d2b8de85c646ba1e5a16535","modified":1751763433148},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/custom-files.js","hash":"8483fcdc7dbbfde40276dc3daa1ddc5e40380360","modified":1751763433114},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/related-posts.js","hash":"cab8c291a8ff460b29b3248ac86827c143aca9ee","modified":1751763433138},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/getList.js","hash":"595400c37b79599f779876808e0308ead7de0a32","modified":1751763433124},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/first-style.js","hash":"ba2e2325a365704abae3f1d204b058731e21bfbf","modified":1751763433117},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/revisioned.js","hash":"57a9d91cd755f8100f149a0fe6cbb45d9c77e13c","modified":1751763433139},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/btn.js","hash":"e9b6e26f106505cf14a72524ab5e8b5bc85f362a","modified":1751763433099},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/btns.js","hash":"648671420faa0ac00076a8c7bb011c908b83fd5a","modified":1751763433100},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/checkbox.js","hash":"0798edc6833d5978709ca5ed56aed33cea46e694","modified":1751763433105},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/contributors.js","hash":"a00573000e7ddf7a9d2f03f29fd62cb8a9752a48","modified":1751763433111},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/dropmenu.js","hash":"19176a6edf7acc6ad31c96961e59da526f200980","modified":1751763433115},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/fancybox.js","hash":"9eac73fa2d7d14ae585b302255270933641a4859","modified":1751763433116},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/image.js","hash":"63a4b3e1e3d661b6ab2b3fcfcfb657e3b632b9cb","modified":1751763433127},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/friends.js","hash":"a902e1ac279014a30eda85e477c52144214cc66c","modified":1751763433119},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/frame.js","hash":"e78834c005bda8f80ba86c78911b9db7566b878b","modified":1751763433118},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/ghcard.js","hash":"1ed7c1508180756ad4752769aa91289d37a7e23d","modified":1751763433125},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/inline-labels.js","hash":"08fbdc0ea622270e1236a28778f875c8ad2e5516","modified":1751763433131},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/folding.js","hash":"a809988c63f358e2ae903d905dc81ed80860bacd","modified":1751763433118},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/md.js","hash":"66d6b7c17638e778a8796d64cd42d0c622eba67e","modified":1751763433132},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/link.js","hash":"9dec9c65819d1135a7a248adaa26acbf24427cd0","modified":1751763433131},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/media.js","hash":"b3871bc024d7fce9500f31073d690c4cd33bce18","modified":1751763433133},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/note.js","hash":"ac86ba50da98d9546522feaca672259620b053d8","modified":1751763433134},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/pandown.js","hash":"4d6f6dab955106ade379d6c55603e1e7eb97a107","modified":1751763433135},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/site.js","hash":"dd23a06f2e8a3cc70730cf199a0661777532ff0b","modified":1751763433142},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/span.js","hash":"b825115f037386797efa1b0aee3a1df21629f243","modified":1751763433144},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/swiper.js","hash":"f0171f07f494c0b0f3f8af265344add15813a676","modified":1751763433145},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/tabs.js","hash":"f0054f1c970cac728b3ad289a3c531c070c06896","modified":1751763433146},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/text.ejs","hash":"9302a6084c8f930532f7f8793b1b20ca1964473e","modified":1751763433082},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/table.js","hash":"ad82046fc64f932019d8a7b3e9a8ff07973a6c3b","modified":1751763433146},{"_id":"node_modules/hexo-theme-volantis/source/css/style.styl","hash":"00892839230a1b05a5f9d9350baacd67d894fc85","modified":1751763433228},{"_id":"node_modules/hexo-theme-volantis/scripts/tags/timeline.js","hash":"9b6b88ada712a8f3a04a825cf73a409f072ed045","modified":1751763433147},{"_id":"node_modules/hexo-theme-volantis/source/css/first.styl","hash":"55fe35847a1d1d831eb71288c0233efb1dd8a630","modified":1751763433185},{"_id":"node_modules/hexo-theme-volantis/source/css/Readme.md","hash":"cf408308dcbc62f4fc2bd5aa38303b368cc88a7e","modified":1751763433155},{"_id":"node_modules/hexo-theme-volantis/source/js/app.js","hash":"8a963d59738599a9b9a0cbce6a543c45ccb6e4e9","modified":1751763433092},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/toc.ejs","hash":"200bf0096d8965e5fb7039b261317c848e36be85","modified":1751763433084},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/dock.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1751763432958},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/featured.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1751763432960},{"_id":"node_modules/hexo-theme-volantis/layout/_widget/webinfo.ejs","hash":"29b70c3e5882afa3045b1282d03f88d30ccf5e84","modified":1751763433087},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/focus.ejs","hash":"7abe0c7080dfcec063b4f52e4ca569bf0510c7c1","modified":1751763432964},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/layout.ejs","hash":"39a463ce33ce6138d40055e72118941515ba2f63","modified":1751763433009},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/_cover/search.ejs","hash":"2f536370d1b51fa7c33798be21e690638f0df74e","modified":1751763433074},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl.ejs","hash":"8dd82dc0d7cd59c55d9e1239ec80c0303a4069bf","modified":1751763432911},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/content-visibility-scroll-fix.ejs","hash":"8aa467244e0976efbdc80e28dd266b0ac0bd2dc7","modified":1751763432950},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/index.ejs","hash":"462334ae298659214464f3a8af3da1c514cf76e1","modified":1751763432995},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/global.ejs","hash":"27a98869f648ff7aed5c290d900d4cf06e51f2f8","modified":1751763432973},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/toc.ejs","hash":"d71bac519593ac09e9e5c521e5999925e253f4b6","modified":1751763433083},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/index.ejs","hash":"56d2e577fbd08859e118cfb1d1b8d230850a3675","modified":1751763433004},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/analytics/LCCounter.ejs","hash":"c83c4b6c3fbf37721e6e6c6e41695fa26abc770a","modified":1751763433018},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/aplayer/script.ejs","hash":"dc0b773f0d26c660b36625fdbd17a2d8455e6095","modified":1751763433032},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/index.ejs","hash":"3d781c01f494b89d1d31d3210c100c822787c9b7","modified":1751763433006},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/aplayer/layout.ejs","hash":"51b4f54a165fbca56c9beec3ce19bc62f10097d9","modified":1751763433010},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/analytics/script.ejs","hash":"a757c6fd89e11ab3e4cbd3e4cc02091a836fcd70","modified":1751763433031},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/darkmode/script.ejs","hash":"742f0e0988741e3eb82bb0d99a081447b45a41b1","modified":1751763433054},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/end-of-support/script.ejs","hash":"b415d8e5dfca4a47c199b1adeb220ff57eaec219","modified":1751763433055},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/script.ejs","hash":"06befe70f47454fbfaa95245fe4cdb8d4f6f9f3c","modified":1751763433060},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/github-api/script.ejs","hash":"8c414c5c39fb6c36c2a4881463f3dc3346cc9b46","modified":1751763433056},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/lazyload/script.ejs","hash":"d80dd5864200d86bc6c43d0fd1efab6538e703cf","modified":1751763433062},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/nodewaves/script.ejs","hash":"f28854fba682c345424f6217525507f0a3e2b17d","modified":1751763433063},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/parallax/script.ejs","hash":"7c88aedd458b2c9df27e57db5c6ecb3090c58eba","modified":1751763433064},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/index.ejs","hash":"4daf9937293b6e2b4bf458d3e868da18900d2864","modified":1751763433007},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/pdata.ejs","hash":"eb90a00163519e6ed01a4f38380caf4dc2bd5049","modified":1751763433026},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/pjax/animate.ejs","hash":"050f626db44ef423e5f8689447197a37f7de6e27","modified":1751763432922},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/index.ejs","hash":"782b9f2cf693d0a7094adac730a4d543335ea614","modified":1751763432979},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/scrollreveal/script.ejs","hash":"bfcd40a4c86a79d11b6ea9460f5bb6c3a60be48e","modified":1751763433066},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/preload/script.ejs","hash":"1c3bf70b6df9da59c5554a921d7447e20684241d","modified":1751763433065},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/search/script.ejs","hash":"c6525e6d76b6e968a1803fe8aea076dfc23659a0","modified":1751763433068},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/slow-network/script.ejs","hash":"5a2f3eaadb6dbe4350e6d32094a0bad62ba240bc","modified":1751763433069},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/check-environment.js","hash":"9d29a3f34ea715a0dc7cb5c2f76b5713d718e6e6","modified":1751763433104},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/swiper/script.ejs","hash":"766ab47f4b26502fb71383ae442a1db629fe9e12","modified":1751763433072},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/check-configuration.js","hash":"08f383bd163383a157db177b77143c467de98a29","modified":1751763433102},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/config.js","hash":"8dafa15769d43693523e435fad10b85f614a0600","modified":1751763433107},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/stellar-tag-utils.js","hash":"8d62893faf26d15d2833f8090bd6257a7282f5e2","modified":1751763433145},{"_id":"node_modules/hexo-theme-volantis/scripts/events/lib/render-stylus.js","hash":"36c2f32d2101eaa84041daf70393df6f3a3fa331","modified":1751763433138},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_preload_fontfamily.js","hash":"d37dbe38fa9125fdce99b2ef9e92582ed08eea82","modified":1751763433121},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/autoCanonical.js","hash":"f3ea74759129c71041371a1d77c687eb6aa88d3a","modified":1751763433095},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_title__keywords__description.js","hash":"179a07b7b2270398216a34d79595d98e30962b22","modified":1751763433123},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/head/generate_seo.js","hash":"e0059a60cc5978be6792dcf795a2ece3a509f41a","modified":1751763433122},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/index.js","hash":"bcb770787c77e39cdc156b7fd58cde8e00b79153","modified":1751763433130},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/share/layout.ejs","hash":"f46f00d5866082bb60137b5044ead669a062bc9f","modified":1751763433015},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/rightmenu/layout.ejs","hash":"aa49c2498e2e61dd4ac0d68db89a1bdee86a9208","modified":1751763433012},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/Readme.md","hash":"77d9e986d24898b98eba2010185951fd1fb8b95c","modified":1751763433154},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/rightmenus/layout.ejs","hash":"31a1787705aa13d3e0eb1aacf76bc4db869cb37a","modified":1751763433014},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/AutoPrefixCSS.styl","hash":"c76f624d332c59b73c1d6b95b30b2afb560976eb","modified":1751763433160},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/color.styl","hash":"02d9bbe630f33ec2c604cb8acdddbe28431fcb05","modified":1751763433171},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/fonts.styl","hash":"fa199b11b568a6b0d6fc4e87ef12ab36ac254966","modified":1751763433189},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/effect.styl","hash":"47db4f84182194a8a233931424c9bc79c6cf0117","modified":1751763433183},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/func.styl","hash":"430adedc7e6f57013e54d15e6f8dce21e9ea2579","modified":1751763433196},{"_id":"node_modules/hexo-theme-volantis/source/css/_defines/layout.styl","hash":"d1bdce2e7974b1feb585adcdf95e36a054a36ec4","modified":1751763433209},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/base_first.styl","hash":"0b8ae4adffce5a9243c0e7253676d03ecd4a43ba","modified":1751763433161},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/cover_first.styl","hash":"32f0e09eba832607165096c68f70698a75d685b5","modified":1751763433174},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/search_first.styl","hash":"955c9eb68b90b97dba0bd27909347cfc91ce68c5","modified":1751763433223},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/fontfamily_first.styl","hash":"5024a9162f4787ac4234d5b8549fad40dbecf865","modified":1751763433189},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/index.styl","hash":"835b3640c257cd229b20c088536b053b92c9796c","modified":1751763433207},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/dark_first.styl","hash":"bcb419588c1972bd47869309dea43ff319440d33","modified":1751763433179},{"_id":"node_modules/hexo-theme-volantis/source/css/_first/navbar_first.styl","hash":"e268d81dc78fdf9758d314cdc5cc087aec1c70e6","modified":1751763433218},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/aplayer.js","hash":"95f2e47535c8d37e90cab7726d25845cf01ca477","modified":1751763433090},{"_id":"node_modules/hexo-theme-volantis/source/js/search/hexo.js","hash":"4b4ecb0c950b95bed02e0e1274aa50c4989553a3","modified":1751763433126},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenu.js","hash":"cb2f17ab10127065f7b9f5f87a49921d25b287e1","modified":1751763433140},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/parallax.js","hash":"3c3210bde6e86d7d157c34c14796abe98cb1bbd0","modified":1751763433136},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl/coverCtrl.ejs","hash":"ee3f2108e61db024466b08beddb895ad97330f63","modified":1751763432956},{"_id":"node_modules/hexo-theme-volantis/layout/_partial/scripts/_ctrl/cdnCtrl.ejs","hash":"8fe3924efab31cf8a6d7ad07a2985b01a2154acb","modified":1751763432949},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/bbtalk/index.ejs","hash":"bd513c00f6d5fb57e504db7e89c3326d9f68dd88","modified":1751763432984},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/rightMenus.js","hash":"877f548870ea7f63a46de071a120aaea96dd4a25","modified":1751763433141},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/artitalk/index.ejs","hash":"98fb39a1ac55b9af0c1501b051ac2698a3684686","modified":1751763432981},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/fcircle/index.ejs","hash":"2a220187916a0474a083a8f716c0a3b9a8f57548","modified":1751763432987},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/indent/index.ejs","hash":"7d112cde9b8d1785d8c541cde94361e0bfc60f30","modified":1751763432993},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/gitter/index.ejs","hash":"e90bf8daf46f34ca9b37049154dda6d1f155d037","modified":1751763432989},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/katex/index.ejs","hash":"159e21313df49ef1ab14122bfe7e02d2d4f6fcdf","modified":1751763432998},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/mathjax/index.ejs","hash":"91a412d8324fbacd7a340e4ad031b4e917a16f2f","modified":1751763433000},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/gitter/script.ejs","hash":"e4f06c50c23d433a0e63fc703a35704c336ba090","modified":1751763433034},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/beaudar/script.ejs","hash":"285226000b8bff1f96b8b69da268a0af79d04b98","modified":1751763433037},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/chat/tidio/script.ejs","hash":"bb678b5e8a9fb87fc1c1e48914da3a1a052a8e02","modified":1751763433035},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/_page_plugins/snackbar/index.ejs","hash":"bddb75f7112d2b438f462a6ebef79810ef5ac291","modified":1751763433002},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/disqus/script.ejs","hash":"3a67befc560e6d0695f64c05d82c68ee9771a1a7","modified":1751763433040},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/discuss/script.ejs","hash":"b8a13e121923d31a5b6870be84c69e5587f4f0ce","modified":1751763433039},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/artalk/script.ejs","hash":"799633e92efc6abb5d0a9ded8b6db70948dcddad","modified":1751763433036},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/disqusjs/script.ejs","hash":"569912aebbde81490e57ab2ce49e35bf678723f2","modified":1751763433041},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/gitalk/script.ejs","hash":"00a20cd4a398204b1193b0e9d3fac2c5f32daad3","modified":1751763433044},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/giscus/script.ejs","hash":"45fe8d3e47d2a990292426d14091cffa46301704","modified":1751763433042},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/hashover/script.ejs","hash":"7ecd8879c66b907da04093a465d346f6569cee83","modified":1751763433045},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/livere/script.ejs","hash":"54340ba16d4f46ed4f3c6f67ac7ba1a2e68be67a","modified":1751763433047},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/isso/script.ejs","hash":"aa7c81e6df9b803966efe5eda8edbc85b924f34b","modified":1751763433046},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/twikoo/script.ejs","hash":"c0fc694962e94a478b85ae7adb95917fc5f8f2c4","modified":1751763433048},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/z-custom/script.ejs","hash":"e5cfe25fb88b7a3dd0c68e20b2e17d44eb2a1f04","modified":1751763433053},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/waline/script.ejs","hash":"945fa1928c6bd1599134b8627b35d3dd7cd79013","modified":1751763433052},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/vssue/script.ejs","hash":"8171fdfbe668277942eaa55847ba646532d245eb","modified":1751763433050},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/breadcrumblist.js","hash":"df6316082af2df061f16bb01d5b5d3478f98c662","modified":1751763433098},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/blogposting.js","hash":"f8543b0460c9a5b23ee43d8ed49e018c1c627439","modified":1751763433097},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/config.js","hash":"e4c3c23e58f0bac72010f962d92da641445e748a","modified":1751763433108},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/organization.js","hash":"02c08f0362aec5d310b8c7e69823cd88ed49ea5e","modified":1751763433134},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/index.js","hash":"41e4af773dfb4755752cb74a6d70e4b5b0c1ce4d","modified":1751763433131},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/person.js","hash":"afca448311d62a44566d9471594a43495a6be6db","modified":1751763433137},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/highlightjs/script.ejs","hash":"3ffdc0dea93efd49b23910fe7a295784c7053b97","modified":1751763433057},{"_id":"node_modules/hexo-theme-volantis/scripts/helpers/structured-data/lib/website.js","hash":"556f28164d31b3898d06cb8f76472bc6547bb1db","modified":1751763433147},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/comments/utterances/script.ejs","hash":"afbb35e59b3b3af34627416ee47ecad1d564bdbc","modified":1751763433049},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_base/base.styl","hash":"712eb4803dc595eb111ebd89546e6ed3fb1ec7ce","modified":1751763433163},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/article.styl","hash":"8d9fe767bb92fc57681817f21af7b2cdc07b0dc3","modified":1751763433159},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_base/fontfamily_async.styl","hash":"48c006682b8f44681662e4b0f8d3ebfdf85add69","modified":1751763433188},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/footer.styl","hash":"bb850b4707ee025e267e079fcf85484849cf4f41","modified":1751763433190},{"_id":"node_modules/hexo-theme-volantis/layout/_plugins/highlight/prismjs/script.ejs","hash":"1349c07f6a1f3efca0a00f483c918d091007d9b3","modified":1751763433058},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/friends-simpleuser.styl","hash":"07c477e15bf75615faff5587cc82dbc6004a901a","modified":1751763433191},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/archive.styl","hash":"a96709230abbc8d4fc40361b8fc02d4249abb4a1","modified":1751763433158},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/loading.styl","hash":"56a2b9f46edd5b87e49d11647dc9396b0d833d54","modified":1751763433211},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/friends-traditional.styl","hash":"2da0419cd5874d03d7d5bafdb081beb6cb786608","modified":1751763433194},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/img.styl","hash":"55d79f07b717d3e28515b41401f656d1593be624","modified":1751763433199},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/pagination.styl","hash":"65dacf95771fc518a06cbf301f4c0b06201d7321","modified":1751763433220},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/posts.styl","hash":"31cf7bdbb44caa173f3dfd49d98157cb6be85c6f","modified":1751763433221},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/md.styl","hash":"d9b25d8199d3d5260c89e8ad84f1a17531b85588","modified":1751763433215},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/main.styl","hash":"d75ac5fd9ee7cddcbaa421d676c2ae0c4501b121","modified":1751763433213},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/search.styl","hash":"ac9f4c4f6e1ac38757dfeae3483a55983e1491d0","modified":1751763433224},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/snackbar.styl","hash":"752a7fea5284a61fd9305d3b0fcaa43f2e64862f","modified":1751763433226},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/sidebar.styl","hash":"4b75b29b67b88ef5ee365535d521c3ee8256a1ea","modified":1751763433224},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/video.styl","hash":"680e8cf8fc5d62913dad4ccd06135caad2bb3e92","modified":1751763433233},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_layout/toc.styl","hash":"3346fbcbcbc2533997a8bf1fbbf801d9120b03ab","modified":1751763433232},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/checkbox.styl","hash":"8c62dd38914d939069d9222c54787a24cb5c31f7","modified":1751763433165},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/dropmenu.styl","hash":"a136ebb90bedef15c1d8b8d75e09b37c3873f5e8","modified":1751763433182},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/Readme.md","hash":"51986550e80990e1db23e2ee4165e5e4800e4b9f","modified":1751763433154},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/btns.styl","hash":"bf592cd78c146bb671217f106632b9e5bcc7c145","modified":1751763433164},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/frame.styl","hash":"6ffbb29514781aa4fa7d7653706554ce33f4525b","modified":1751763433191},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/fancybox.styl","hash":"1b4709787f9bda8ce565aa9a4aaf7f1f58751b44","modified":1751763433184},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/folding.styl","hash":"253f13e60218e0d014a1df99933f5cdba507f3b1","modified":1751763433186},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/ghcard.styl","hash":"58adb206695a704b1f40df42e2dc10e9e9055aeb","modified":1751763433196},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/friends.styl","hash":"8f9e60b94c02197e4555f923d357017742bf8d7b","modified":1751763433195},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/image.styl","hash":"bb4b07841602592e421597ba8dd7110edec789d8","modified":1751763433199},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/media.styl","hash":"576c9eede3a8f9ec2ba1a970e92a49154ec3acb3","modified":1751763433216},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/link.styl","hash":"82cdcc537612eec3e1af40d00edf80b14116c191","modified":1751763433210},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/table.styl","hash":"ef07ab4fe8a391ea9039fbe53333aaf58e3ce033","modified":1751763433230},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/note.styl","hash":"005d3c55c2216d7c88661f79ad466ad89fad4784","modified":1751763433219},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/span.styl","hash":"6e9f8b453244d9241d3fceed0a56e12c86a4b446","modified":1751763433228},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/sites.styl","hash":"01593f3b8a233bc2c3193796707e4ed77df217bb","modified":1751763433225},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/swiper.styl","hash":"819385594f1825e26074ade900835a3f4031fe42","modified":1751763433229},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/tabs.styl","hash":"a2366f4fe1d9f06e47a7a994cfc80a1edbf6c535","modified":1751763433230},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/tag.json","hash":"506f87e397f258b097ba24ce16c33b5353bab462","modified":1751763433151},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/timeline.styl","hash":"f84f411a3b7dcdbfd4fb19ac4e0f91300c5e19be","modified":1751763433231},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/aplayer.styl","hash":"da809e1dde8adb9d1c98f0daeb52a2d920d497f7","modified":1751763433156},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_tag-plugins/text.styl","hash":"b2c2f3946fb611ad052c61d7309098edbf494c86","modified":1751763433231},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/cursor.styl","hash":"bc055048c7d017be8cf25a3385f516656c96cf66","modified":1751763433175},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/index.styl","hash":"a18de4930b88f62e557e62e8fbb9e2ce550c5d49","modified":1751763433205},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/fontcolor.styl","hash":"fa13f91f8be68b62210048d1481c3b23e23f939b","modified":1751763433187},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/mathjax.styl","hash":"11ee86571f31f9aa61dcc48b40977dcd974d76a4","modified":1751763433214},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/gitalk.styl","hash":"c4c9950fd6654f87ca4f481cf3065ca4069fac48","modified":1751763433198},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/message.styl","hash":"995b46084664f2ed2cf025c1a208089ecfe1147e","modified":1751763433217},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/pjaxanimate.styl","hash":"86c80d1d1c8a02c0eb4c0b5d29ff41c9a5dd5ac3","modified":1751763433221},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/friends.js","hash":"7d53cf366638d0e254f7f26de01c8892710d1d23","modified":1751763433120},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/contributors.js","hash":"cf1af362cf73c83a28ae2651eb1daafaed2ec91f","modified":1751763433113},{"_id":"node_modules/hexo-theme-volantis/source/js/plugins/tags/sites.js","hash":"47b0ff4a3ccea2da9b60023cb4288f979504b0c7","modified":1751763433144},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_rightmenu/reading.styl","hash":"cb01065424dbd32c79b973b06fcdbc1c72917bc6","modified":1751763433222},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_dark/dark_plugins.styl","hash":"c56c2271847809e21e4938d770577622aeb161aa","modified":1751763433180},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_rightmenu/rightmenu.styl","hash":"ef456a92173c303b61015f3581450aa14f0d2b41","modified":1751763433223},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_dark/dark_async.styl","hash":"a5da6f0b232a767057321fa51e382fd2d86bd98d","modified":1751763433177},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/index.styl","hash":"38089b686a0cfdde555539c1c0c5b3fe402afada","modified":1751763433200},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/clipboard.styl","hash":"0f92935e3bb9732b6e1cc7f305577144f1fe99a8","modified":1751763433170},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/index.styl","hash":"6c681c760fa63425e7564c0d68532bb5ac95690a","modified":1751763433202},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/clipboard.styl","hash":"6818ba853fd6a319ff4eb50d228b1d625db9a0fd","modified":1751763433167},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/language.styl","hash":"4fade2fe067f557d3b420d0b9a9d88d18feb9a72","modified":1751763433208},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/index.styl","hash":"215face68fab1c31cfa8d4c21941c72efe54cb78","modified":1751763433203},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/prismjs/language.styl","hash":"3af7fae25a0e2c54f0aacb1d8cbe383d5c1e60a5","modified":1751763433209},{"_id":"node_modules/hexo-theme-volantis/source/css/_style/_plugins/_highlight/highlightjs/color.styl","hash":"319ccc46d5d387ee14a22e0de1a518288331629b","modified":1751763433174},{"_id":"source/_posts/01-3d_game_developing.md","hash":"622fa4c25621917737223bea52fb76dc2b984e45","modified":1752027197573},{"_id":"source/_posts/02-Web_study.md","hash":"da454b33ed1cb220d631bf5b27aaa5b352590e2a","modified":1752027209966},{"_id":"source/_posts/03-ACM-hangdianoj-peactice-questions.md","hash":"8f6d77411bbfd87a6936ed4f6376d919a79caeaa","modified":1751766931008},{"_id":"source/_posts/04-ACM-algorithm-recursion.md","hash":"e32f239ebfcb256528e6d176ce6d2c506213c8d1","modified":1752023903791},{"_id":"source/_posts/07-ACM-homework-7.22.md","hash":"55af3122632c3cdbbef7a3b4ab0ab306c10d11ad","modified":1752023463711},{"_id":"source/_posts/06-ACM-homework-7.21.md","hash":"70de37c0ba93e4a430737fe8aa1c02f64a93c8cc","modified":1752021753964},{"_id":"source/_posts/05-ACM-algorithm-greedy.md","hash":"90424e3f65498183567b1eecf984d0c4cfd96400","modified":1752027468279},{"_id":"source/_posts/11-ACM-middlecollege-7-25.md","hash":"fad6213607cfb41e65df43d850bf2faf1e67b64e","modified":1752027004920},{"_id":"source/_posts/10-ACM-homework-7-25.md","hash":"d9c6f6603ae7ccf911eb0cf2c6200fb96b0ddbf2","modified":1752027002080},{"_id":"source/_posts/08-ACM-homework-7-23.md","hash":"bcf8303d2facd39b89f037fb39a3648114d75a0c","modified":1752023746473},{"_id":"source/_posts/09-ACM-algorithm-search.md","hash":"2531cf51db32127b8d92122e6c2105b5373e3d38","modified":1752024096198}],"Category":[{"name":"技术随笔","_id":"cmcr40e180001mwnf4phl9wh8"},{"name":"算法入门","_id":"cmcr40e1c000fmwnf83d10mar"},{"name":"刷题经验","parent":"cmcr40e1c000fmwnf83d10mar","_id":"cmcr40e1d000jmwnfcgr45w6n"}],"Data":[],"Page":[],"Post":[{"title":"3D 游戏开发阶段总结","date":"2025-07-01T01:13:44.000Z","_content":"\n# 3D 游戏开发阶段总结\n\n> 一篇面向有志于从事 3D 游戏开发的朋友的成长路线图，分为四个阶段，从入门到达人。希望能帮你明确方向，找到适合自己的成长节奏。\n\n---\n\n## 第一阶段：初学者阶段\n\n这个阶段的目标是打好图形学基础，掌握空间变换与基本 API 使用。\n\n- **重点掌握内容：**\n\n  - 3D 图形学的基本原理\n  - 坐标变换、矩阵、向量的概念与运用\n  - 简单渲染流程：模型加载、摄像机、光照等\n  - 基本图形 API（如 OpenGL、DirectX、WebGL）使用\n\n- **学习方式：**\n  - 看书（如《OpenGL 编程指南》《Real-Time Rendering》）\n  - 看 demo，模仿、调试\n  - 动手写代码，完成基础功能\n- **达成目标：**\n\n  - 能用简单资源制作一个小 demo（如加载模型并旋转显示）\n\n- **推荐时长：**\n  - 自学：6~12 个月（取决于图形学基础）\n\n---\n\n## 第二阶段：进阶阶段（应用与效果提升）\n\n初步掌握基础后，通常会分成两类方向：\n\n### 方向一：走向引擎，参与游戏开发\n\n### 方向二：深挖图形原理，研究场景管理和高级渲染\n\n- **常见学习内容：**\n\n  - 阴影、法线贴图、HDR、反射折射等高级效果\n  - 优化技巧（如 LOD、批处理、DrawCall 管理）\n  - 简单的场景管理方案设计（空间划分、层级管理等）\n  - 熟悉至少一款引擎（Unity、Unreal、Godot 等）\n\n- **学习方式：**\n\n  - 写效果 demo（如实时水面、体积雾、PBR 材质等）\n  - 研究开源引擎或修改小型引擎代码\n  - 参与团队项目或个人项目开发\n\n- **常见瓶颈：**\n\n  - 代码能跑，但不理解原理\n  - 缺乏复杂场景设计经验\n  - 技术孤岛：各项技术之间缺少整合能力\n\n- **推荐时长：**\n  - 自学：1~2 年，实践+理论结合效果更佳\n\n---\n\n## 第三阶段：3D 成熟阶段（系统集成与性能优化）\n\n这个阶段的标志是：**你不再仅仅追求效果，而开始关注“效率”和“系统设计”**。\n\n- **关键任务：**\n\n  - 资源与带宽优化（如资源复用、GPU 占用优化）\n  - 场景系统重构：为复杂游戏构建可扩展系统\n  - 深入显卡原理，理解 GPU 流水线并进行定向优化\n  - 自定义材质系统、Effect 框架搭建\n  - 精通图形调试（RenderDoc、Nsight、PIX 等）\n\n- **常见成长路径：**\n\n  - 自主编写一个小型 3D 引擎（或深度修改现有引擎）\n  - 针对不同游戏类型定制场景系统与渲染方案\n  - 具备解决“为什么慢、哪里慢、怎么快”的能力\n\n- **推荐时长：**\n\n  - ≥1 年（高手带，悟性高者可更快）\n  - 对多数人来说，这已是图形方向程序员的高阶水平\n\n- **阶段特征：**\n  - 技术整合能力突出，具备独立解决复杂问题的能力\n  - debug、优化变得自然高效\n  - 能设计出支撑大型场景的系统架构\n\n---\n\n## 第四阶段：达人阶段（技术之外的更高层）\n\n这阶段不再是“研究技术”，而是**创造体系、传递价值**。\n\n- **核心变化：**\n\n  - 不满足现有工具，尝试创建属于自己的引擎或架构\n  - 具备完整项目从立项到上线的全流程经验\n  - 带团队、指导他人，追求产品和技术以外的影响力\n\n- **关注点转变：**\n\n  - 技术只是基础，开始关注设计、用户体验、性能成本比\n  - 与美术、策划等非技术人员协作更加顺畅\n  - 希望输出有价值的产品和思想，被行业广泛认可\n\n- **常见表现：**\n\n  - 搭建引擎团队、技术主导整款游戏开发\n  - 写出有传播力的文章/课程/工具\n  - 在社区（如 GameRes、知乎、知乎 Live、B 站）持续输出\n\n- **阶段特征：**\n  - 知道“技术”不能解决一切\n  - 更懂“为什么做”和“做给谁看”\n  - 技术与思维、审美、沟通协作能力并重\n\n---\n\n## 补充说明：第二阶段与第三阶段的关键转折点\n\n要从**第二阶段迈向第三阶段**，有一个明显的分界线：\n\n- **你必须开始写引擎，或至少主动修改引擎**\n- 第二阶段是“练功夫”：各种特效、技术点、功能堆叠\n- 第三阶段是“实战演练”：将分散的技能整合，解决真实问题\n\n就像武术修炼一样，第二阶段是学套路，第三阶段是上擂台。\n\n在第三阶段，常常会有“顿悟”，这来源于实践、碰壁和突破。\n\n---\n\n## 写在最后\n\n这个阶段划分不是绝对的，每个人的起点、目标、环境都不同。但愿你能对照一下自己，看看目前在哪一阶段，以及下一步该往哪里走。\n\n**只要不停止学习，你就是在进步。**\n","source":"_posts/01-3d_game_developing.md","raw":"---\ntitle: 3D 游戏开发阶段总结\ndate: 2025-07-01 09:13:44\ntags:\n  - 游戏开发\n  - 碎碎念\ncategories:\n  - 技术随笔\n---\n\n# 3D 游戏开发阶段总结\n\n> 一篇面向有志于从事 3D 游戏开发的朋友的成长路线图，分为四个阶段，从入门到达人。希望能帮你明确方向，找到适合自己的成长节奏。\n\n---\n\n## 第一阶段：初学者阶段\n\n这个阶段的目标是打好图形学基础，掌握空间变换与基本 API 使用。\n\n- **重点掌握内容：**\n\n  - 3D 图形学的基本原理\n  - 坐标变换、矩阵、向量的概念与运用\n  - 简单渲染流程：模型加载、摄像机、光照等\n  - 基本图形 API（如 OpenGL、DirectX、WebGL）使用\n\n- **学习方式：**\n  - 看书（如《OpenGL 编程指南》《Real-Time Rendering》）\n  - 看 demo，模仿、调试\n  - 动手写代码，完成基础功能\n- **达成目标：**\n\n  - 能用简单资源制作一个小 demo（如加载模型并旋转显示）\n\n- **推荐时长：**\n  - 自学：6~12 个月（取决于图形学基础）\n\n---\n\n## 第二阶段：进阶阶段（应用与效果提升）\n\n初步掌握基础后，通常会分成两类方向：\n\n### 方向一：走向引擎，参与游戏开发\n\n### 方向二：深挖图形原理，研究场景管理和高级渲染\n\n- **常见学习内容：**\n\n  - 阴影、法线贴图、HDR、反射折射等高级效果\n  - 优化技巧（如 LOD、批处理、DrawCall 管理）\n  - 简单的场景管理方案设计（空间划分、层级管理等）\n  - 熟悉至少一款引擎（Unity、Unreal、Godot 等）\n\n- **学习方式：**\n\n  - 写效果 demo（如实时水面、体积雾、PBR 材质等）\n  - 研究开源引擎或修改小型引擎代码\n  - 参与团队项目或个人项目开发\n\n- **常见瓶颈：**\n\n  - 代码能跑，但不理解原理\n  - 缺乏复杂场景设计经验\n  - 技术孤岛：各项技术之间缺少整合能力\n\n- **推荐时长：**\n  - 自学：1~2 年，实践+理论结合效果更佳\n\n---\n\n## 第三阶段：3D 成熟阶段（系统集成与性能优化）\n\n这个阶段的标志是：**你不再仅仅追求效果，而开始关注“效率”和“系统设计”**。\n\n- **关键任务：**\n\n  - 资源与带宽优化（如资源复用、GPU 占用优化）\n  - 场景系统重构：为复杂游戏构建可扩展系统\n  - 深入显卡原理，理解 GPU 流水线并进行定向优化\n  - 自定义材质系统、Effect 框架搭建\n  - 精通图形调试（RenderDoc、Nsight、PIX 等）\n\n- **常见成长路径：**\n\n  - 自主编写一个小型 3D 引擎（或深度修改现有引擎）\n  - 针对不同游戏类型定制场景系统与渲染方案\n  - 具备解决“为什么慢、哪里慢、怎么快”的能力\n\n- **推荐时长：**\n\n  - ≥1 年（高手带，悟性高者可更快）\n  - 对多数人来说，这已是图形方向程序员的高阶水平\n\n- **阶段特征：**\n  - 技术整合能力突出，具备独立解决复杂问题的能力\n  - debug、优化变得自然高效\n  - 能设计出支撑大型场景的系统架构\n\n---\n\n## 第四阶段：达人阶段（技术之外的更高层）\n\n这阶段不再是“研究技术”，而是**创造体系、传递价值**。\n\n- **核心变化：**\n\n  - 不满足现有工具，尝试创建属于自己的引擎或架构\n  - 具备完整项目从立项到上线的全流程经验\n  - 带团队、指导他人，追求产品和技术以外的影响力\n\n- **关注点转变：**\n\n  - 技术只是基础，开始关注设计、用户体验、性能成本比\n  - 与美术、策划等非技术人员协作更加顺畅\n  - 希望输出有价值的产品和思想，被行业广泛认可\n\n- **常见表现：**\n\n  - 搭建引擎团队、技术主导整款游戏开发\n  - 写出有传播力的文章/课程/工具\n  - 在社区（如 GameRes、知乎、知乎 Live、B 站）持续输出\n\n- **阶段特征：**\n  - 知道“技术”不能解决一切\n  - 更懂“为什么做”和“做给谁看”\n  - 技术与思维、审美、沟通协作能力并重\n\n---\n\n## 补充说明：第二阶段与第三阶段的关键转折点\n\n要从**第二阶段迈向第三阶段**，有一个明显的分界线：\n\n- **你必须开始写引擎，或至少主动修改引擎**\n- 第二阶段是“练功夫”：各种特效、技术点、功能堆叠\n- 第三阶段是“实战演练”：将分散的技能整合，解决真实问题\n\n就像武术修炼一样，第二阶段是学套路，第三阶段是上擂台。\n\n在第三阶段，常常会有“顿悟”，这来源于实践、碰壁和突破。\n\n---\n\n## 写在最后\n\n这个阶段划分不是绝对的，每个人的起点、目标、环境都不同。但愿你能对照一下自己，看看目前在哪一阶段，以及下一步该往哪里走。\n\n**只要不停止学习，你就是在进步。**\n","slug":"01-3d_game_developing","published":1,"updated":"2025-07-06T01:23:52.517Z","_id":"cmcqyxcah000258nf059u7xg8","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"3D-游戏开发阶段总结\"><a href=\"#3D-游戏开发阶段总结\" class=\"headerlink\" title=\"3D 游戏开发阶段总结\"></a>3D 游戏开发阶段总结</h1><blockquote>\n<p>一篇面向有志于从事 3D 游戏开发的朋友的成长路线图，分为四个阶段，从入门到达人。希望能帮你明确方向，找到适合自己的成长节奏。</p>\n</blockquote>\n<hr>\n<h2 id=\"第一阶段：初学者阶段\"><a href=\"#第一阶段：初学者阶段\" class=\"headerlink\" title=\"第一阶段：初学者阶段\"></a>第一阶段：初学者阶段</h2><p>这个阶段的目标是打好图形学基础，掌握空间变换与基本 API 使用。</p>\n<ul>\n<li><p><strong>重点掌握内容：</strong></p>\n<ul>\n<li>3D 图形学的基本原理</li>\n<li>坐标变换、矩阵、向量的概念与运用</li>\n<li>简单渲染流程：模型加载、摄像机、光照等</li>\n<li>基本图形 API（如 OpenGL、DirectX、WebGL）使用</li>\n</ul>\n</li>\n<li><p><strong>学习方式：</strong></p>\n<ul>\n<li>看书（如《OpenGL 编程指南》《Real-Time Rendering》）</li>\n<li>看 demo，模仿、调试</li>\n<li>动手写代码，完成基础功能</li>\n</ul>\n</li>\n<li><p><strong>达成目标：</strong></p>\n<ul>\n<li>能用简单资源制作一个小 demo（如加载模型并旋转显示）</li>\n</ul>\n</li>\n<li><p><strong>推荐时长：</strong></p>\n<ul>\n<li>自学：6~12 个月（取决于图形学基础）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第二阶段：进阶阶段（应用与效果提升）\"><a href=\"#第二阶段：进阶阶段（应用与效果提升）\" class=\"headerlink\" title=\"第二阶段：进阶阶段（应用与效果提升）\"></a>第二阶段：进阶阶段（应用与效果提升）</h2><p>初步掌握基础后，通常会分成两类方向：</p>\n<h3 id=\"方向一：走向引擎，参与游戏开发\"><a href=\"#方向一：走向引擎，参与游戏开发\" class=\"headerlink\" title=\"方向一：走向引擎，参与游戏开发\"></a>方向一：走向引擎，参与游戏开发</h3><h3 id=\"方向二：深挖图形原理，研究场景管理和高级渲染\"><a href=\"#方向二：深挖图形原理，研究场景管理和高级渲染\" class=\"headerlink\" title=\"方向二：深挖图形原理，研究场景管理和高级渲染\"></a>方向二：深挖图形原理，研究场景管理和高级渲染</h3><ul>\n<li><p><strong>常见学习内容：</strong></p>\n<ul>\n<li>阴影、法线贴图、HDR、反射折射等高级效果</li>\n<li>优化技巧（如 LOD、批处理、DrawCall 管理）</li>\n<li>简单的场景管理方案设计（空间划分、层级管理等）</li>\n<li>熟悉至少一款引擎（Unity、Unreal、Godot 等）</li>\n</ul>\n</li>\n<li><p><strong>学习方式：</strong></p>\n<ul>\n<li>写效果 demo（如实时水面、体积雾、PBR 材质等）</li>\n<li>研究开源引擎或修改小型引擎代码</li>\n<li>参与团队项目或个人项目开发</li>\n</ul>\n</li>\n<li><p><strong>常见瓶颈：</strong></p>\n<ul>\n<li>代码能跑，但不理解原理</li>\n<li>缺乏复杂场景设计经验</li>\n<li>技术孤岛：各项技术之间缺少整合能力</li>\n</ul>\n</li>\n<li><p><strong>推荐时长：</strong></p>\n<ul>\n<li>自学：1~2 年，实践+理论结合效果更佳</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第三阶段：3D-成熟阶段（系统集成与性能优化）\"><a href=\"#第三阶段：3D-成熟阶段（系统集成与性能优化）\" class=\"headerlink\" title=\"第三阶段：3D 成熟阶段（系统集成与性能优化）\"></a>第三阶段：3D 成熟阶段（系统集成与性能优化）</h2><p>这个阶段的标志是：<strong>你不再仅仅追求效果，而开始关注“效率”和“系统设计”</strong>。</p>\n<ul>\n<li><p><strong>关键任务：</strong></p>\n<ul>\n<li>资源与带宽优化（如资源复用、GPU 占用优化）</li>\n<li>场景系统重构：为复杂游戏构建可扩展系统</li>\n<li>深入显卡原理，理解 GPU 流水线并进行定向优化</li>\n<li>自定义材质系统、Effect 框架搭建</li>\n<li>精通图形调试（RenderDoc、Nsight、PIX 等）</li>\n</ul>\n</li>\n<li><p><strong>常见成长路径：</strong></p>\n<ul>\n<li>自主编写一个小型 3D 引擎（或深度修改现有引擎）</li>\n<li>针对不同游戏类型定制场景系统与渲染方案</li>\n<li>具备解决“为什么慢、哪里慢、怎么快”的能力</li>\n</ul>\n</li>\n<li><p><strong>推荐时长：</strong></p>\n<ul>\n<li>≥1 年（高手带，悟性高者可更快）</li>\n<li>对多数人来说，这已是图形方向程序员的高阶水平</li>\n</ul>\n</li>\n<li><p><strong>阶段特征：</strong></p>\n<ul>\n<li>技术整合能力突出，具备独立解决复杂问题的能力</li>\n<li>debug、优化变得自然高效</li>\n<li>能设计出支撑大型场景的系统架构</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第四阶段：达人阶段（技术之外的更高层）\"><a href=\"#第四阶段：达人阶段（技术之外的更高层）\" class=\"headerlink\" title=\"第四阶段：达人阶段（技术之外的更高层）\"></a>第四阶段：达人阶段（技术之外的更高层）</h2><p>这阶段不再是“研究技术”，而是<strong>创造体系、传递价值</strong>。</p>\n<ul>\n<li><p><strong>核心变化：</strong></p>\n<ul>\n<li>不满足现有工具，尝试创建属于自己的引擎或架构</li>\n<li>具备完整项目从立项到上线的全流程经验</li>\n<li>带团队、指导他人，追求产品和技术以外的影响力</li>\n</ul>\n</li>\n<li><p><strong>关注点转变：</strong></p>\n<ul>\n<li>技术只是基础，开始关注设计、用户体验、性能成本比</li>\n<li>与美术、策划等非技术人员协作更加顺畅</li>\n<li>希望输出有价值的产品和思想，被行业广泛认可</li>\n</ul>\n</li>\n<li><p><strong>常见表现：</strong></p>\n<ul>\n<li>搭建引擎团队、技术主导整款游戏开发</li>\n<li>写出有传播力的文章&#x2F;课程&#x2F;工具</li>\n<li>在社区（如 GameRes、知乎、知乎 Live、B 站）持续输出</li>\n</ul>\n</li>\n<li><p><strong>阶段特征：</strong></p>\n<ul>\n<li>知道“技术”不能解决一切</li>\n<li>更懂“为什么做”和“做给谁看”</li>\n<li>技术与思维、审美、沟通协作能力并重</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"补充说明：第二阶段与第三阶段的关键转折点\"><a href=\"#补充说明：第二阶段与第三阶段的关键转折点\" class=\"headerlink\" title=\"补充说明：第二阶段与第三阶段的关键转折点\"></a>补充说明：第二阶段与第三阶段的关键转折点</h2><p>要从<strong>第二阶段迈向第三阶段</strong>，有一个明显的分界线：</p>\n<ul>\n<li><strong>你必须开始写引擎，或至少主动修改引擎</strong></li>\n<li>第二阶段是“练功夫”：各种特效、技术点、功能堆叠</li>\n<li>第三阶段是“实战演练”：将分散的技能整合，解决真实问题</li>\n</ul>\n<p>就像武术修炼一样，第二阶段是学套路，第三阶段是上擂台。</p>\n<p>在第三阶段，常常会有“顿悟”，这来源于实践、碰壁和突破。</p>\n<hr>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>这个阶段划分不是绝对的，每个人的起点、目标、环境都不同。但愿你能对照一下自己，看看目前在哪一阶段，以及下一步该往哪里走。</p>\n<p><strong>只要不停止学习，你就是在进步。</strong></p>\n","excerpt":"","more":"<h1 id=\"3D-游戏开发阶段总结\"><a href=\"#3D-游戏开发阶段总结\" class=\"headerlink\" title=\"3D 游戏开发阶段总结\"></a>3D 游戏开发阶段总结</h1><blockquote>\n<p>一篇面向有志于从事 3D 游戏开发的朋友的成长路线图，分为四个阶段，从入门到达人。希望能帮你明确方向，找到适合自己的成长节奏。</p>\n</blockquote>\n<hr>\n<h2 id=\"第一阶段：初学者阶段\"><a href=\"#第一阶段：初学者阶段\" class=\"headerlink\" title=\"第一阶段：初学者阶段\"></a>第一阶段：初学者阶段</h2><p>这个阶段的目标是打好图形学基础，掌握空间变换与基本 API 使用。</p>\n<ul>\n<li><p><strong>重点掌握内容：</strong></p>\n<ul>\n<li>3D 图形学的基本原理</li>\n<li>坐标变换、矩阵、向量的概念与运用</li>\n<li>简单渲染流程：模型加载、摄像机、光照等</li>\n<li>基本图形 API（如 OpenGL、DirectX、WebGL）使用</li>\n</ul>\n</li>\n<li><p><strong>学习方式：</strong></p>\n<ul>\n<li>看书（如《OpenGL 编程指南》《Real-Time Rendering》）</li>\n<li>看 demo，模仿、调试</li>\n<li>动手写代码，完成基础功能</li>\n</ul>\n</li>\n<li><p><strong>达成目标：</strong></p>\n<ul>\n<li>能用简单资源制作一个小 demo（如加载模型并旋转显示）</li>\n</ul>\n</li>\n<li><p><strong>推荐时长：</strong></p>\n<ul>\n<li>自学：6~12 个月（取决于图形学基础）</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第二阶段：进阶阶段（应用与效果提升）\"><a href=\"#第二阶段：进阶阶段（应用与效果提升）\" class=\"headerlink\" title=\"第二阶段：进阶阶段（应用与效果提升）\"></a>第二阶段：进阶阶段（应用与效果提升）</h2><p>初步掌握基础后，通常会分成两类方向：</p>\n<h3 id=\"方向一：走向引擎，参与游戏开发\"><a href=\"#方向一：走向引擎，参与游戏开发\" class=\"headerlink\" title=\"方向一：走向引擎，参与游戏开发\"></a>方向一：走向引擎，参与游戏开发</h3><h3 id=\"方向二：深挖图形原理，研究场景管理和高级渲染\"><a href=\"#方向二：深挖图形原理，研究场景管理和高级渲染\" class=\"headerlink\" title=\"方向二：深挖图形原理，研究场景管理和高级渲染\"></a>方向二：深挖图形原理，研究场景管理和高级渲染</h3><ul>\n<li><p><strong>常见学习内容：</strong></p>\n<ul>\n<li>阴影、法线贴图、HDR、反射折射等高级效果</li>\n<li>优化技巧（如 LOD、批处理、DrawCall 管理）</li>\n<li>简单的场景管理方案设计（空间划分、层级管理等）</li>\n<li>熟悉至少一款引擎（Unity、Unreal、Godot 等）</li>\n</ul>\n</li>\n<li><p><strong>学习方式：</strong></p>\n<ul>\n<li>写效果 demo（如实时水面、体积雾、PBR 材质等）</li>\n<li>研究开源引擎或修改小型引擎代码</li>\n<li>参与团队项目或个人项目开发</li>\n</ul>\n</li>\n<li><p><strong>常见瓶颈：</strong></p>\n<ul>\n<li>代码能跑，但不理解原理</li>\n<li>缺乏复杂场景设计经验</li>\n<li>技术孤岛：各项技术之间缺少整合能力</li>\n</ul>\n</li>\n<li><p><strong>推荐时长：</strong></p>\n<ul>\n<li>自学：1~2 年，实践+理论结合效果更佳</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第三阶段：3D-成熟阶段（系统集成与性能优化）\"><a href=\"#第三阶段：3D-成熟阶段（系统集成与性能优化）\" class=\"headerlink\" title=\"第三阶段：3D 成熟阶段（系统集成与性能优化）\"></a>第三阶段：3D 成熟阶段（系统集成与性能优化）</h2><p>这个阶段的标志是：<strong>你不再仅仅追求效果，而开始关注“效率”和“系统设计”</strong>。</p>\n<ul>\n<li><p><strong>关键任务：</strong></p>\n<ul>\n<li>资源与带宽优化（如资源复用、GPU 占用优化）</li>\n<li>场景系统重构：为复杂游戏构建可扩展系统</li>\n<li>深入显卡原理，理解 GPU 流水线并进行定向优化</li>\n<li>自定义材质系统、Effect 框架搭建</li>\n<li>精通图形调试（RenderDoc、Nsight、PIX 等）</li>\n</ul>\n</li>\n<li><p><strong>常见成长路径：</strong></p>\n<ul>\n<li>自主编写一个小型 3D 引擎（或深度修改现有引擎）</li>\n<li>针对不同游戏类型定制场景系统与渲染方案</li>\n<li>具备解决“为什么慢、哪里慢、怎么快”的能力</li>\n</ul>\n</li>\n<li><p><strong>推荐时长：</strong></p>\n<ul>\n<li>≥1 年（高手带，悟性高者可更快）</li>\n<li>对多数人来说，这已是图形方向程序员的高阶水平</li>\n</ul>\n</li>\n<li><p><strong>阶段特征：</strong></p>\n<ul>\n<li>技术整合能力突出，具备独立解决复杂问题的能力</li>\n<li>debug、优化变得自然高效</li>\n<li>能设计出支撑大型场景的系统架构</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"第四阶段：达人阶段（技术之外的更高层）\"><a href=\"#第四阶段：达人阶段（技术之外的更高层）\" class=\"headerlink\" title=\"第四阶段：达人阶段（技术之外的更高层）\"></a>第四阶段：达人阶段（技术之外的更高层）</h2><p>这阶段不再是“研究技术”，而是<strong>创造体系、传递价值</strong>。</p>\n<ul>\n<li><p><strong>核心变化：</strong></p>\n<ul>\n<li>不满足现有工具，尝试创建属于自己的引擎或架构</li>\n<li>具备完整项目从立项到上线的全流程经验</li>\n<li>带团队、指导他人，追求产品和技术以外的影响力</li>\n</ul>\n</li>\n<li><p><strong>关注点转变：</strong></p>\n<ul>\n<li>技术只是基础，开始关注设计、用户体验、性能成本比</li>\n<li>与美术、策划等非技术人员协作更加顺畅</li>\n<li>希望输出有价值的产品和思想，被行业广泛认可</li>\n</ul>\n</li>\n<li><p><strong>常见表现：</strong></p>\n<ul>\n<li>搭建引擎团队、技术主导整款游戏开发</li>\n<li>写出有传播力的文章&#x2F;课程&#x2F;工具</li>\n<li>在社区（如 GameRes、知乎、知乎 Live、B 站）持续输出</li>\n</ul>\n</li>\n<li><p><strong>阶段特征：</strong></p>\n<ul>\n<li>知道“技术”不能解决一切</li>\n<li>更懂“为什么做”和“做给谁看”</li>\n<li>技术与思维、审美、沟通协作能力并重</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"补充说明：第二阶段与第三阶段的关键转折点\"><a href=\"#补充说明：第二阶段与第三阶段的关键转折点\" class=\"headerlink\" title=\"补充说明：第二阶段与第三阶段的关键转折点\"></a>补充说明：第二阶段与第三阶段的关键转折点</h2><p>要从<strong>第二阶段迈向第三阶段</strong>，有一个明显的分界线：</p>\n<ul>\n<li><strong>你必须开始写引擎，或至少主动修改引擎</strong></li>\n<li>第二阶段是“练功夫”：各种特效、技术点、功能堆叠</li>\n<li>第三阶段是“实战演练”：将分散的技能整合，解决真实问题</li>\n</ul>\n<p>就像武术修炼一样，第二阶段是学套路，第三阶段是上擂台。</p>\n<p>在第三阶段，常常会有“顿悟”，这来源于实践、碰壁和突破。</p>\n<hr>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>这个阶段划分不是绝对的，每个人的起点、目标、环境都不同。但愿你能对照一下自己，看看目前在哪一阶段，以及下一步该往哪里走。</p>\n<p><strong>只要不停止学习，你就是在进步。</strong></p>\n"},{"title":"等等，真的要重新选择一个方向开始吗？——–前端学习(草)","date":"2025-07-01T01:13:44.000Z","_content":"\n# 等等，真的要重新选择一个方向开始吗？——–前端学习(草)\n\n## 为什么学习前端？\n\n我想这应该是最重要的问题了，就好像我当初为什么要选择代码事业一样，没什么就是因为喜欢，在这个代码领域，现在我还有学长可以依靠，现在基本在一个领域挖掘越深了解的人越少，不扯了，总之如果说就业的话，说现在互联网已经人满为患的话，那都是屁话，现在没本事又想乘上互联网这趟列车的人多得是，随便加一个代码交流群就知道了。没本事又觉得自己很厉害的人多得是，但是我依旧认为自己应该成为什么样的人？其实有些问题仁者见仁，智者见智，随便逛一下 B 站翻一下弹幕和评论就知道现在的人有多么的恶臭了，例：[别再编那些垃圾假项目经验了，我来教程序员新人求职如何脱颖而出(https://www.bilibili.com/video/BV1zx411R7tb)](https://www.bilibili.com/video/BV1zx411R7tb/?vd_source=3dafe751afaac2d3acd4f464c3870eff)这个视频我看到了明明是重要的分享视频，但是弹幕不给力，一直发无关紧要的弹幕什么衣领，这啊那啊，反而重要的东西没把握住，这个视频想告诉我们一个正确的目标，一个好的程序员是怎么来的？就是那句话：从一个点出发到一个面一个体。这些应该算是好的分享了，因为他告诉了你怎么去思考，学习。比如古人通过在船驶进港口总是先看到船的船桅，这就证明了地球是圆的，牛顿通过一颗落下的苹果，感受到了万有引力。其实伟大的科学发现就是这样通过一件小得不能再小的事发现的，在于主动思考，能有一种主动思考的能力，这才是重要的，这才是你拿得出去的东西，才能形成竞争力。[一眼就知道这是培训出来的简历，为什么？(https://www.bilibili.com/video/BV1QJ411X7mk)](https://www.bilibili.com/video/BV1QJ411X7mk)\n\n> 哈哈哈，2025 年看这段话真的草 😂😂，也算真情流露，就保留着吧。\n\n## 前端学习方向\n\n前端学习可以分为几个阶段，每个阶段的重点不一样，建议循序渐进。\n\n---\n\n### 一、基础阶段：前端三剑客打牢基础\n\n**目标**：掌握前端开发的基本构建模块。\n\n- **HTML**：网页的结构骨架\n- **CSS**：网页的美化师\n- **JavaScript**：网页的灵魂\n\n#### 推荐项目练习\n\n- 仿照写一个登录页、个人主页、计算器等。\n\n#### 推荐学习网站\n\n- [前端九部](https://www.yuque.com/fe9/basic)：内容扎实、通俗易懂\n- [MDN Web Docs](https://developer.mozilla.org/zh-CN/)：HTML/CSS/JS 权威文档\n- [w3schools](https://www.w3schools.com/)：交互式学习平台，适合入门\n- [菜鸟教程](https://www.runoob.com/)：国内入门教程利器\n- [codepen.io](https://codepen.io/)：看别人是怎么写页面的，适合模仿学习\n\n---\n\n### 二、进阶阶段：真正具备“开发能力”\n\n**目标**：掌握项目开发流程与调试技巧，能独立开发简单页面。\n\n- **JavaScript 进阶**\n- **浏览器原理理解**\n- **调试与版本控制工具**\n\n#### 推荐项目练习\n\n- TodoList、新闻展示页、豆瓣电影页面仿写等。\n\n#### 推荐学习网站\n\n- [JavaScript.info](https://zh.javascript.info/)：现代 JS 教程，非常系统\n- [Bilibili 前端进阶课程合集](https://search.bilibili.com/all?keyword=JavaScript%20%E8%BF%9B%E9%98%B6)\n- [Git 官方文档（中文）](https://git-scm.com/book/zh/v2)\n- [Chrome DevTools 学习资源](https://developer.chrome.com/docs/devtools/)\n\n---\n\n### 三、框架阶段：现代前端的标配\n\n**目标**：掌握主流前端框架，进入“企业项目实战”的门槛。\n\n- **React / Vue**\n- **构建工具链**\n- **响应式布局和适配**\n\n#### 推荐项目练习\n\n- 后台管理系统、简易博客系统、仿某 App 页面等。\n\n#### 推荐学习网站\n\n- [Vue 官方文档](https://cn.vuejs.org/)（建议从 Vue 3 开始）\n- [React 官方文档](https://react.dev/)（新版文档更适合新手）\n- [Vite 官方文档](https://vitejs.dev/)（现代构建工具）\n- [Webpack 中文网](https://webpack.docschina.org/)\n- [掘金前端专栏](https://juejin.cn/frontend)：海量实战和踩坑经验分享\n\n---\n\n### 四、全栈与工程化方向（可选）\n\n**目标**：成为独立开发者，或为高级岗位打基础。\n\n- 前端工程化理念\n- Node.js 后端开发\n- 数据库基础\n- SSR / SEO 等进阶话题\n\n#### 推荐项目练习\n\n- 简易博客系统（前后端分离）\n- Markdown 笔记管理系统\n- 静态博客生成器（如 Hexo/Next.js）\n\n#### 推荐学习网站\n\n- [Node.js 中文网](https://nodejs.cn/)\n- [MongoDB 官方教程](https://www.mongodb.com/docs/manual/)\n- [Next.js 官方文档](https://nextjs.org/)\n- [TypeScript 官方文档（中文）](https://www.tslang.cn/docs/home.html)\n- [Full Stack Open](https://fullstackopen.com/)：芬兰大学开设的超高质量全栈课程（英文）\n\n---\n\n## 学习建议\n\n1. **项目导向学习**：不要只刷语法，做出一个完整页面再优化它。\n2. **阅读优秀代码**：GitHub、CodePen、Vue 源码、React 源码学习。\n3. **多做总结笔记**：写博客 / 公众号 / 文档，把“输入”变成“输出”。\n4. **交流学习**：加入开发者社群，和比你优秀的人交流。\n   - 微信群 / QQ 群：搜索“前端技术交流群”\n   - GitHub：参与开源项目，学习规范写法\n   - B 站、知乎、掘金、语雀等平台持续关注实战内容\n\n---\n","source":"_posts/02-Web_study.md","raw":"---\ntitle: 等等，真的要重新选择一个方向开始吗？——–前端学习(草)\ndate: 2025-07-01 09:13:44\ntags:\n  - 前端开发\n  - 碎碎念\ncategories:\n  - 技术随笔\n---\n\n# 等等，真的要重新选择一个方向开始吗？——–前端学习(草)\n\n## 为什么学习前端？\n\n我想这应该是最重要的问题了，就好像我当初为什么要选择代码事业一样，没什么就是因为喜欢，在这个代码领域，现在我还有学长可以依靠，现在基本在一个领域挖掘越深了解的人越少，不扯了，总之如果说就业的话，说现在互联网已经人满为患的话，那都是屁话，现在没本事又想乘上互联网这趟列车的人多得是，随便加一个代码交流群就知道了。没本事又觉得自己很厉害的人多得是，但是我依旧认为自己应该成为什么样的人？其实有些问题仁者见仁，智者见智，随便逛一下 B 站翻一下弹幕和评论就知道现在的人有多么的恶臭了，例：[别再编那些垃圾假项目经验了，我来教程序员新人求职如何脱颖而出(https://www.bilibili.com/video/BV1zx411R7tb)](https://www.bilibili.com/video/BV1zx411R7tb/?vd_source=3dafe751afaac2d3acd4f464c3870eff)这个视频我看到了明明是重要的分享视频，但是弹幕不给力，一直发无关紧要的弹幕什么衣领，这啊那啊，反而重要的东西没把握住，这个视频想告诉我们一个正确的目标，一个好的程序员是怎么来的？就是那句话：从一个点出发到一个面一个体。这些应该算是好的分享了，因为他告诉了你怎么去思考，学习。比如古人通过在船驶进港口总是先看到船的船桅，这就证明了地球是圆的，牛顿通过一颗落下的苹果，感受到了万有引力。其实伟大的科学发现就是这样通过一件小得不能再小的事发现的，在于主动思考，能有一种主动思考的能力，这才是重要的，这才是你拿得出去的东西，才能形成竞争力。[一眼就知道这是培训出来的简历，为什么？(https://www.bilibili.com/video/BV1QJ411X7mk)](https://www.bilibili.com/video/BV1QJ411X7mk)\n\n> 哈哈哈，2025 年看这段话真的草 😂😂，也算真情流露，就保留着吧。\n\n## 前端学习方向\n\n前端学习可以分为几个阶段，每个阶段的重点不一样，建议循序渐进。\n\n---\n\n### 一、基础阶段：前端三剑客打牢基础\n\n**目标**：掌握前端开发的基本构建模块。\n\n- **HTML**：网页的结构骨架\n- **CSS**：网页的美化师\n- **JavaScript**：网页的灵魂\n\n#### 推荐项目练习\n\n- 仿照写一个登录页、个人主页、计算器等。\n\n#### 推荐学习网站\n\n- [前端九部](https://www.yuque.com/fe9/basic)：内容扎实、通俗易懂\n- [MDN Web Docs](https://developer.mozilla.org/zh-CN/)：HTML/CSS/JS 权威文档\n- [w3schools](https://www.w3schools.com/)：交互式学习平台，适合入门\n- [菜鸟教程](https://www.runoob.com/)：国内入门教程利器\n- [codepen.io](https://codepen.io/)：看别人是怎么写页面的，适合模仿学习\n\n---\n\n### 二、进阶阶段：真正具备“开发能力”\n\n**目标**：掌握项目开发流程与调试技巧，能独立开发简单页面。\n\n- **JavaScript 进阶**\n- **浏览器原理理解**\n- **调试与版本控制工具**\n\n#### 推荐项目练习\n\n- TodoList、新闻展示页、豆瓣电影页面仿写等。\n\n#### 推荐学习网站\n\n- [JavaScript.info](https://zh.javascript.info/)：现代 JS 教程，非常系统\n- [Bilibili 前端进阶课程合集](https://search.bilibili.com/all?keyword=JavaScript%20%E8%BF%9B%E9%98%B6)\n- [Git 官方文档（中文）](https://git-scm.com/book/zh/v2)\n- [Chrome DevTools 学习资源](https://developer.chrome.com/docs/devtools/)\n\n---\n\n### 三、框架阶段：现代前端的标配\n\n**目标**：掌握主流前端框架，进入“企业项目实战”的门槛。\n\n- **React / Vue**\n- **构建工具链**\n- **响应式布局和适配**\n\n#### 推荐项目练习\n\n- 后台管理系统、简易博客系统、仿某 App 页面等。\n\n#### 推荐学习网站\n\n- [Vue 官方文档](https://cn.vuejs.org/)（建议从 Vue 3 开始）\n- [React 官方文档](https://react.dev/)（新版文档更适合新手）\n- [Vite 官方文档](https://vitejs.dev/)（现代构建工具）\n- [Webpack 中文网](https://webpack.docschina.org/)\n- [掘金前端专栏](https://juejin.cn/frontend)：海量实战和踩坑经验分享\n\n---\n\n### 四、全栈与工程化方向（可选）\n\n**目标**：成为独立开发者，或为高级岗位打基础。\n\n- 前端工程化理念\n- Node.js 后端开发\n- 数据库基础\n- SSR / SEO 等进阶话题\n\n#### 推荐项目练习\n\n- 简易博客系统（前后端分离）\n- Markdown 笔记管理系统\n- 静态博客生成器（如 Hexo/Next.js）\n\n#### 推荐学习网站\n\n- [Node.js 中文网](https://nodejs.cn/)\n- [MongoDB 官方教程](https://www.mongodb.com/docs/manual/)\n- [Next.js 官方文档](https://nextjs.org/)\n- [TypeScript 官方文档（中文）](https://www.tslang.cn/docs/home.html)\n- [Full Stack Open](https://fullstackopen.com/)：芬兰大学开设的超高质量全栈课程（英文）\n\n---\n\n## 学习建议\n\n1. **项目导向学习**：不要只刷语法，做出一个完整页面再优化它。\n2. **阅读优秀代码**：GitHub、CodePen、Vue 源码、React 源码学习。\n3. **多做总结笔记**：写博客 / 公众号 / 文档，把“输入”变成“输出”。\n4. **交流学习**：加入开发者社群，和比你优秀的人交流。\n   - 微信群 / QQ 群：搜索“前端技术交流群”\n   - GitHub：参与开源项目，学习规范写法\n   - B 站、知乎、掘金、语雀等平台持续关注实战内容\n\n---\n","slug":"02-Web_study","published":1,"updated":"2025-07-06T01:23:08.950Z","comments":1,"layout":"post","photos":[],"_id":"cmcr40e170000mwnfastr8wef","content":"<h1 id=\"等等，真的要重新选择一个方向开始吗？——–前端学习-草\"><a href=\"#等等，真的要重新选择一个方向开始吗？——–前端学习-草\" class=\"headerlink\" title=\"等等，真的要重新选择一个方向开始吗？——–前端学习(草)\"></a>等等，真的要重新选择一个方向开始吗？——–前端学习(草)</h1><h2 id=\"为什么学习前端？\"><a href=\"#为什么学习前端？\" class=\"headerlink\" title=\"为什么学习前端？\"></a>为什么学习前端？</h2><p>我想这应该是最重要的问题了，就好像我当初为什么要选择代码事业一样，没什么就是因为喜欢，在这个代码领域，现在我还有学长可以依靠，现在基本在一个领域挖掘越深了解的人越少，不扯了，总之如果说就业的话，说现在互联网已经人满为患的话，那都是屁话，现在没本事又想乘上互联网这趟列车的人多得是，随便加一个代码交流群就知道了。没本事又觉得自己很厉害的人多得是，但是我依旧认为自己应该成为什么样的人？其实有些问题仁者见仁，智者见智，随便逛一下 B 站翻一下弹幕和评论就知道现在的人有多么的恶臭了，例：<a href=\"https://www.bilibili.com/video/BV1zx411R7tb/?vd_source=3dafe751afaac2d3acd4f464c3870eff\">别再编那些垃圾假项目经验了，我来教程序员新人求职如何脱颖而出(https://www.bilibili.com/video/BV1zx411R7tb)</a>这个视频我看到了明明是重要的分享视频，但是弹幕不给力，一直发无关紧要的弹幕什么衣领，这啊那啊，反而重要的东西没把握住，这个视频想告诉我们一个正确的目标，一个好的程序员是怎么来的？就是那句话：从一个点出发到一个面一个体。这些应该算是好的分享了，因为他告诉了你怎么去思考，学习。比如古人通过在船驶进港口总是先看到船的船桅，这就证明了地球是圆的，牛顿通过一颗落下的苹果，感受到了万有引力。其实伟大的科学发现就是这样通过一件小得不能再小的事发现的，在于主动思考，能有一种主动思考的能力，这才是重要的，这才是你拿得出去的东西，才能形成竞争力。<a href=\"https://www.bilibili.com/video/BV1QJ411X7mk\">一眼就知道这是培训出来的简历，为什么？(https://www.bilibili.com/video/BV1QJ411X7mk)</a></p>\n<blockquote>\n<p>哈哈哈，2025 年看这段话真的草 😂😂，也算真情流露，就保留着吧。</p>\n</blockquote>\n<h2 id=\"前端学习方向\"><a href=\"#前端学习方向\" class=\"headerlink\" title=\"前端学习方向\"></a>前端学习方向</h2><p>前端学习可以分为几个阶段，每个阶段的重点不一样，建议循序渐进。</p>\n<hr>\n<h3 id=\"一、基础阶段：前端三剑客打牢基础\"><a href=\"#一、基础阶段：前端三剑客打牢基础\" class=\"headerlink\" title=\"一、基础阶段：前端三剑客打牢基础\"></a>一、基础阶段：前端三剑客打牢基础</h3><p><strong>目标</strong>：掌握前端开发的基本构建模块。</p>\n<ul>\n<li><strong>HTML</strong>：网页的结构骨架</li>\n<li><strong>CSS</strong>：网页的美化师</li>\n<li><strong>JavaScript</strong>：网页的灵魂</li>\n</ul>\n<h4 id=\"推荐项目练习\"><a href=\"#推荐项目练习\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>仿照写一个登录页、个人主页、计算器等。</li>\n</ul>\n<h4 id=\"推荐学习网站\"><a href=\"#推荐学习网站\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://www.yuque.com/fe9/basic\">前端九部</a>：内容扎实、通俗易懂</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a>：HTML&#x2F;CSS&#x2F;JS 权威文档</li>\n<li><a href=\"https://www.w3schools.com/\">w3schools</a>：交互式学习平台，适合入门</li>\n<li><a href=\"https://www.runoob.com/\">菜鸟教程</a>：国内入门教程利器</li>\n<li><a href=\"https://codepen.io/\">codepen.io</a>：看别人是怎么写页面的，适合模仿学习</li>\n</ul>\n<hr>\n<h3 id=\"二、进阶阶段：真正具备“开发能力”\"><a href=\"#二、进阶阶段：真正具备“开发能力”\" class=\"headerlink\" title=\"二、进阶阶段：真正具备“开发能力”\"></a>二、进阶阶段：真正具备“开发能力”</h3><p><strong>目标</strong>：掌握项目开发流程与调试技巧，能独立开发简单页面。</p>\n<ul>\n<li><strong>JavaScript 进阶</strong></li>\n<li><strong>浏览器原理理解</strong></li>\n<li><strong>调试与版本控制工具</strong></li>\n</ul>\n<h4 id=\"推荐项目练习-1\"><a href=\"#推荐项目练习-1\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>TodoList、新闻展示页、豆瓣电影页面仿写等。</li>\n</ul>\n<h4 id=\"推荐学习网站-1\"><a href=\"#推荐学习网站-1\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://zh.javascript.info/\">JavaScript.info</a>：现代 JS 教程，非常系统</li>\n<li><a href=\"https://search.bilibili.com/all?keyword=JavaScript%20%E8%BF%9B%E9%98%B6\">Bilibili 前端进阶课程合集</a></li>\n<li><a href=\"https://git-scm.com/book/zh/v2\">Git 官方文档（中文）</a></li>\n<li><a href=\"https://developer.chrome.com/docs/devtools/\">Chrome DevTools 学习资源</a></li>\n</ul>\n<hr>\n<h3 id=\"三、框架阶段：现代前端的标配\"><a href=\"#三、框架阶段：现代前端的标配\" class=\"headerlink\" title=\"三、框架阶段：现代前端的标配\"></a>三、框架阶段：现代前端的标配</h3><p><strong>目标</strong>：掌握主流前端框架，进入“企业项目实战”的门槛。</p>\n<ul>\n<li><strong>React &#x2F; Vue</strong></li>\n<li><strong>构建工具链</strong></li>\n<li><strong>响应式布局和适配</strong></li>\n</ul>\n<h4 id=\"推荐项目练习-2\"><a href=\"#推荐项目练习-2\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>后台管理系统、简易博客系统、仿某 App 页面等。</li>\n</ul>\n<h4 id=\"推荐学习网站-2\"><a href=\"#推荐学习网站-2\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://cn.vuejs.org/\">Vue 官方文档</a>（建议从 Vue 3 开始）</li>\n<li><a href=\"https://react.dev/\">React 官方文档</a>（新版文档更适合新手）</li>\n<li><a href=\"https://vitejs.dev/\">Vite 官方文档</a>（现代构建工具）</li>\n<li><a href=\"https://webpack.docschina.org/\">Webpack 中文网</a></li>\n<li><a href=\"https://juejin.cn/frontend\">掘金前端专栏</a>：海量实战和踩坑经验分享</li>\n</ul>\n<hr>\n<h3 id=\"四、全栈与工程化方向（可选）\"><a href=\"#四、全栈与工程化方向（可选）\" class=\"headerlink\" title=\"四、全栈与工程化方向（可选）\"></a>四、全栈与工程化方向（可选）</h3><p><strong>目标</strong>：成为独立开发者，或为高级岗位打基础。</p>\n<ul>\n<li>前端工程化理念</li>\n<li>Node.js 后端开发</li>\n<li>数据库基础</li>\n<li>SSR &#x2F; SEO 等进阶话题</li>\n</ul>\n<h4 id=\"推荐项目练习-3\"><a href=\"#推荐项目练习-3\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>简易博客系统（前后端分离）</li>\n<li>Markdown 笔记管理系统</li>\n<li>静态博客生成器（如 Hexo&#x2F;Next.js）</li>\n</ul>\n<h4 id=\"推荐学习网站-3\"><a href=\"#推荐学习网站-3\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://nodejs.cn/\">Node.js 中文网</a></li>\n<li><a href=\"https://www.mongodb.com/docs/manual/\">MongoDB 官方教程</a></li>\n<li><a href=\"https://nextjs.org/\">Next.js 官方文档</a></li>\n<li><a href=\"https://www.tslang.cn/docs/home.html\">TypeScript 官方文档（中文）</a></li>\n<li><a href=\"https://fullstackopen.com/\">Full Stack Open</a>：芬兰大学开设的超高质量全栈课程（英文）</li>\n</ul>\n<hr>\n<h2 id=\"学习建议\"><a href=\"#学习建议\" class=\"headerlink\" title=\"学习建议\"></a>学习建议</h2><ol>\n<li><strong>项目导向学习</strong>：不要只刷语法，做出一个完整页面再优化它。</li>\n<li><strong>阅读优秀代码</strong>：GitHub、CodePen、Vue 源码、React 源码学习。</li>\n<li><strong>多做总结笔记</strong>：写博客 &#x2F; 公众号 &#x2F; 文档，把“输入”变成“输出”。</li>\n<li><strong>交流学习</strong>：加入开发者社群，和比你优秀的人交流。<ul>\n<li>微信群 &#x2F; QQ 群：搜索“前端技术交流群”</li>\n<li>GitHub：参与开源项目，学习规范写法</li>\n<li>B 站、知乎、掘金、语雀等平台持续关注实战内容</li>\n</ul>\n</li>\n</ol>\n<hr>\n","excerpt":"","more":"<h1 id=\"等等，真的要重新选择一个方向开始吗？——–前端学习-草\"><a href=\"#等等，真的要重新选择一个方向开始吗？——–前端学习-草\" class=\"headerlink\" title=\"等等，真的要重新选择一个方向开始吗？——–前端学习(草)\"></a>等等，真的要重新选择一个方向开始吗？——–前端学习(草)</h1><h2 id=\"为什么学习前端？\"><a href=\"#为什么学习前端？\" class=\"headerlink\" title=\"为什么学习前端？\"></a>为什么学习前端？</h2><p>我想这应该是最重要的问题了，就好像我当初为什么要选择代码事业一样，没什么就是因为喜欢，在这个代码领域，现在我还有学长可以依靠，现在基本在一个领域挖掘越深了解的人越少，不扯了，总之如果说就业的话，说现在互联网已经人满为患的话，那都是屁话，现在没本事又想乘上互联网这趟列车的人多得是，随便加一个代码交流群就知道了。没本事又觉得自己很厉害的人多得是，但是我依旧认为自己应该成为什么样的人？其实有些问题仁者见仁，智者见智，随便逛一下 B 站翻一下弹幕和评论就知道现在的人有多么的恶臭了，例：<a href=\"https://www.bilibili.com/video/BV1zx411R7tb/?vd_source=3dafe751afaac2d3acd4f464c3870eff\">别再编那些垃圾假项目经验了，我来教程序员新人求职如何脱颖而出(https://www.bilibili.com/video/BV1zx411R7tb)</a>这个视频我看到了明明是重要的分享视频，但是弹幕不给力，一直发无关紧要的弹幕什么衣领，这啊那啊，反而重要的东西没把握住，这个视频想告诉我们一个正确的目标，一个好的程序员是怎么来的？就是那句话：从一个点出发到一个面一个体。这些应该算是好的分享了，因为他告诉了你怎么去思考，学习。比如古人通过在船驶进港口总是先看到船的船桅，这就证明了地球是圆的，牛顿通过一颗落下的苹果，感受到了万有引力。其实伟大的科学发现就是这样通过一件小得不能再小的事发现的，在于主动思考，能有一种主动思考的能力，这才是重要的，这才是你拿得出去的东西，才能形成竞争力。<a href=\"https://www.bilibili.com/video/BV1QJ411X7mk\">一眼就知道这是培训出来的简历，为什么？(https://www.bilibili.com/video/BV1QJ411X7mk)</a></p>\n<blockquote>\n<p>哈哈哈，2025 年看这段话真的草 😂😂，也算真情流露，就保留着吧。</p>\n</blockquote>\n<h2 id=\"前端学习方向\"><a href=\"#前端学习方向\" class=\"headerlink\" title=\"前端学习方向\"></a>前端学习方向</h2><p>前端学习可以分为几个阶段，每个阶段的重点不一样，建议循序渐进。</p>\n<hr>\n<h3 id=\"一、基础阶段：前端三剑客打牢基础\"><a href=\"#一、基础阶段：前端三剑客打牢基础\" class=\"headerlink\" title=\"一、基础阶段：前端三剑客打牢基础\"></a>一、基础阶段：前端三剑客打牢基础</h3><p><strong>目标</strong>：掌握前端开发的基本构建模块。</p>\n<ul>\n<li><strong>HTML</strong>：网页的结构骨架</li>\n<li><strong>CSS</strong>：网页的美化师</li>\n<li><strong>JavaScript</strong>：网页的灵魂</li>\n</ul>\n<h4 id=\"推荐项目练习\"><a href=\"#推荐项目练习\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>仿照写一个登录页、个人主页、计算器等。</li>\n</ul>\n<h4 id=\"推荐学习网站\"><a href=\"#推荐学习网站\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://www.yuque.com/fe9/basic\">前端九部</a>：内容扎实、通俗易懂</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/\">MDN Web Docs</a>：HTML&#x2F;CSS&#x2F;JS 权威文档</li>\n<li><a href=\"https://www.w3schools.com/\">w3schools</a>：交互式学习平台，适合入门</li>\n<li><a href=\"https://www.runoob.com/\">菜鸟教程</a>：国内入门教程利器</li>\n<li><a href=\"https://codepen.io/\">codepen.io</a>：看别人是怎么写页面的，适合模仿学习</li>\n</ul>\n<hr>\n<h3 id=\"二、进阶阶段：真正具备“开发能力”\"><a href=\"#二、进阶阶段：真正具备“开发能力”\" class=\"headerlink\" title=\"二、进阶阶段：真正具备“开发能力”\"></a>二、进阶阶段：真正具备“开发能力”</h3><p><strong>目标</strong>：掌握项目开发流程与调试技巧，能独立开发简单页面。</p>\n<ul>\n<li><strong>JavaScript 进阶</strong></li>\n<li><strong>浏览器原理理解</strong></li>\n<li><strong>调试与版本控制工具</strong></li>\n</ul>\n<h4 id=\"推荐项目练习-1\"><a href=\"#推荐项目练习-1\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>TodoList、新闻展示页、豆瓣电影页面仿写等。</li>\n</ul>\n<h4 id=\"推荐学习网站-1\"><a href=\"#推荐学习网站-1\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://zh.javascript.info/\">JavaScript.info</a>：现代 JS 教程，非常系统</li>\n<li><a href=\"https://search.bilibili.com/all?keyword=JavaScript%20%E8%BF%9B%E9%98%B6\">Bilibili 前端进阶课程合集</a></li>\n<li><a href=\"https://git-scm.com/book/zh/v2\">Git 官方文档（中文）</a></li>\n<li><a href=\"https://developer.chrome.com/docs/devtools/\">Chrome DevTools 学习资源</a></li>\n</ul>\n<hr>\n<h3 id=\"三、框架阶段：现代前端的标配\"><a href=\"#三、框架阶段：现代前端的标配\" class=\"headerlink\" title=\"三、框架阶段：现代前端的标配\"></a>三、框架阶段：现代前端的标配</h3><p><strong>目标</strong>：掌握主流前端框架，进入“企业项目实战”的门槛。</p>\n<ul>\n<li><strong>React &#x2F; Vue</strong></li>\n<li><strong>构建工具链</strong></li>\n<li><strong>响应式布局和适配</strong></li>\n</ul>\n<h4 id=\"推荐项目练习-2\"><a href=\"#推荐项目练习-2\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>后台管理系统、简易博客系统、仿某 App 页面等。</li>\n</ul>\n<h4 id=\"推荐学习网站-2\"><a href=\"#推荐学习网站-2\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://cn.vuejs.org/\">Vue 官方文档</a>（建议从 Vue 3 开始）</li>\n<li><a href=\"https://react.dev/\">React 官方文档</a>（新版文档更适合新手）</li>\n<li><a href=\"https://vitejs.dev/\">Vite 官方文档</a>（现代构建工具）</li>\n<li><a href=\"https://webpack.docschina.org/\">Webpack 中文网</a></li>\n<li><a href=\"https://juejin.cn/frontend\">掘金前端专栏</a>：海量实战和踩坑经验分享</li>\n</ul>\n<hr>\n<h3 id=\"四、全栈与工程化方向（可选）\"><a href=\"#四、全栈与工程化方向（可选）\" class=\"headerlink\" title=\"四、全栈与工程化方向（可选）\"></a>四、全栈与工程化方向（可选）</h3><p><strong>目标</strong>：成为独立开发者，或为高级岗位打基础。</p>\n<ul>\n<li>前端工程化理念</li>\n<li>Node.js 后端开发</li>\n<li>数据库基础</li>\n<li>SSR &#x2F; SEO 等进阶话题</li>\n</ul>\n<h4 id=\"推荐项目练习-3\"><a href=\"#推荐项目练习-3\" class=\"headerlink\" title=\"推荐项目练习\"></a>推荐项目练习</h4><ul>\n<li>简易博客系统（前后端分离）</li>\n<li>Markdown 笔记管理系统</li>\n<li>静态博客生成器（如 Hexo&#x2F;Next.js）</li>\n</ul>\n<h4 id=\"推荐学习网站-3\"><a href=\"#推荐学习网站-3\" class=\"headerlink\" title=\"推荐学习网站\"></a>推荐学习网站</h4><ul>\n<li><a href=\"https://nodejs.cn/\">Node.js 中文网</a></li>\n<li><a href=\"https://www.mongodb.com/docs/manual/\">MongoDB 官方教程</a></li>\n<li><a href=\"https://nextjs.org/\">Next.js 官方文档</a></li>\n<li><a href=\"https://www.tslang.cn/docs/home.html\">TypeScript 官方文档（中文）</a></li>\n<li><a href=\"https://fullstackopen.com/\">Full Stack Open</a>：芬兰大学开设的超高质量全栈课程（英文）</li>\n</ul>\n<hr>\n<h2 id=\"学习建议\"><a href=\"#学习建议\" class=\"headerlink\" title=\"学习建议\"></a>学习建议</h2><ol>\n<li><strong>项目导向学习</strong>：不要只刷语法，做出一个完整页面再优化它。</li>\n<li><strong>阅读优秀代码</strong>：GitHub、CodePen、Vue 源码、React 源码学习。</li>\n<li><strong>多做总结笔记</strong>：写博客 &#x2F; 公众号 &#x2F; 文档，把“输入”变成“输出”。</li>\n<li><strong>交流学习</strong>：加入开发者社群，和比你优秀的人交流。<ul>\n<li>微信群 &#x2F; QQ 群：搜索“前端技术交流群”</li>\n<li>GitHub：参与开源项目，学习规范写法</li>\n<li>B 站、知乎、掘金、语雀等平台持续关注实战内容</li>\n</ul>\n</li>\n</ol>\n<hr>\n"},{"title":"ACM之杭电 OJ 刷题顺序指南","date":"2020-07-07T01:21:29.000Z","_content":"\n# ACM 之杭电 OJ 刷题顺序指南\n\n> ✅ **温馨提示：杭电 OJ 截至 2025 年仍可正常访问！**  \n> 无论你是刚刚入门，还是备战 ACM 赛事，希望这份刷题指南能帮助你少走弯路、快速成长！  \n> 🎯 **祝各位刷题顺利，早日 AK！**\n\n![杭电 OJ 官网截图](https://s2.loli.net/2025/07/06/EgbnuCmUtywJVY2.png)\n\n## 第一阶段：开始入门吧！（15 天 / 53 题）\n\n### 一、输入输出练习（2 天 / 10 题）\n\n题号：`1000`, `1089`~`1096`, `1001`\n\n---\n\n### 二、简单操作（2~4 天 / 12 题）\n\n题号：`2000`~`2011`, `2039`\n\n---\n\n### 三、英文题试水（3~4 天 / 8 题）\n\n题号：`1720`, `1062`, `2104`, `1064`, `2734`, `1170`, `1197`, `2629`\n\n---\n\n### 四、回归水题（4~6 天 / 24 题）\n\n题号：`2012`~`2030`, `2032`, `2040`, `2042`, `2054`, `2055`\n\n---\n\n## 第二阶段：我要学算法！（12 天 / 31 题）\n\n### 一、字符串处理（2 天 / 6 题）\n\n题号：`2072`, `2081`, `2093`, `2091`, `1004`, `2057`\n\n---\n\n### 二、简单数学题（4 天 / 12 题）\n\n题号：`2031`, `2033`, `2070`, `2071`, `2075`, `2089`, `2090`, `2092`, `2096`~`2099`\n\n---\n\n### 三、汉诺塔专场（2 天 / 5 题）\n\n题号：`1995`, `1996`, `2064`, `2077`, `2175`\n\n---\n\n### 四、As Easy as Math（4 天 / 8 题）\n\n题号：`1108`, `2138`, `1713`, `1722`, `2136`, `2504`, `1717`, `1125`\n\n---\n\n## 第三阶段：ACM 无底洞啊！（10 天 / 18 题）\n\n### 一、初见 DP（2~4 天 / 4 题）\n\n题号：`2062`, `1087`, `1203`, `1003`\n\n---\n\n### 二、迷宫系列（2~4 天 / 3 题）\n\n题号：`1728`, `1010`, `1072`\n\n---\n\n### 三、数学难题（3~5 天 / 8 题）\n\n题号：`1052`, `1568`, `1443`, `1222`, `1249`, `1005`, `2674`, `1018`\n\n---\n\n### 四、龙门客栈（2~3 天 / 3 题）\n\n题号：`1022`, `1237`, `1082`\n\n---\n\n## 分类整理：题目类型推荐\n\n### 一、模拟题 & 枚举类\n\n代表题目：  \n`1002`, `1004`, `1013`, `1015`, `1033`, `1047`, `1050`, `1057`, `1062`, `1075`, `1082`, `1106`, `1172`, `1200`, `1212`, `1225`, `1236`, `1282`, `1305`, 等\n\n---\n\n### 二、搜索 / 递归类\n\n代表题目：  \n`1010`, `1016`, `1026`, `1043`, `1044`, `1045`, `1067`, `1072`, `1104`, `1175`, `1208`, `1242`, `1271`, `1312`\n\n---\n\n### 三、动态规划（DP）\n\n代表题目：  \n`1003`, `1024`, `1025`, `1051`, `1058`, `1059`, `1074`, `1078`, `1080`, `1081`, `1085`, `1087`, `1158`, `1203`, `1244`, `1254`, `1300`\n\n---\n\n### 四、数学 / 递推 / 找规律\n\n代表题目：  \n`1005`, `1012`, `1018`, `1021`, `1023`, `1046`, `1061`, `1071`, `1097`, `1100`, `1112`, `1132`, `1165`, `1214`, `1249`, `1267`, `1290`\n\n---\n\n### 五、数论\n\n代表题目：  \n`1164`, `1211`, `1222`, `1286`, `1299`\n\n---\n\n### 六、计算几何\n\n代表题目：  \n`1086`, `1115`, `1147`\n\n---\n\n### 七、贪心算法\n\n代表题目：  \n`1009`, `1052`, `1055`, `1257`\n\n---\n\n### 八、并查集\n\n代表题目：  \n`1198`, `1213`, `1232`, `1272`\n\n---\n\n### 九、图论专题\n\n- 最短路径：`1142`, `1162`, `1217`, `1301`\n- 二分图：`1054`, `1068`, `1150`, `1281`\n- MST、强连通等：`1102`, `1233`, `1269`, `1116`\n\n---\n\n### 十、数据结构进阶\n\n- 堆、树状数组、线段树、拓扑排序等：\n  - `1103`, `1166`, `1247`, `1251`, `1285`, `1298`\n\n---\n\n## 杭电 1500+ 专题题单（部分）\n\n| 题号      | 类型            |\n| --------- | --------------- |\n| 1500      | DP              |\n| 1501      | DP              |\n| 1502      | DP / 记忆化     |\n| 1503      | DP              |\n| 1504      | 模拟            |\n| 1505      | DP              |\n| 1506      | DP              |\n| 1507      | 二分匹配        |\n| 1508      | 记忆化搜索      |\n| 1509      | 模拟            |\n| 1510      | DP              |\n| 1511      | 搜索            |\n| 1512      | 左偏树          |\n| 1513      | DP              |\n| 1514      | DP              |\n| 1515      | DFS             |\n| 1516      | DP              |\n| 1517      | 博弈            |\n| 1518      | 搜索            |\n| 1520      | 树状 DP         |\n| 1521      | 数学 / 母函数   |\n| 1522      | 稳定婚姻        |\n| 1526      | 最大流          |\n| 1530      | 最大团          |\n| 1532      | 最大流（入门）  |\n| 1533      | KM / 最小费用流 |\n| 1534~1535 | 差分约束        |\n| 1564      | 博弈            |\n| 1569      | 最小割          |\n\n📌 **注：** 1500 题以上大多属于比赛原题或高难度训练题，适合在前三阶段完成后深入挑战。\n\n---\n\n## 📚 总结\n\n- 从 **输入输出、基础数学、简单字符串处理** 开始入门；\n- 逐步挑战 **搜索、动态规划、图论、博弈论** 等核心 ACM 算法；\n- 多归类总结，整理错题，形成知识图谱；\n- 养成刷题“项目化”的习惯，每一阶段都制定计划；\n\n🧠 **刷题并非死记套路，而是构建解决问题的能力。**\n\n愿你在 ACM 的旅途中，不断突破自我，收获成长！\n","source":"_posts/03-ACM-hangdianoj-peactice-questions.md","raw":"---\ntitle: ACM之杭电 OJ 刷题顺序指南\ndate: 2020-07-07 09:21:29\ntags:\n  - 杭电OJ\n  - 刷题顺序\n  - ACM算法\ncategories:\n  - 算法入门\n  - 刷题经验\n---\n\n# ACM 之杭电 OJ 刷题顺序指南\n\n> ✅ **温馨提示：杭电 OJ 截至 2025 年仍可正常访问！**  \n> 无论你是刚刚入门，还是备战 ACM 赛事，希望这份刷题指南能帮助你少走弯路、快速成长！  \n> 🎯 **祝各位刷题顺利，早日 AK！**\n\n![杭电 OJ 官网截图](https://s2.loli.net/2025/07/06/EgbnuCmUtywJVY2.png)\n\n## 第一阶段：开始入门吧！（15 天 / 53 题）\n\n### 一、输入输出练习（2 天 / 10 题）\n\n题号：`1000`, `1089`~`1096`, `1001`\n\n---\n\n### 二、简单操作（2~4 天 / 12 题）\n\n题号：`2000`~`2011`, `2039`\n\n---\n\n### 三、英文题试水（3~4 天 / 8 题）\n\n题号：`1720`, `1062`, `2104`, `1064`, `2734`, `1170`, `1197`, `2629`\n\n---\n\n### 四、回归水题（4~6 天 / 24 题）\n\n题号：`2012`~`2030`, `2032`, `2040`, `2042`, `2054`, `2055`\n\n---\n\n## 第二阶段：我要学算法！（12 天 / 31 题）\n\n### 一、字符串处理（2 天 / 6 题）\n\n题号：`2072`, `2081`, `2093`, `2091`, `1004`, `2057`\n\n---\n\n### 二、简单数学题（4 天 / 12 题）\n\n题号：`2031`, `2033`, `2070`, `2071`, `2075`, `2089`, `2090`, `2092`, `2096`~`2099`\n\n---\n\n### 三、汉诺塔专场（2 天 / 5 题）\n\n题号：`1995`, `1996`, `2064`, `2077`, `2175`\n\n---\n\n### 四、As Easy as Math（4 天 / 8 题）\n\n题号：`1108`, `2138`, `1713`, `1722`, `2136`, `2504`, `1717`, `1125`\n\n---\n\n## 第三阶段：ACM 无底洞啊！（10 天 / 18 题）\n\n### 一、初见 DP（2~4 天 / 4 题）\n\n题号：`2062`, `1087`, `1203`, `1003`\n\n---\n\n### 二、迷宫系列（2~4 天 / 3 题）\n\n题号：`1728`, `1010`, `1072`\n\n---\n\n### 三、数学难题（3~5 天 / 8 题）\n\n题号：`1052`, `1568`, `1443`, `1222`, `1249`, `1005`, `2674`, `1018`\n\n---\n\n### 四、龙门客栈（2~3 天 / 3 题）\n\n题号：`1022`, `1237`, `1082`\n\n---\n\n## 分类整理：题目类型推荐\n\n### 一、模拟题 & 枚举类\n\n代表题目：  \n`1002`, `1004`, `1013`, `1015`, `1033`, `1047`, `1050`, `1057`, `1062`, `1075`, `1082`, `1106`, `1172`, `1200`, `1212`, `1225`, `1236`, `1282`, `1305`, 等\n\n---\n\n### 二、搜索 / 递归类\n\n代表题目：  \n`1010`, `1016`, `1026`, `1043`, `1044`, `1045`, `1067`, `1072`, `1104`, `1175`, `1208`, `1242`, `1271`, `1312`\n\n---\n\n### 三、动态规划（DP）\n\n代表题目：  \n`1003`, `1024`, `1025`, `1051`, `1058`, `1059`, `1074`, `1078`, `1080`, `1081`, `1085`, `1087`, `1158`, `1203`, `1244`, `1254`, `1300`\n\n---\n\n### 四、数学 / 递推 / 找规律\n\n代表题目：  \n`1005`, `1012`, `1018`, `1021`, `1023`, `1046`, `1061`, `1071`, `1097`, `1100`, `1112`, `1132`, `1165`, `1214`, `1249`, `1267`, `1290`\n\n---\n\n### 五、数论\n\n代表题目：  \n`1164`, `1211`, `1222`, `1286`, `1299`\n\n---\n\n### 六、计算几何\n\n代表题目：  \n`1086`, `1115`, `1147`\n\n---\n\n### 七、贪心算法\n\n代表题目：  \n`1009`, `1052`, `1055`, `1257`\n\n---\n\n### 八、并查集\n\n代表题目：  \n`1198`, `1213`, `1232`, `1272`\n\n---\n\n### 九、图论专题\n\n- 最短路径：`1142`, `1162`, `1217`, `1301`\n- 二分图：`1054`, `1068`, `1150`, `1281`\n- MST、强连通等：`1102`, `1233`, `1269`, `1116`\n\n---\n\n### 十、数据结构进阶\n\n- 堆、树状数组、线段树、拓扑排序等：\n  - `1103`, `1166`, `1247`, `1251`, `1285`, `1298`\n\n---\n\n## 杭电 1500+ 专题题单（部分）\n\n| 题号      | 类型            |\n| --------- | --------------- |\n| 1500      | DP              |\n| 1501      | DP              |\n| 1502      | DP / 记忆化     |\n| 1503      | DP              |\n| 1504      | 模拟            |\n| 1505      | DP              |\n| 1506      | DP              |\n| 1507      | 二分匹配        |\n| 1508      | 记忆化搜索      |\n| 1509      | 模拟            |\n| 1510      | DP              |\n| 1511      | 搜索            |\n| 1512      | 左偏树          |\n| 1513      | DP              |\n| 1514      | DP              |\n| 1515      | DFS             |\n| 1516      | DP              |\n| 1517      | 博弈            |\n| 1518      | 搜索            |\n| 1520      | 树状 DP         |\n| 1521      | 数学 / 母函数   |\n| 1522      | 稳定婚姻        |\n| 1526      | 最大流          |\n| 1530      | 最大团          |\n| 1532      | 最大流（入门）  |\n| 1533      | KM / 最小费用流 |\n| 1534~1535 | 差分约束        |\n| 1564      | 博弈            |\n| 1569      | 最小割          |\n\n📌 **注：** 1500 题以上大多属于比赛原题或高难度训练题，适合在前三阶段完成后深入挑战。\n\n---\n\n## 📚 总结\n\n- 从 **输入输出、基础数学、简单字符串处理** 开始入门；\n- 逐步挑战 **搜索、动态规划、图论、博弈论** 等核心 ACM 算法；\n- 多归类总结，整理错题，形成知识图谱；\n- 养成刷题“项目化”的习惯，每一阶段都制定计划；\n\n🧠 **刷题并非死记套路，而是构建解决问题的能力。**\n\n愿你在 ACM 的旅途中，不断突破自我，收获成长！\n","slug":"03-ACM-hangdianoj-peactice-questions","published":1,"updated":"2025-07-06T01:55:31.008Z","comments":1,"layout":"post","photos":[],"_id":"cmcr40e1c000dmwnfefrbds0u","content":"<h1 id=\"ACM-之杭电-OJ-刷题顺序指南\"><a href=\"#ACM-之杭电-OJ-刷题顺序指南\" class=\"headerlink\" title=\"ACM 之杭电 OJ 刷题顺序指南\"></a>ACM 之杭电 OJ 刷题顺序指南</h1><blockquote>\n<p>✅ <strong>温馨提示：杭电 OJ 截至 2025 年仍可正常访问！</strong><br>无论你是刚刚入门，还是备战 ACM 赛事，希望这份刷题指南能帮助你少走弯路、快速成长！<br>🎯 <strong>祝各位刷题顺利，早日 AK！</strong></p>\n</blockquote>\n<p><img src=\"https://s2.loli.net/2025/07/06/EgbnuCmUtywJVY2.png\" class=\"lazyload\" data-srcset=\"https://s2.loli.net/2025/07/06/EgbnuCmUtywJVY2.png\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"杭电 OJ 官网截图\"></p>\n<h2 id=\"第一阶段：开始入门吧！（15-天-53-题）\"><a href=\"#第一阶段：开始入门吧！（15-天-53-题）\" class=\"headerlink\" title=\"第一阶段：开始入门吧！（15 天 &#x2F; 53 题）\"></a>第一阶段：开始入门吧！（15 天 &#x2F; 53 题）</h2><h3 id=\"一、输入输出练习（2-天-10-题）\"><a href=\"#一、输入输出练习（2-天-10-题）\" class=\"headerlink\" title=\"一、输入输出练习（2 天 &#x2F; 10 题）\"></a>一、输入输出练习（2 天 &#x2F; 10 题）</h3><p>题号：<code>1000</code>, <code>1089</code>~&#96;1096<code>, </code>1001&#96;</p>\n<hr>\n<h3 id=\"二、简单操作（2-4-天-12-题）\"><a href=\"#二、简单操作（2-4-天-12-题）\" class=\"headerlink\" title=\"二、简单操作（2~4 天 &#x2F; 12 题）\"></a>二、简单操作（2~4 天 &#x2F; 12 题）</h3><p>题号：<code>2000</code>~&#96;2011<code>, </code>2039&#96;</p>\n<hr>\n<h3 id=\"三、英文题试水（3-4-天-8-题）\"><a href=\"#三、英文题试水（3-4-天-8-题）\" class=\"headerlink\" title=\"三、英文题试水（3~4 天 &#x2F; 8 题）\"></a>三、英文题试水（3~4 天 &#x2F; 8 题）</h3><p>题号：<code>1720</code>, <code>1062</code>, <code>2104</code>, <code>1064</code>, <code>2734</code>, <code>1170</code>, <code>1197</code>, <code>2629</code></p>\n<hr>\n<h3 id=\"四、回归水题（4-6-天-24-题）\"><a href=\"#四、回归水题（4-6-天-24-题）\" class=\"headerlink\" title=\"四、回归水题（4~6 天 &#x2F; 24 题）\"></a>四、回归水题（4~6 天 &#x2F; 24 题）</h3><p>题号：<code>2012</code>~&#96;2030<code>, </code>2032<code>, </code>2040<code>, </code>2042<code>, </code>2054<code>, </code>2055&#96;</p>\n<hr>\n<h2 id=\"第二阶段：我要学算法！（12-天-31-题）\"><a href=\"#第二阶段：我要学算法！（12-天-31-题）\" class=\"headerlink\" title=\"第二阶段：我要学算法！（12 天 &#x2F; 31 题）\"></a>第二阶段：我要学算法！（12 天 &#x2F; 31 题）</h2><h3 id=\"一、字符串处理（2-天-6-题）\"><a href=\"#一、字符串处理（2-天-6-题）\" class=\"headerlink\" title=\"一、字符串处理（2 天 &#x2F; 6 题）\"></a>一、字符串处理（2 天 &#x2F; 6 题）</h3><p>题号：<code>2072</code>, <code>2081</code>, <code>2093</code>, <code>2091</code>, <code>1004</code>, <code>2057</code></p>\n<hr>\n<h3 id=\"二、简单数学题（4-天-12-题）\"><a href=\"#二、简单数学题（4-天-12-题）\" class=\"headerlink\" title=\"二、简单数学题（4 天 &#x2F; 12 题）\"></a>二、简单数学题（4 天 &#x2F; 12 题）</h3><p>题号：<code>2031</code>, <code>2033</code>, <code>2070</code>, <code>2071</code>, <code>2075</code>, <code>2089</code>, <code>2090</code>, <code>2092</code>, <code>2096</code>~&#96;2099&#96;</p>\n<hr>\n<h3 id=\"三、汉诺塔专场（2-天-5-题）\"><a href=\"#三、汉诺塔专场（2-天-5-题）\" class=\"headerlink\" title=\"三、汉诺塔专场（2 天 &#x2F; 5 题）\"></a>三、汉诺塔专场（2 天 &#x2F; 5 题）</h3><p>题号：<code>1995</code>, <code>1996</code>, <code>2064</code>, <code>2077</code>, <code>2175</code></p>\n<hr>\n<h3 id=\"四、As-Easy-as-Math（4-天-8-题）\"><a href=\"#四、As-Easy-as-Math（4-天-8-题）\" class=\"headerlink\" title=\"四、As Easy as Math（4 天 &#x2F; 8 题）\"></a>四、As Easy as Math（4 天 &#x2F; 8 题）</h3><p>题号：<code>1108</code>, <code>2138</code>, <code>1713</code>, <code>1722</code>, <code>2136</code>, <code>2504</code>, <code>1717</code>, <code>1125</code></p>\n<hr>\n<h2 id=\"第三阶段：ACM-无底洞啊！（10-天-18-题）\"><a href=\"#第三阶段：ACM-无底洞啊！（10-天-18-题）\" class=\"headerlink\" title=\"第三阶段：ACM 无底洞啊！（10 天 &#x2F; 18 题）\"></a>第三阶段：ACM 无底洞啊！（10 天 &#x2F; 18 题）</h2><h3 id=\"一、初见-DP（2-4-天-4-题）\"><a href=\"#一、初见-DP（2-4-天-4-题）\" class=\"headerlink\" title=\"一、初见 DP（2~4 天 &#x2F; 4 题）\"></a>一、初见 DP（2~4 天 &#x2F; 4 题）</h3><p>题号：<code>2062</code>, <code>1087</code>, <code>1203</code>, <code>1003</code></p>\n<hr>\n<h3 id=\"二、迷宫系列（2-4-天-3-题）\"><a href=\"#二、迷宫系列（2-4-天-3-题）\" class=\"headerlink\" title=\"二、迷宫系列（2~4 天 &#x2F; 3 题）\"></a>二、迷宫系列（2~4 天 &#x2F; 3 题）</h3><p>题号：<code>1728</code>, <code>1010</code>, <code>1072</code></p>\n<hr>\n<h3 id=\"三、数学难题（3-5-天-8-题）\"><a href=\"#三、数学难题（3-5-天-8-题）\" class=\"headerlink\" title=\"三、数学难题（3~5 天 &#x2F; 8 题）\"></a>三、数学难题（3~5 天 &#x2F; 8 题）</h3><p>题号：<code>1052</code>, <code>1568</code>, <code>1443</code>, <code>1222</code>, <code>1249</code>, <code>1005</code>, <code>2674</code>, <code>1018</code></p>\n<hr>\n<h3 id=\"四、龙门客栈（2-3-天-3-题）\"><a href=\"#四、龙门客栈（2-3-天-3-题）\" class=\"headerlink\" title=\"四、龙门客栈（2~3 天 &#x2F; 3 题）\"></a>四、龙门客栈（2~3 天 &#x2F; 3 题）</h3><p>题号：<code>1022</code>, <code>1237</code>, <code>1082</code></p>\n<hr>\n<h2 id=\"分类整理：题目类型推荐\"><a href=\"#分类整理：题目类型推荐\" class=\"headerlink\" title=\"分类整理：题目类型推荐\"></a>分类整理：题目类型推荐</h2><h3 id=\"一、模拟题-枚举类\"><a href=\"#一、模拟题-枚举类\" class=\"headerlink\" title=\"一、模拟题 &amp; 枚举类\"></a>一、模拟题 &amp; 枚举类</h3><p>代表题目：<br><code>1002</code>, <code>1004</code>, <code>1013</code>, <code>1015</code>, <code>1033</code>, <code>1047</code>, <code>1050</code>, <code>1057</code>, <code>1062</code>, <code>1075</code>, <code>1082</code>, <code>1106</code>, <code>1172</code>, <code>1200</code>, <code>1212</code>, <code>1225</code>, <code>1236</code>, <code>1282</code>, <code>1305</code>, 等</p>\n<hr>\n<h3 id=\"二、搜索-递归类\"><a href=\"#二、搜索-递归类\" class=\"headerlink\" title=\"二、搜索 &#x2F; 递归类\"></a>二、搜索 &#x2F; 递归类</h3><p>代表题目：<br><code>1010</code>, <code>1016</code>, <code>1026</code>, <code>1043</code>, <code>1044</code>, <code>1045</code>, <code>1067</code>, <code>1072</code>, <code>1104</code>, <code>1175</code>, <code>1208</code>, <code>1242</code>, <code>1271</code>, <code>1312</code></p>\n<hr>\n<h3 id=\"三、动态规划（DP）\"><a href=\"#三、动态规划（DP）\" class=\"headerlink\" title=\"三、动态规划（DP）\"></a>三、动态规划（DP）</h3><p>代表题目：<br><code>1003</code>, <code>1024</code>, <code>1025</code>, <code>1051</code>, <code>1058</code>, <code>1059</code>, <code>1074</code>, <code>1078</code>, <code>1080</code>, <code>1081</code>, <code>1085</code>, <code>1087</code>, <code>1158</code>, <code>1203</code>, <code>1244</code>, <code>1254</code>, <code>1300</code></p>\n<hr>\n<h3 id=\"四、数学-递推-找规律\"><a href=\"#四、数学-递推-找规律\" class=\"headerlink\" title=\"四、数学 &#x2F; 递推 &#x2F; 找规律\"></a>四、数学 &#x2F; 递推 &#x2F; 找规律</h3><p>代表题目：<br><code>1005</code>, <code>1012</code>, <code>1018</code>, <code>1021</code>, <code>1023</code>, <code>1046</code>, <code>1061</code>, <code>1071</code>, <code>1097</code>, <code>1100</code>, <code>1112</code>, <code>1132</code>, <code>1165</code>, <code>1214</code>, <code>1249</code>, <code>1267</code>, <code>1290</code></p>\n<hr>\n<h3 id=\"五、数论\"><a href=\"#五、数论\" class=\"headerlink\" title=\"五、数论\"></a>五、数论</h3><p>代表题目：<br><code>1164</code>, <code>1211</code>, <code>1222</code>, <code>1286</code>, <code>1299</code></p>\n<hr>\n<h3 id=\"六、计算几何\"><a href=\"#六、计算几何\" class=\"headerlink\" title=\"六、计算几何\"></a>六、计算几何</h3><p>代表题目：<br><code>1086</code>, <code>1115</code>, <code>1147</code></p>\n<hr>\n<h3 id=\"七、贪心算法\"><a href=\"#七、贪心算法\" class=\"headerlink\" title=\"七、贪心算法\"></a>七、贪心算法</h3><p>代表题目：<br><code>1009</code>, <code>1052</code>, <code>1055</code>, <code>1257</code></p>\n<hr>\n<h3 id=\"八、并查集\"><a href=\"#八、并查集\" class=\"headerlink\" title=\"八、并查集\"></a>八、并查集</h3><p>代表题目：<br><code>1198</code>, <code>1213</code>, <code>1232</code>, <code>1272</code></p>\n<hr>\n<h3 id=\"九、图论专题\"><a href=\"#九、图论专题\" class=\"headerlink\" title=\"九、图论专题\"></a>九、图论专题</h3><ul>\n<li>最短路径：<code>1142</code>, <code>1162</code>, <code>1217</code>, <code>1301</code></li>\n<li>二分图：<code>1054</code>, <code>1068</code>, <code>1150</code>, <code>1281</code></li>\n<li>MST、强连通等：<code>1102</code>, <code>1233</code>, <code>1269</code>, <code>1116</code></li>\n</ul>\n<hr>\n<h3 id=\"十、数据结构进阶\"><a href=\"#十、数据结构进阶\" class=\"headerlink\" title=\"十、数据结构进阶\"></a>十、数据结构进阶</h3><ul>\n<li>堆、树状数组、线段树、拓扑排序等：<ul>\n<li><code>1103</code>, <code>1166</code>, <code>1247</code>, <code>1251</code>, <code>1285</code>, <code>1298</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"杭电-1500-专题题单（部分）\"><a href=\"#杭电-1500-专题题单（部分）\" class=\"headerlink\" title=\"杭电 1500+ 专题题单（部分）\"></a>杭电 1500+ 专题题单（部分）</h2><table>\n<thead>\n<tr>\n<th>题号</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1500</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1501</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1502</td>\n<td>DP &#x2F; 记忆化</td>\n</tr>\n<tr>\n<td>1503</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1504</td>\n<td>模拟</td>\n</tr>\n<tr>\n<td>1505</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1506</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1507</td>\n<td>二分匹配</td>\n</tr>\n<tr>\n<td>1508</td>\n<td>记忆化搜索</td>\n</tr>\n<tr>\n<td>1509</td>\n<td>模拟</td>\n</tr>\n<tr>\n<td>1510</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1511</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td>1512</td>\n<td>左偏树</td>\n</tr>\n<tr>\n<td>1513</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1514</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1515</td>\n<td>DFS</td>\n</tr>\n<tr>\n<td>1516</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1517</td>\n<td>博弈</td>\n</tr>\n<tr>\n<td>1518</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td>1520</td>\n<td>树状 DP</td>\n</tr>\n<tr>\n<td>1521</td>\n<td>数学 &#x2F; 母函数</td>\n</tr>\n<tr>\n<td>1522</td>\n<td>稳定婚姻</td>\n</tr>\n<tr>\n<td>1526</td>\n<td>最大流</td>\n</tr>\n<tr>\n<td>1530</td>\n<td>最大团</td>\n</tr>\n<tr>\n<td>1532</td>\n<td>最大流（入门）</td>\n</tr>\n<tr>\n<td>1533</td>\n<td>KM &#x2F; 最小费用流</td>\n</tr>\n<tr>\n<td>1534~1535</td>\n<td>差分约束</td>\n</tr>\n<tr>\n<td>1564</td>\n<td>博弈</td>\n</tr>\n<tr>\n<td>1569</td>\n<td>最小割</td>\n</tr>\n</tbody></table>\n<p>📌 <strong>注：</strong> 1500 题以上大多属于比赛原题或高难度训练题，适合在前三阶段完成后深入挑战。</p>\n<hr>\n<h2 id=\"📚-总结\"><a href=\"#📚-总结\" class=\"headerlink\" title=\"📚 总结\"></a>📚 总结</h2><ul>\n<li>从 <strong>输入输出、基础数学、简单字符串处理</strong> 开始入门；</li>\n<li>逐步挑战 <strong>搜索、动态规划、图论、博弈论</strong> 等核心 ACM 算法；</li>\n<li>多归类总结，整理错题，形成知识图谱；</li>\n<li>养成刷题“项目化”的习惯，每一阶段都制定计划；</li>\n</ul>\n<p>🧠 <strong>刷题并非死记套路，而是构建解决问题的能力。</strong></p>\n<p>愿你在 ACM 的旅途中，不断突破自我，收获成长！</p>\n","excerpt":"","more":"<h1 id=\"ACM-之杭电-OJ-刷题顺序指南\"><a href=\"#ACM-之杭电-OJ-刷题顺序指南\" class=\"headerlink\" title=\"ACM 之杭电 OJ 刷题顺序指南\"></a>ACM 之杭电 OJ 刷题顺序指南</h1><blockquote>\n<p>✅ <strong>温馨提示：杭电 OJ 截至 2025 年仍可正常访问！</strong><br>无论你是刚刚入门，还是备战 ACM 赛事，希望这份刷题指南能帮助你少走弯路、快速成长！<br>🎯 <strong>祝各位刷题顺利，早日 AK！</strong></p>\n</blockquote>\n<p><img src=\"https://s2.loli.net/2025/07/06/EgbnuCmUtywJVY2.png\" alt=\"杭电 OJ 官网截图\"></p>\n<h2 id=\"第一阶段：开始入门吧！（15-天-53-题）\"><a href=\"#第一阶段：开始入门吧！（15-天-53-题）\" class=\"headerlink\" title=\"第一阶段：开始入门吧！（15 天 &#x2F; 53 题）\"></a>第一阶段：开始入门吧！（15 天 &#x2F; 53 题）</h2><h3 id=\"一、输入输出练习（2-天-10-题）\"><a href=\"#一、输入输出练习（2-天-10-题）\" class=\"headerlink\" title=\"一、输入输出练习（2 天 &#x2F; 10 题）\"></a>一、输入输出练习（2 天 &#x2F; 10 题）</h3><p>题号：<code>1000</code>, <code>1089</code>~&#96;1096<code>, </code>1001&#96;</p>\n<hr>\n<h3 id=\"二、简单操作（2-4-天-12-题）\"><a href=\"#二、简单操作（2-4-天-12-题）\" class=\"headerlink\" title=\"二、简单操作（2~4 天 &#x2F; 12 题）\"></a>二、简单操作（2~4 天 &#x2F; 12 题）</h3><p>题号：<code>2000</code>~&#96;2011<code>, </code>2039&#96;</p>\n<hr>\n<h3 id=\"三、英文题试水（3-4-天-8-题）\"><a href=\"#三、英文题试水（3-4-天-8-题）\" class=\"headerlink\" title=\"三、英文题试水（3~4 天 &#x2F; 8 题）\"></a>三、英文题试水（3~4 天 &#x2F; 8 题）</h3><p>题号：<code>1720</code>, <code>1062</code>, <code>2104</code>, <code>1064</code>, <code>2734</code>, <code>1170</code>, <code>1197</code>, <code>2629</code></p>\n<hr>\n<h3 id=\"四、回归水题（4-6-天-24-题）\"><a href=\"#四、回归水题（4-6-天-24-题）\" class=\"headerlink\" title=\"四、回归水题（4~6 天 &#x2F; 24 题）\"></a>四、回归水题（4~6 天 &#x2F; 24 题）</h3><p>题号：<code>2012</code>~&#96;2030<code>, </code>2032<code>, </code>2040<code>, </code>2042<code>, </code>2054<code>, </code>2055&#96;</p>\n<hr>\n<h2 id=\"第二阶段：我要学算法！（12-天-31-题）\"><a href=\"#第二阶段：我要学算法！（12-天-31-题）\" class=\"headerlink\" title=\"第二阶段：我要学算法！（12 天 &#x2F; 31 题）\"></a>第二阶段：我要学算法！（12 天 &#x2F; 31 题）</h2><h3 id=\"一、字符串处理（2-天-6-题）\"><a href=\"#一、字符串处理（2-天-6-题）\" class=\"headerlink\" title=\"一、字符串处理（2 天 &#x2F; 6 题）\"></a>一、字符串处理（2 天 &#x2F; 6 题）</h3><p>题号：<code>2072</code>, <code>2081</code>, <code>2093</code>, <code>2091</code>, <code>1004</code>, <code>2057</code></p>\n<hr>\n<h3 id=\"二、简单数学题（4-天-12-题）\"><a href=\"#二、简单数学题（4-天-12-题）\" class=\"headerlink\" title=\"二、简单数学题（4 天 &#x2F; 12 题）\"></a>二、简单数学题（4 天 &#x2F; 12 题）</h3><p>题号：<code>2031</code>, <code>2033</code>, <code>2070</code>, <code>2071</code>, <code>2075</code>, <code>2089</code>, <code>2090</code>, <code>2092</code>, <code>2096</code>~&#96;2099&#96;</p>\n<hr>\n<h3 id=\"三、汉诺塔专场（2-天-5-题）\"><a href=\"#三、汉诺塔专场（2-天-5-题）\" class=\"headerlink\" title=\"三、汉诺塔专场（2 天 &#x2F; 5 题）\"></a>三、汉诺塔专场（2 天 &#x2F; 5 题）</h3><p>题号：<code>1995</code>, <code>1996</code>, <code>2064</code>, <code>2077</code>, <code>2175</code></p>\n<hr>\n<h3 id=\"四、As-Easy-as-Math（4-天-8-题）\"><a href=\"#四、As-Easy-as-Math（4-天-8-题）\" class=\"headerlink\" title=\"四、As Easy as Math（4 天 &#x2F; 8 题）\"></a>四、As Easy as Math（4 天 &#x2F; 8 题）</h3><p>题号：<code>1108</code>, <code>2138</code>, <code>1713</code>, <code>1722</code>, <code>2136</code>, <code>2504</code>, <code>1717</code>, <code>1125</code></p>\n<hr>\n<h2 id=\"第三阶段：ACM-无底洞啊！（10-天-18-题）\"><a href=\"#第三阶段：ACM-无底洞啊！（10-天-18-题）\" class=\"headerlink\" title=\"第三阶段：ACM 无底洞啊！（10 天 &#x2F; 18 题）\"></a>第三阶段：ACM 无底洞啊！（10 天 &#x2F; 18 题）</h2><h3 id=\"一、初见-DP（2-4-天-4-题）\"><a href=\"#一、初见-DP（2-4-天-4-题）\" class=\"headerlink\" title=\"一、初见 DP（2~4 天 &#x2F; 4 题）\"></a>一、初见 DP（2~4 天 &#x2F; 4 题）</h3><p>题号：<code>2062</code>, <code>1087</code>, <code>1203</code>, <code>1003</code></p>\n<hr>\n<h3 id=\"二、迷宫系列（2-4-天-3-题）\"><a href=\"#二、迷宫系列（2-4-天-3-题）\" class=\"headerlink\" title=\"二、迷宫系列（2~4 天 &#x2F; 3 题）\"></a>二、迷宫系列（2~4 天 &#x2F; 3 题）</h3><p>题号：<code>1728</code>, <code>1010</code>, <code>1072</code></p>\n<hr>\n<h3 id=\"三、数学难题（3-5-天-8-题）\"><a href=\"#三、数学难题（3-5-天-8-题）\" class=\"headerlink\" title=\"三、数学难题（3~5 天 &#x2F; 8 题）\"></a>三、数学难题（3~5 天 &#x2F; 8 题）</h3><p>题号：<code>1052</code>, <code>1568</code>, <code>1443</code>, <code>1222</code>, <code>1249</code>, <code>1005</code>, <code>2674</code>, <code>1018</code></p>\n<hr>\n<h3 id=\"四、龙门客栈（2-3-天-3-题）\"><a href=\"#四、龙门客栈（2-3-天-3-题）\" class=\"headerlink\" title=\"四、龙门客栈（2~3 天 &#x2F; 3 题）\"></a>四、龙门客栈（2~3 天 &#x2F; 3 题）</h3><p>题号：<code>1022</code>, <code>1237</code>, <code>1082</code></p>\n<hr>\n<h2 id=\"分类整理：题目类型推荐\"><a href=\"#分类整理：题目类型推荐\" class=\"headerlink\" title=\"分类整理：题目类型推荐\"></a>分类整理：题目类型推荐</h2><h3 id=\"一、模拟题-枚举类\"><a href=\"#一、模拟题-枚举类\" class=\"headerlink\" title=\"一、模拟题 &amp; 枚举类\"></a>一、模拟题 &amp; 枚举类</h3><p>代表题目：<br><code>1002</code>, <code>1004</code>, <code>1013</code>, <code>1015</code>, <code>1033</code>, <code>1047</code>, <code>1050</code>, <code>1057</code>, <code>1062</code>, <code>1075</code>, <code>1082</code>, <code>1106</code>, <code>1172</code>, <code>1200</code>, <code>1212</code>, <code>1225</code>, <code>1236</code>, <code>1282</code>, <code>1305</code>, 等</p>\n<hr>\n<h3 id=\"二、搜索-递归类\"><a href=\"#二、搜索-递归类\" class=\"headerlink\" title=\"二、搜索 &#x2F; 递归类\"></a>二、搜索 &#x2F; 递归类</h3><p>代表题目：<br><code>1010</code>, <code>1016</code>, <code>1026</code>, <code>1043</code>, <code>1044</code>, <code>1045</code>, <code>1067</code>, <code>1072</code>, <code>1104</code>, <code>1175</code>, <code>1208</code>, <code>1242</code>, <code>1271</code>, <code>1312</code></p>\n<hr>\n<h3 id=\"三、动态规划（DP）\"><a href=\"#三、动态规划（DP）\" class=\"headerlink\" title=\"三、动态规划（DP）\"></a>三、动态规划（DP）</h3><p>代表题目：<br><code>1003</code>, <code>1024</code>, <code>1025</code>, <code>1051</code>, <code>1058</code>, <code>1059</code>, <code>1074</code>, <code>1078</code>, <code>1080</code>, <code>1081</code>, <code>1085</code>, <code>1087</code>, <code>1158</code>, <code>1203</code>, <code>1244</code>, <code>1254</code>, <code>1300</code></p>\n<hr>\n<h3 id=\"四、数学-递推-找规律\"><a href=\"#四、数学-递推-找规律\" class=\"headerlink\" title=\"四、数学 &#x2F; 递推 &#x2F; 找规律\"></a>四、数学 &#x2F; 递推 &#x2F; 找规律</h3><p>代表题目：<br><code>1005</code>, <code>1012</code>, <code>1018</code>, <code>1021</code>, <code>1023</code>, <code>1046</code>, <code>1061</code>, <code>1071</code>, <code>1097</code>, <code>1100</code>, <code>1112</code>, <code>1132</code>, <code>1165</code>, <code>1214</code>, <code>1249</code>, <code>1267</code>, <code>1290</code></p>\n<hr>\n<h3 id=\"五、数论\"><a href=\"#五、数论\" class=\"headerlink\" title=\"五、数论\"></a>五、数论</h3><p>代表题目：<br><code>1164</code>, <code>1211</code>, <code>1222</code>, <code>1286</code>, <code>1299</code></p>\n<hr>\n<h3 id=\"六、计算几何\"><a href=\"#六、计算几何\" class=\"headerlink\" title=\"六、计算几何\"></a>六、计算几何</h3><p>代表题目：<br><code>1086</code>, <code>1115</code>, <code>1147</code></p>\n<hr>\n<h3 id=\"七、贪心算法\"><a href=\"#七、贪心算法\" class=\"headerlink\" title=\"七、贪心算法\"></a>七、贪心算法</h3><p>代表题目：<br><code>1009</code>, <code>1052</code>, <code>1055</code>, <code>1257</code></p>\n<hr>\n<h3 id=\"八、并查集\"><a href=\"#八、并查集\" class=\"headerlink\" title=\"八、并查集\"></a>八、并查集</h3><p>代表题目：<br><code>1198</code>, <code>1213</code>, <code>1232</code>, <code>1272</code></p>\n<hr>\n<h3 id=\"九、图论专题\"><a href=\"#九、图论专题\" class=\"headerlink\" title=\"九、图论专题\"></a>九、图论专题</h3><ul>\n<li>最短路径：<code>1142</code>, <code>1162</code>, <code>1217</code>, <code>1301</code></li>\n<li>二分图：<code>1054</code>, <code>1068</code>, <code>1150</code>, <code>1281</code></li>\n<li>MST、强连通等：<code>1102</code>, <code>1233</code>, <code>1269</code>, <code>1116</code></li>\n</ul>\n<hr>\n<h3 id=\"十、数据结构进阶\"><a href=\"#十、数据结构进阶\" class=\"headerlink\" title=\"十、数据结构进阶\"></a>十、数据结构进阶</h3><ul>\n<li>堆、树状数组、线段树、拓扑排序等：<ul>\n<li><code>1103</code>, <code>1166</code>, <code>1247</code>, <code>1251</code>, <code>1285</code>, <code>1298</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"杭电-1500-专题题单（部分）\"><a href=\"#杭电-1500-专题题单（部分）\" class=\"headerlink\" title=\"杭电 1500+ 专题题单（部分）\"></a>杭电 1500+ 专题题单（部分）</h2><table>\n<thead>\n<tr>\n<th>题号</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1500</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1501</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1502</td>\n<td>DP &#x2F; 记忆化</td>\n</tr>\n<tr>\n<td>1503</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1504</td>\n<td>模拟</td>\n</tr>\n<tr>\n<td>1505</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1506</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1507</td>\n<td>二分匹配</td>\n</tr>\n<tr>\n<td>1508</td>\n<td>记忆化搜索</td>\n</tr>\n<tr>\n<td>1509</td>\n<td>模拟</td>\n</tr>\n<tr>\n<td>1510</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1511</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td>1512</td>\n<td>左偏树</td>\n</tr>\n<tr>\n<td>1513</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1514</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1515</td>\n<td>DFS</td>\n</tr>\n<tr>\n<td>1516</td>\n<td>DP</td>\n</tr>\n<tr>\n<td>1517</td>\n<td>博弈</td>\n</tr>\n<tr>\n<td>1518</td>\n<td>搜索</td>\n</tr>\n<tr>\n<td>1520</td>\n<td>树状 DP</td>\n</tr>\n<tr>\n<td>1521</td>\n<td>数学 &#x2F; 母函数</td>\n</tr>\n<tr>\n<td>1522</td>\n<td>稳定婚姻</td>\n</tr>\n<tr>\n<td>1526</td>\n<td>最大流</td>\n</tr>\n<tr>\n<td>1530</td>\n<td>最大团</td>\n</tr>\n<tr>\n<td>1532</td>\n<td>最大流（入门）</td>\n</tr>\n<tr>\n<td>1533</td>\n<td>KM &#x2F; 最小费用流</td>\n</tr>\n<tr>\n<td>1534~1535</td>\n<td>差分约束</td>\n</tr>\n<tr>\n<td>1564</td>\n<td>博弈</td>\n</tr>\n<tr>\n<td>1569</td>\n<td>最小割</td>\n</tr>\n</tbody></table>\n<p>📌 <strong>注：</strong> 1500 题以上大多属于比赛原题或高难度训练题，适合在前三阶段完成后深入挑战。</p>\n<hr>\n<h2 id=\"📚-总结\"><a href=\"#📚-总结\" class=\"headerlink\" title=\"📚 总结\"></a>📚 总结</h2><ul>\n<li>从 <strong>输入输出、基础数学、简单字符串处理</strong> 开始入门；</li>\n<li>逐步挑战 <strong>搜索、动态规划、图论、博弈论</strong> 等核心 ACM 算法；</li>\n<li>多归类总结，整理错题，形成知识图谱；</li>\n<li>养成刷题“项目化”的习惯，每一阶段都制定计划；</li>\n</ul>\n<p>🧠 <strong>刷题并非死记套路，而是构建解决问题的能力。</strong></p>\n<p>愿你在 ACM 的旅途中，不断突破自我，收获成长！</p>\n"},{"title":"ACM算法之递归","date":"2020-07-12T01:57:14.000Z","_content":"\n# ACM 算法之递归\n\n## 什么是递归？\n\n> 递归（Recursion）是一种程序调用自身的编程技巧，常用于将复杂问题分解为规模更小的同类问题。  \n> 它是一种 **“以小见大”** 的思想，用有限的代码描述无限的过程。\n\n递归在程序设计语言中被广泛应用，尤其在算法题中非常常见。其核心在于：\n\n- **边界条件**：定义递归终止的情形；\n- **递归调用**：将问题逐步缩小并调用自身；\n- **返回过程**：逐层返回解，最终合并结果。\n\n举个例子：**阶乘的递归定义**\n\n```text\nfac(1) = 1\nfac(n) = n * fac(n-1)\n```\n\n## 递归三步走（以阶乘为例）\n\n### Step 1：边界条件（终止递归的出口）\n\n我们先考虑一个简单的问题：6! =6 × 5 × 4 × 3 × 2 × 1。\n\n在编写阶乘函数时，我们可以有两种实现思路：\n\n- **从 1 乘到 n**（正序递归）\n\n- **从 n 乘到 1**（逆序递归）\n\n不论哪种方式，核心都在于**设定边界条件**，也就是：**什么时候停止递归？**\n\n我们这里采用第二种方式 —— **从 n 递减到 1**：\n\n当 `n == 1` 时，就不再继续向下递归，而是直接返回 `1`，这就是我们设定的递归终止条件（边界）：\n\n```python\ndef fac(i):\n  if(i==1):    #边界条件\n    return 1\n```\n\n这意味着，**当问题被缩小到最简单的情况（n=1）时，递归不再继续，而是开始回传答案。**\n\n### Step 2：递归调用（函数调用自身）\n\n在确定了边界后，我们就可以让函数调用自身，把大问题逐步“压小”：\n\n```python\ndef fac(i):\n    if i == 1:\n        return 1\n    return fac(i - 1) * i\n```\n\n这时，函数每次都会将问题规模减小为 `fac(i-1)`，直到 `i == 1` 为止。\n\n### Step 3：返回过程（从最小问题逐层回传）\n\n递归调用本质上是**函数栈**，每次压栈是“前进”，每次 return 是“回退”。\n\n举个例子：`fac(6)` 实际调用流程如下：\n\n```text\nfac(6)\n→ return fac(5) * 6\n→ → return fac(4) * 5\n→ → → return fac(3) * 4\n→ → → → return fac(2) * 3\n→ → → → → return fac(1) * 2\n→ → → → → → return 1\n最终返回值：1 * 2 * 3 * 4 * 5 * 6 = 720\n\n```\n\n![recursion.jpg](https://s2.loli.net/2025/07/06/BuCyzem6ORcAEbL.jpg)\n\n## 构成递归的必要条件\n\n- 1、子问题必须与原问题结构相同，且规模更小；\n\n- 2、必须有终止条件，否则将无限调用；\n\n- 3、问题最终需能归结为基本情形求解。\n\n以经典的**斐波那契数列**为例：\n\n```text\nFib(0) = 1\nFib(1) = 1\nFib(n) = Fib(n-1) + Fib(n-2)  （n > 1）\n```\n\n虽然写法简单，但由于重复计算多，效率低，因此在实际编程中经常结合**记忆化搜索**或**动态规划**来优化。\n\n## 生活中的递归现象\n\n递归不仅仅是代码技巧，也出现在生活和艺术中，例如：\n\n- **德罗斯特效应**：一个图像中包含缩小版的自己，一层套一层；\n\n- **镜中蜡烛**：两面镜子之间放置蜡烛，可以看到无限反射；\n\n- **搬箱子问题**：你要搬 100 个箱子，先搬一个，再解决“搬 99 个箱子”的问题……\n\n这类递归式的思维方式，正是递归定义的日常化体现。\n\n## 实战演练\n\n### 递归的经典应用：斐波那契数列\n\n> 斐波那契数列（Fibonacci Sequence）是递归最经典的应用之一。  \n> 它的定义是：一个数等于前两个数之和。\n\n```python\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nn = int(input(\"请输入一个正整数 n：\"))\nprint(f\"第 {n} 个斐波那契数是：{fib(n)}\")\n```\n\n> 注意：这种方式虽然直观，但性能较差，时间复杂度是指数级（约为 O(2ⁿ)），不适合计算较大的 n。\n\n输出示例（输入 10）：\n\n```text\n第 10 个斐波那契数是：55\n```\n\n#### 算法题：卖鸭子\n\n一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子\n\n递归终止的条件是当达到第 7 个村庄时递归停止，设经过的村庄数为 n 则有剩余的鸭子为总数为每次剩余的鸭子数位 sum = sum-(sum/2+1)\n算法构造：当 n=7 时 sum = 2;当 0<n<7 时 sum =2\\*m+2;\n\n源代码：\n\n```C\n#include <iostream.h>\nclass Questionone{\npublic:\n    int answer(int n, int sum){\n        if(n>0){\n            sum = 2*sum+2;\n            if(n-1>0){\n                cout<<\"第\"<<n-1<<\"个村庄\"<<\"卖出\"<<2*sum+2-sum<<endl;\n            }\n            n--;\n            return answer(n,sum);\n\n        }else{\n            return sum;\n        }\n    }\n};\nvoid main(){\n    int SUM = 2;\n    int  N =  7;\n    Questionone question;\n    cout<<\"总数：\"<<question.answer(N,SUM)<<endl;\n}\n```\n\n### 经典算法题：角谷定理\n\n题目：\n输入一个自然数，若为偶数，则把它除以 2，若为奇数，则把它乘以 3 加 1。经过如此有限次运算后，总可以得到自然数值 1。求经过多少次可得到自然数 1。\n\n算法分析：\n递归的终止条件是最后值为 1；设输入的值为 n 先进项判断，若 n = 1 则输出 n;\n若 n 不为 1；则对他进行偶数判断，若为偶数除 2，若为奇数则乘 3 加 1；然后在进行偶数判断，直到 n = 1 为止；\n算法构造\nn=1 时 输出 n；n!=1 时 偶数判断 偶数 n = n/2;若是奇数 n = 3\\*n+1\n\n源代码：\n\n```C\n#include<iostream.h>\nclass questiontwo{\n    public:\n        int answer(int sum){\n            if(sum == 1){\n                cout<<\" \"<<sum;\n                return sum;\n            }else{\n                if((sum%2) == 1){\n                    sum = 3*sum+1;\n                    cout<<\" \"<<sum;\n                    return answer(sum);\n                }else{\n                    sum = sum/2;\n                    cout<<\" \"<<sum;\n                    return answer(sum);\n                }\n            }\n        }\n};\nvoid main(){\n    int c ;\n    cout<<\"请输入一个数\"<<endl;\n    cin>>c;\n    questiontwo question2;\n    question2.answer(c);\n}\n```\n\n### 经典算法题：电话号码\n\n题目：\n电话号码对应的字符组合：在电话或者手机上，一个数字对应着字母 ABC，7 对应着 PQRS。那么数字串 27 所对应的字符可能组合就有 3\\*4 种（如 AP,BR 等）。现在输入一个 3 到 11 位长的电话号码，请打印出这个电话号码对应的字符的所有可能组合和组合数。\n\n题目分析：\n根据题意可知：2 对应的是 ABC 3 对应的是 DEF 4 对应的是 GHI 5 对应的 JKL 6 对应的是 MNO 7 对应的是 PQRS 8 对应的是 TUV 9 对应的是 WXYZ\n\n源代码：\n\n```C\npublic class questionthree {\n    /**\n    *\n    * @param number      电话号码\n    * @param answer    辅助数组\n    * @param index  电话位数中对应的第几位循环\n    * @param n  电话位数\n    */\n    public static void Answer(int []number, int []answer,int\n    index,int n){\n        char[][] word ={{},{},{'A','B','c'},{'D','E','F'},{'G',\n            'H','I'},{'J','K','L'},{'M','N','O'},{'P','Q','R','s'},\n            {'T','U','V'},{'W','X','Y','Z'}};\n        int []sum = {0,0,3,3,3,3,3,4,3,4};\n        if(index == n){\n            for(int i = 0; i<n; i++){\n                System.out.print(word[number[i]][answer[i]]);\n            }\n            System.out.println(\";\");\n            return ;\n        }\n        for(answer[index] = 0; answer[index] < sum [number[index]]; answer[index]++){\n            Answer(number,answer,index+1,n);\n        }\n    }\n    public static void main(String[] args){\n        int[] number = {2,3,4,5,6,7,8,9};\n        int[] answer = new int[number.length];\n        Answer(number, answer, 0, number.length);\n\n    }\n}\n```\n\n### 经典算法题：柿子分配\n\n题目：\n日本著名数学游戏专家中村义作教授提出这样一个问题：父亲将 2520 个桔子分给六个儿子。分完 后父亲说：“老大将分给你的桔子的 1/8 给老二；老二拿到后连同原先的桔子分 1/7 给老三；老三拿到后连同原先的桔子分 1/6 给老四；老四拿到后连同原先的桔子分 1/5 给老五；老五拿到后连同原先的桔子分 1/4 给老六；老六拿到后连同原先的桔子分 1/3 给老大”。结果大家手中的桔子正好一 样多。问六兄弟原来手中各有多少桔子？\n\n题目分析：\n解决此问题主要使用递归运算。由题目可以看出原来手中的加上得到的满足关系式：StartNum = 420 * (n -2)/(n - 1)  分给下一个人的橘子数：GiveNum = AfterGetNum / n;   下一个人的橘子数：nextStartNum = 420*(n-1)/(n-2) - GiveNum;   下一个人加上之前得到的橘子的总数：afterGetNum = nextStartNum + GiveNum;   以此使用递归算法可以算出各个孩子原来手中的橘子数。\n\n源代码：\n\n```C\npublic class questionfour {\n    /**\n    *\n    * @param n  表示第几个儿子\n    * @param befor  表示为分配之前就的桔子数\n    * @param After    表示分配之后的桔子数\n    * @param m        分配的比例\n    * @return\n    */\n    public int answer(int n,int befornum, int afternum,int m ){\n        if(n>6){\n            return 0;\n        }else{\n            System.out.println(\"老\"+n+\"原有的桔子数\"+befornum);\n            //分给下一个人的桔子数\n            int givenum = afternum/m;\n            //下一个人的桔子数\n            int nextBeforenum = 420*(m-1)/(m-2)-givenum;\n            //下一人加上之前的桔子数的总数\n            int afterGetnum = nextBeforenum+givenum;\n            return answer(n+1,nextBeforenum,afterGetnum,m-1);\n        }\n    }\n    public static void main(String[] args){\n        questionfour question4 = new questionfour();\n        question4.answer(1, 240, 240, 8);\n    }\n```\n\n## 总结\n\n递归是一种将**大问题分解为小问题**、逐层求解再合并结果的强大方法。掌握递归不仅是解题利器，更能帮助你建立更抽象、更系统的问题解决能力。\n","source":"_posts/04-ACM-algorithm-recursion.md","raw":"---\ntitle: ACM算法之递归\ndate: 2020-07-12 09:57:14\ntags:\n  - 递归\n  - ACM算法\ncategories:\n  - 算法入门\n---\n\n# ACM 算法之递归\n\n## 什么是递归？\n\n> 递归（Recursion）是一种程序调用自身的编程技巧，常用于将复杂问题分解为规模更小的同类问题。  \n> 它是一种 **“以小见大”** 的思想，用有限的代码描述无限的过程。\n\n递归在程序设计语言中被广泛应用，尤其在算法题中非常常见。其核心在于：\n\n- **边界条件**：定义递归终止的情形；\n- **递归调用**：将问题逐步缩小并调用自身；\n- **返回过程**：逐层返回解，最终合并结果。\n\n举个例子：**阶乘的递归定义**\n\n```text\nfac(1) = 1\nfac(n) = n * fac(n-1)\n```\n\n## 递归三步走（以阶乘为例）\n\n### Step 1：边界条件（终止递归的出口）\n\n我们先考虑一个简单的问题：6! =6 × 5 × 4 × 3 × 2 × 1。\n\n在编写阶乘函数时，我们可以有两种实现思路：\n\n- **从 1 乘到 n**（正序递归）\n\n- **从 n 乘到 1**（逆序递归）\n\n不论哪种方式，核心都在于**设定边界条件**，也就是：**什么时候停止递归？**\n\n我们这里采用第二种方式 —— **从 n 递减到 1**：\n\n当 `n == 1` 时，就不再继续向下递归，而是直接返回 `1`，这就是我们设定的递归终止条件（边界）：\n\n```python\ndef fac(i):\n  if(i==1):    #边界条件\n    return 1\n```\n\n这意味着，**当问题被缩小到最简单的情况（n=1）时，递归不再继续，而是开始回传答案。**\n\n### Step 2：递归调用（函数调用自身）\n\n在确定了边界后，我们就可以让函数调用自身，把大问题逐步“压小”：\n\n```python\ndef fac(i):\n    if i == 1:\n        return 1\n    return fac(i - 1) * i\n```\n\n这时，函数每次都会将问题规模减小为 `fac(i-1)`，直到 `i == 1` 为止。\n\n### Step 3：返回过程（从最小问题逐层回传）\n\n递归调用本质上是**函数栈**，每次压栈是“前进”，每次 return 是“回退”。\n\n举个例子：`fac(6)` 实际调用流程如下：\n\n```text\nfac(6)\n→ return fac(5) * 6\n→ → return fac(4) * 5\n→ → → return fac(3) * 4\n→ → → → return fac(2) * 3\n→ → → → → return fac(1) * 2\n→ → → → → → return 1\n最终返回值：1 * 2 * 3 * 4 * 5 * 6 = 720\n\n```\n\n![recursion.jpg](https://s2.loli.net/2025/07/06/BuCyzem6ORcAEbL.jpg)\n\n## 构成递归的必要条件\n\n- 1、子问题必须与原问题结构相同，且规模更小；\n\n- 2、必须有终止条件，否则将无限调用；\n\n- 3、问题最终需能归结为基本情形求解。\n\n以经典的**斐波那契数列**为例：\n\n```text\nFib(0) = 1\nFib(1) = 1\nFib(n) = Fib(n-1) + Fib(n-2)  （n > 1）\n```\n\n虽然写法简单，但由于重复计算多，效率低，因此在实际编程中经常结合**记忆化搜索**或**动态规划**来优化。\n\n## 生活中的递归现象\n\n递归不仅仅是代码技巧，也出现在生活和艺术中，例如：\n\n- **德罗斯特效应**：一个图像中包含缩小版的自己，一层套一层；\n\n- **镜中蜡烛**：两面镜子之间放置蜡烛，可以看到无限反射；\n\n- **搬箱子问题**：你要搬 100 个箱子，先搬一个，再解决“搬 99 个箱子”的问题……\n\n这类递归式的思维方式，正是递归定义的日常化体现。\n\n## 实战演练\n\n### 递归的经典应用：斐波那契数列\n\n> 斐波那契数列（Fibonacci Sequence）是递归最经典的应用之一。  \n> 它的定义是：一个数等于前两个数之和。\n\n```python\ndef fib(n):\n    if n <= 1:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\nn = int(input(\"请输入一个正整数 n：\"))\nprint(f\"第 {n} 个斐波那契数是：{fib(n)}\")\n```\n\n> 注意：这种方式虽然直观，但性能较差，时间复杂度是指数级（约为 O(2ⁿ)），不适合计算较大的 n。\n\n输出示例（输入 10）：\n\n```text\n第 10 个斐波那契数是：55\n```\n\n#### 算法题：卖鸭子\n\n一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子\n\n递归终止的条件是当达到第 7 个村庄时递归停止，设经过的村庄数为 n 则有剩余的鸭子为总数为每次剩余的鸭子数位 sum = sum-(sum/2+1)\n算法构造：当 n=7 时 sum = 2;当 0<n<7 时 sum =2\\*m+2;\n\n源代码：\n\n```C\n#include <iostream.h>\nclass Questionone{\npublic:\n    int answer(int n, int sum){\n        if(n>0){\n            sum = 2*sum+2;\n            if(n-1>0){\n                cout<<\"第\"<<n-1<<\"个村庄\"<<\"卖出\"<<2*sum+2-sum<<endl;\n            }\n            n--;\n            return answer(n,sum);\n\n        }else{\n            return sum;\n        }\n    }\n};\nvoid main(){\n    int SUM = 2;\n    int  N =  7;\n    Questionone question;\n    cout<<\"总数：\"<<question.answer(N,SUM)<<endl;\n}\n```\n\n### 经典算法题：角谷定理\n\n题目：\n输入一个自然数，若为偶数，则把它除以 2，若为奇数，则把它乘以 3 加 1。经过如此有限次运算后，总可以得到自然数值 1。求经过多少次可得到自然数 1。\n\n算法分析：\n递归的终止条件是最后值为 1；设输入的值为 n 先进项判断，若 n = 1 则输出 n;\n若 n 不为 1；则对他进行偶数判断，若为偶数除 2，若为奇数则乘 3 加 1；然后在进行偶数判断，直到 n = 1 为止；\n算法构造\nn=1 时 输出 n；n!=1 时 偶数判断 偶数 n = n/2;若是奇数 n = 3\\*n+1\n\n源代码：\n\n```C\n#include<iostream.h>\nclass questiontwo{\n    public:\n        int answer(int sum){\n            if(sum == 1){\n                cout<<\" \"<<sum;\n                return sum;\n            }else{\n                if((sum%2) == 1){\n                    sum = 3*sum+1;\n                    cout<<\" \"<<sum;\n                    return answer(sum);\n                }else{\n                    sum = sum/2;\n                    cout<<\" \"<<sum;\n                    return answer(sum);\n                }\n            }\n        }\n};\nvoid main(){\n    int c ;\n    cout<<\"请输入一个数\"<<endl;\n    cin>>c;\n    questiontwo question2;\n    question2.answer(c);\n}\n```\n\n### 经典算法题：电话号码\n\n题目：\n电话号码对应的字符组合：在电话或者手机上，一个数字对应着字母 ABC，7 对应着 PQRS。那么数字串 27 所对应的字符可能组合就有 3\\*4 种（如 AP,BR 等）。现在输入一个 3 到 11 位长的电话号码，请打印出这个电话号码对应的字符的所有可能组合和组合数。\n\n题目分析：\n根据题意可知：2 对应的是 ABC 3 对应的是 DEF 4 对应的是 GHI 5 对应的 JKL 6 对应的是 MNO 7 对应的是 PQRS 8 对应的是 TUV 9 对应的是 WXYZ\n\n源代码：\n\n```C\npublic class questionthree {\n    /**\n    *\n    * @param number      电话号码\n    * @param answer    辅助数组\n    * @param index  电话位数中对应的第几位循环\n    * @param n  电话位数\n    */\n    public static void Answer(int []number, int []answer,int\n    index,int n){\n        char[][] word ={{},{},{'A','B','c'},{'D','E','F'},{'G',\n            'H','I'},{'J','K','L'},{'M','N','O'},{'P','Q','R','s'},\n            {'T','U','V'},{'W','X','Y','Z'}};\n        int []sum = {0,0,3,3,3,3,3,4,3,4};\n        if(index == n){\n            for(int i = 0; i<n; i++){\n                System.out.print(word[number[i]][answer[i]]);\n            }\n            System.out.println(\";\");\n            return ;\n        }\n        for(answer[index] = 0; answer[index] < sum [number[index]]; answer[index]++){\n            Answer(number,answer,index+1,n);\n        }\n    }\n    public static void main(String[] args){\n        int[] number = {2,3,4,5,6,7,8,9};\n        int[] answer = new int[number.length];\n        Answer(number, answer, 0, number.length);\n\n    }\n}\n```\n\n### 经典算法题：柿子分配\n\n题目：\n日本著名数学游戏专家中村义作教授提出这样一个问题：父亲将 2520 个桔子分给六个儿子。分完 后父亲说：“老大将分给你的桔子的 1/8 给老二；老二拿到后连同原先的桔子分 1/7 给老三；老三拿到后连同原先的桔子分 1/6 给老四；老四拿到后连同原先的桔子分 1/5 给老五；老五拿到后连同原先的桔子分 1/4 给老六；老六拿到后连同原先的桔子分 1/3 给老大”。结果大家手中的桔子正好一 样多。问六兄弟原来手中各有多少桔子？\n\n题目分析：\n解决此问题主要使用递归运算。由题目可以看出原来手中的加上得到的满足关系式：StartNum = 420 * (n -2)/(n - 1)  分给下一个人的橘子数：GiveNum = AfterGetNum / n;   下一个人的橘子数：nextStartNum = 420*(n-1)/(n-2) - GiveNum;   下一个人加上之前得到的橘子的总数：afterGetNum = nextStartNum + GiveNum;   以此使用递归算法可以算出各个孩子原来手中的橘子数。\n\n源代码：\n\n```C\npublic class questionfour {\n    /**\n    *\n    * @param n  表示第几个儿子\n    * @param befor  表示为分配之前就的桔子数\n    * @param After    表示分配之后的桔子数\n    * @param m        分配的比例\n    * @return\n    */\n    public int answer(int n,int befornum, int afternum,int m ){\n        if(n>6){\n            return 0;\n        }else{\n            System.out.println(\"老\"+n+\"原有的桔子数\"+befornum);\n            //分给下一个人的桔子数\n            int givenum = afternum/m;\n            //下一个人的桔子数\n            int nextBeforenum = 420*(m-1)/(m-2)-givenum;\n            //下一人加上之前的桔子数的总数\n            int afterGetnum = nextBeforenum+givenum;\n            return answer(n+1,nextBeforenum,afterGetnum,m-1);\n        }\n    }\n    public static void main(String[] args){\n        questionfour question4 = new questionfour();\n        question4.answer(1, 240, 240, 8);\n    }\n```\n\n## 总结\n\n递归是一种将**大问题分解为小问题**、逐层求解再合并结果的强大方法。掌握递归不仅是解题利器，更能帮助你建立更抽象、更系统的问题解决能力。\n","slug":"04-ACM-algorithm-recursion","published":1,"updated":"2025-07-06T03:19:30.485Z","comments":1,"layout":"post","photos":[],"_id":"cmcr40e1c000emwnf8enf4h7v","content":"<h1 id=\"ACM-算法之递归\"><a href=\"#ACM-算法之递归\" class=\"headerlink\" title=\"ACM 算法之递归\"></a>ACM 算法之递归</h1><h2 id=\"什么是递归？\"><a href=\"#什么是递归？\" class=\"headerlink\" title=\"什么是递归？\"></a>什么是递归？</h2><blockquote>\n<p>递归（Recursion）是一种程序调用自身的编程技巧，常用于将复杂问题分解为规模更小的同类问题。<br>它是一种 <strong>“以小见大”</strong> 的思想，用有限的代码描述无限的过程。</p>\n</blockquote>\n<p>递归在程序设计语言中被广泛应用，尤其在算法题中非常常见。其核心在于：</p>\n<ul>\n<li><strong>边界条件</strong>：定义递归终止的情形；</li>\n<li><strong>递归调用</strong>：将问题逐步缩小并调用自身；</li>\n<li><strong>返回过程</strong>：逐层返回解，最终合并结果。</li>\n</ul>\n<p>举个例子：<strong>阶乘的递归定义</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fac(1) = 1</span><br><span class=\"line\">fac(n) = n * fac(n-1)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"递归三步走（以阶乘为例）\"><a href=\"#递归三步走（以阶乘为例）\" class=\"headerlink\" title=\"递归三步走（以阶乘为例）\"></a>递归三步走（以阶乘为例）</h2><h3 id=\"Step-1：边界条件（终止递归的出口）\"><a href=\"#Step-1：边界条件（终止递归的出口）\" class=\"headerlink\" title=\"Step 1：边界条件（终止递归的出口）\"></a>Step 1：边界条件（终止递归的出口）</h3><p>我们先考虑一个简单的问题：6! &#x3D;6 × 5 × 4 × 3 × 2 × 1。</p>\n<p>在编写阶乘函数时，我们可以有两种实现思路：</p>\n<ul>\n<li><p><strong>从 1 乘到 n</strong>（正序递归）</p>\n</li>\n<li><p><strong>从 n 乘到 1</strong>（逆序递归）</p>\n</li>\n</ul>\n<p>不论哪种方式，核心都在于<strong>设定边界条件</strong>，也就是：<strong>什么时候停止递归？</strong></p>\n<p>我们这里采用第二种方式 —— <strong>从 n 递减到 1</strong>：</p>\n<p>当 <code>n == 1</code> 时，就不再继续向下递归，而是直接返回 <code>1</code>，这就是我们设定的递归终止条件（边界）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fac</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>):    <span class=\"comment\">#边界条件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>这意味着，<strong>当问题被缩小到最简单的情况（n&#x3D;1）时，递归不再继续，而是开始回传答案。</strong></p>\n<h3 id=\"Step-2：递归调用（函数调用自身）\"><a href=\"#Step-2：递归调用（函数调用自身）\" class=\"headerlink\" title=\"Step 2：递归调用（函数调用自身）\"></a>Step 2：递归调用（函数调用自身）</h3><p>在确定了边界后，我们就可以让函数调用自身，把大问题逐步“压小”：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fac</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fac(i - <span class=\"number\">1</span>) * i</span><br></pre></td></tr></table></figure>\n\n<p>这时，函数每次都会将问题规模减小为 <code>fac(i-1)</code>，直到 <code>i == 1</code> 为止。</p>\n<h3 id=\"Step-3：返回过程（从最小问题逐层回传）\"><a href=\"#Step-3：返回过程（从最小问题逐层回传）\" class=\"headerlink\" title=\"Step 3：返回过程（从最小问题逐层回传）\"></a>Step 3：返回过程（从最小问题逐层回传）</h3><p>递归调用本质上是<strong>函数栈</strong>，每次压栈是“前进”，每次 return 是“回退”。</p>\n<p>举个例子：<code>fac(6)</code> 实际调用流程如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fac(6)</span><br><span class=\"line\">→ return fac(5) * 6</span><br><span class=\"line\">→ → return fac(4) * 5</span><br><span class=\"line\">→ → → return fac(3) * 4</span><br><span class=\"line\">→ → → → return fac(2) * 3</span><br><span class=\"line\">→ → → → → return fac(1) * 2</span><br><span class=\"line\">→ → → → → → return 1</span><br><span class=\"line\">最终返回值：1 * 2 * 3 * 4 * 5 * 6 = 720</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2025/07/06/BuCyzem6ORcAEbL.jpg\" class=\"lazyload\" data-srcset=\"https://s2.loli.net/2025/07/06/BuCyzem6ORcAEbL.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" alt=\"recursion.jpg\"></p>\n<h2 id=\"构成递归的必要条件\"><a href=\"#构成递归的必要条件\" class=\"headerlink\" title=\"构成递归的必要条件\"></a>构成递归的必要条件</h2><ul>\n<li><p>1、子问题必须与原问题结构相同，且规模更小；</p>\n</li>\n<li><p>2、必须有终止条件，否则将无限调用；</p>\n</li>\n<li><p>3、问题最终需能归结为基本情形求解。</p>\n</li>\n</ul>\n<p>以经典的<strong>斐波那契数列</strong>为例：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fib(0) = 1</span><br><span class=\"line\">Fib(1) = 1</span><br><span class=\"line\">Fib(n) = Fib(n-1) + Fib(n-2)  （n &gt; 1）</span><br></pre></td></tr></table></figure>\n\n<p>虽然写法简单，但由于重复计算多，效率低，因此在实际编程中经常结合<strong>记忆化搜索</strong>或<strong>动态规划</strong>来优化。</p>\n<h2 id=\"生活中的递归现象\"><a href=\"#生活中的递归现象\" class=\"headerlink\" title=\"生活中的递归现象\"></a>生活中的递归现象</h2><p>递归不仅仅是代码技巧，也出现在生活和艺术中，例如：</p>\n<ul>\n<li><p><strong>德罗斯特效应</strong>：一个图像中包含缩小版的自己，一层套一层；</p>\n</li>\n<li><p><strong>镜中蜡烛</strong>：两面镜子之间放置蜡烛，可以看到无限反射；</p>\n</li>\n<li><p><strong>搬箱子问题</strong>：你要搬 100 个箱子，先搬一个，再解决“搬 99 个箱子”的问题……</p>\n</li>\n</ul>\n<p>这类递归式的思维方式，正是递归定义的日常化体现。</p>\n<h2 id=\"实战演练\"><a href=\"#实战演练\" class=\"headerlink\" title=\"实战演练\"></a>实战演练</h2><h3 id=\"递归的经典应用：斐波那契数列\"><a href=\"#递归的经典应用：斐波那契数列\" class=\"headerlink\" title=\"递归的经典应用：斐波那契数列\"></a>递归的经典应用：斐波那契数列</h3><blockquote>\n<p>斐波那契数列（Fibonacci Sequence）是递归最经典的应用之一。<br>它的定义是：一个数等于前两个数之和。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fib</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>(<span class=\"string\">&quot;请输入一个正整数 n：&quot;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第 <span class=\"subst\">&#123;n&#125;</span> 个斐波那契数是：<span class=\"subst\">&#123;fib(n)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：这种方式虽然直观，但性能较差，时间复杂度是指数级（约为 O(2ⁿ)），不适合计算较大的 n。</p>\n</blockquote>\n<p>输出示例（输入 10）：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 10 个斐波那契数是：55</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法题：卖鸭子\"><a href=\"#算法题：卖鸭子\" class=\"headerlink\" title=\"算法题：卖鸭子\"></a>算法题：卖鸭子</h4><p>一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子</p>\n<p>递归终止的条件是当达到第 7 个村庄时递归停止，设经过的村庄数为 n 则有剩余的鸭子为总数为每次剩余的鸭子数位 sum &#x3D; sum-(sum&#x2F;2+1)<br>算法构造：当 n&#x3D;7 时 sum &#x3D; 2;当 0&lt;n&lt;7 时 sum &#x3D;2*m+2;</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Questionone</span>&#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">answer</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> sum)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum = <span class=\"number\">2</span>*sum+<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n<span class=\"number\">-1</span>&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;第&quot;</span>&lt;&lt;n<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;个村庄&quot;</span>&lt;&lt;<span class=\"string\">&quot;卖出&quot;</span>&lt;&lt;<span class=\"number\">2</span>*sum+<span class=\"number\">2</span>-sum&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> answer(n,sum);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> SUM = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>  N =  <span class=\"number\">7</span>;</span><br><span class=\"line\">    Questionone question;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;总数：&quot;</span>&lt;&lt;question.answer(N,SUM)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典算法题：角谷定理\"><a href=\"#经典算法题：角谷定理\" class=\"headerlink\" title=\"经典算法题：角谷定理\"></a>经典算法题：角谷定理</h3><p>题目：<br>输入一个自然数，若为偶数，则把它除以 2，若为奇数，则把它乘以 3 加 1。经过如此有限次运算后，总可以得到自然数值 1。求经过多少次可得到自然数 1。</p>\n<p>算法分析：<br>递归的终止条件是最后值为 1；设输入的值为 n 先进项判断，若 n &#x3D; 1 则输出 n;<br>若 n 不为 1；则对他进行偶数判断，若为偶数除 2，若为奇数则乘 3 加 1；然后在进行偶数判断，直到 n &#x3D; 1 为止；<br>算法构造<br>n&#x3D;1 时 输出 n；n!&#x3D;1 时 偶数判断 偶数 n &#x3D; n&#x2F;2;若是奇数 n &#x3D; 3*n+1</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">questiontwo</span>&#123;</span></span><br><span class=\"line\">    public:</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"title function_\">answer</span><span class=\"params\">(<span class=\"type\">int</span> sum)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((sum%<span class=\"number\">2</span>) == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    sum = <span class=\"number\">3</span>*sum+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> answer(sum);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    sum = sum/<span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> answer(sum);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> c ;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;请输入一个数&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;c;</span><br><span class=\"line\">    questiontwo question2;</span><br><span class=\"line\">    question2.answer(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典算法题：电话号码\"><a href=\"#经典算法题：电话号码\" class=\"headerlink\" title=\"经典算法题：电话号码\"></a>经典算法题：电话号码</h3><p>题目：<br>电话号码对应的字符组合：在电话或者手机上，一个数字对应着字母 ABC，7 对应着 PQRS。那么数字串 27 所对应的字符可能组合就有 3*4 种（如 AP,BR 等）。现在输入一个 3 到 11 位长的电话号码，请打印出这个电话号码对应的字符的所有可能组合和组合数。</p>\n<p>题目分析：<br>根据题意可知：2 对应的是 ABC 3 对应的是 DEF 4 对应的是 GHI 5 对应的 JKL 6 对应的是 MNO 7 对应的是 PQRS 8 对应的是 TUV 9 对应的是 WXYZ</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">questionthree</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * @param number      电话号码</span></span><br><span class=\"line\"><span class=\"comment\">    * @param answer    辅助数组</span></span><br><span class=\"line\"><span class=\"comment\">    * @param index  电话位数中对应的第几位循环</span></span><br><span class=\"line\"><span class=\"comment\">    * @param n  电话位数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    public <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">Answer</span><span class=\"params\">(<span class=\"type\">int</span> []number, <span class=\"type\">int</span> []answer,<span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"params\">    index,<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>[][] word =&#123;&#123;&#125;,&#123;&#125;,&#123;<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;D&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;F&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;G&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;I&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;J&#x27;</span>,<span class=\"string\">&#x27;K&#x27;</span>,<span class=\"string\">&#x27;L&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;M&#x27;</span>,<span class=\"string\">&#x27;N&#x27;</span>,<span class=\"string\">&#x27;O&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;P&#x27;</span>,<span class=\"string\">&#x27;Q&#x27;</span>,<span class=\"string\">&#x27;R&#x27;</span>,<span class=\"string\">&#x27;s&#x27;</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"string\">&#x27;T&#x27;</span>,<span class=\"string\">&#x27;U&#x27;</span>,<span class=\"string\">&#x27;V&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;X&#x27;</span>,<span class=\"string\">&#x27;Y&#x27;</span>,<span class=\"string\">&#x27;Z&#x27;</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> []sum = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">                System.out.print(word[number[i]][answer[i]]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;;&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(answer[index] = <span class=\"number\">0</span>; answer[index] &lt; sum [number[index]]; answer[index]++)&#123;</span><br><span class=\"line\">            Answer(number,answer,index+<span class=\"number\">1</span>,n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] number = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] answer = new <span class=\"type\">int</span>[number.length];</span><br><span class=\"line\">        Answer(number, answer, <span class=\"number\">0</span>, number.length);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典算法题：柿子分配\"><a href=\"#经典算法题：柿子分配\" class=\"headerlink\" title=\"经典算法题：柿子分配\"></a>经典算法题：柿子分配</h3><p>题目：<br>日本著名数学游戏专家中村义作教授提出这样一个问题：父亲将 2520 个桔子分给六个儿子。分完 后父亲说：“老大将分给你的桔子的 1&#x2F;8 给老二；老二拿到后连同原先的桔子分 1&#x2F;7 给老三；老三拿到后连同原先的桔子分 1&#x2F;6 给老四；老四拿到后连同原先的桔子分 1&#x2F;5 给老五；老五拿到后连同原先的桔子分 1&#x2F;4 给老六；老六拿到后连同原先的桔子分 1&#x2F;3 给老大”。结果大家手中的桔子正好一 样多。问六兄弟原来手中各有多少桔子？</p>\n<p>题目分析：<br>解决此问题主要使用递归运算。由题目可以看出原来手中的加上得到的满足关系式：StartNum &#x3D; 420 * (n -2)&#x2F;(n - 1)  分给下一个人的橘子数：GiveNum &#x3D; AfterGetNum &#x2F; n;   下一个人的橘子数：nextStartNum &#x3D; 420*(n-1)&#x2F;(n-2) - GiveNum;   下一个人加上之前得到的橘子的总数：afterGetNum &#x3D; nextStartNum + GiveNum;   以此使用递归算法可以算出各个孩子原来手中的橘子数。</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">questionfour</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * @param n  表示第几个儿子</span></span><br><span class=\"line\"><span class=\"comment\">    * @param befor  表示为分配之前就的桔子数</span></span><br><span class=\"line\"><span class=\"comment\">    * @param After    表示分配之后的桔子数</span></span><br><span class=\"line\"><span class=\"comment\">    * @param m        分配的比例</span></span><br><span class=\"line\"><span class=\"comment\">    * @return</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    public <span class=\"type\">int</span> <span class=\"title function_\">answer</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> befornum, <span class=\"type\">int</span> afternum,<span class=\"type\">int</span> m )</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">6</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;老&quot;</span>+n+<span class=\"string\">&quot;原有的桔子数&quot;</span>+befornum);</span><br><span class=\"line\">            <span class=\"comment\">//分给下一个人的桔子数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> givenum = afternum/m;</span><br><span class=\"line\">            <span class=\"comment\">//下一个人的桔子数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> nextBeforenum = <span class=\"number\">420</span>*(m<span class=\"number\">-1</span>)/(m<span class=\"number\">-2</span>)-givenum;</span><br><span class=\"line\">            <span class=\"comment\">//下一人加上之前的桔子数的总数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> afterGetnum = nextBeforenum+givenum;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> answer(n+<span class=\"number\">1</span>,nextBeforenum,afterGetnum,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        questionfour question4 = new questionfour();</span><br><span class=\"line\">        question4.answer(<span class=\"number\">1</span>, <span class=\"number\">240</span>, <span class=\"number\">240</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>递归是一种将<strong>大问题分解为小问题</strong>、逐层求解再合并结果的强大方法。掌握递归不仅是解题利器，更能帮助你建立更抽象、更系统的问题解决能力。</p>\n","excerpt":"","more":"<h1 id=\"ACM-算法之递归\"><a href=\"#ACM-算法之递归\" class=\"headerlink\" title=\"ACM 算法之递归\"></a>ACM 算法之递归</h1><h2 id=\"什么是递归？\"><a href=\"#什么是递归？\" class=\"headerlink\" title=\"什么是递归？\"></a>什么是递归？</h2><blockquote>\n<p>递归（Recursion）是一种程序调用自身的编程技巧，常用于将复杂问题分解为规模更小的同类问题。<br>它是一种 <strong>“以小见大”</strong> 的思想，用有限的代码描述无限的过程。</p>\n</blockquote>\n<p>递归在程序设计语言中被广泛应用，尤其在算法题中非常常见。其核心在于：</p>\n<ul>\n<li><strong>边界条件</strong>：定义递归终止的情形；</li>\n<li><strong>递归调用</strong>：将问题逐步缩小并调用自身；</li>\n<li><strong>返回过程</strong>：逐层返回解，最终合并结果。</li>\n</ul>\n<p>举个例子：<strong>阶乘的递归定义</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fac(1) = 1</span><br><span class=\"line\">fac(n) = n * fac(n-1)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"递归三步走（以阶乘为例）\"><a href=\"#递归三步走（以阶乘为例）\" class=\"headerlink\" title=\"递归三步走（以阶乘为例）\"></a>递归三步走（以阶乘为例）</h2><h3 id=\"Step-1：边界条件（终止递归的出口）\"><a href=\"#Step-1：边界条件（终止递归的出口）\" class=\"headerlink\" title=\"Step 1：边界条件（终止递归的出口）\"></a>Step 1：边界条件（终止递归的出口）</h3><p>我们先考虑一个简单的问题：6! &#x3D;6 × 5 × 4 × 3 × 2 × 1。</p>\n<p>在编写阶乘函数时，我们可以有两种实现思路：</p>\n<ul>\n<li><p><strong>从 1 乘到 n</strong>（正序递归）</p>\n</li>\n<li><p><strong>从 n 乘到 1</strong>（逆序递归）</p>\n</li>\n</ul>\n<p>不论哪种方式，核心都在于<strong>设定边界条件</strong>，也就是：<strong>什么时候停止递归？</strong></p>\n<p>我们这里采用第二种方式 —— <strong>从 n 递减到 1</strong>：</p>\n<p>当 <code>n == 1</code> 时，就不再继续向下递归，而是直接返回 <code>1</code>，这就是我们设定的递归终止条件（边界）：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fac</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i==<span class=\"number\">1</span>):    <span class=\"comment\">#边界条件</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>这意味着，<strong>当问题被缩小到最简单的情况（n&#x3D;1）时，递归不再继续，而是开始回传答案。</strong></p>\n<h3 id=\"Step-2：递归调用（函数调用自身）\"><a href=\"#Step-2：递归调用（函数调用自身）\" class=\"headerlink\" title=\"Step 2：递归调用（函数调用自身）\"></a>Step 2：递归调用（函数调用自身）</h3><p>在确定了边界后，我们就可以让函数调用自身，把大问题逐步“压小”：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fac</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fac(i - <span class=\"number\">1</span>) * i</span><br></pre></td></tr></table></figure>\n\n<p>这时，函数每次都会将问题规模减小为 <code>fac(i-1)</code>，直到 <code>i == 1</code> 为止。</p>\n<h3 id=\"Step-3：返回过程（从最小问题逐层回传）\"><a href=\"#Step-3：返回过程（从最小问题逐层回传）\" class=\"headerlink\" title=\"Step 3：返回过程（从最小问题逐层回传）\"></a>Step 3：返回过程（从最小问题逐层回传）</h3><p>递归调用本质上是<strong>函数栈</strong>，每次压栈是“前进”，每次 return 是“回退”。</p>\n<p>举个例子：<code>fac(6)</code> 实际调用流程如下：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fac(6)</span><br><span class=\"line\">→ return fac(5) * 6</span><br><span class=\"line\">→ → return fac(4) * 5</span><br><span class=\"line\">→ → → return fac(3) * 4</span><br><span class=\"line\">→ → → → return fac(2) * 3</span><br><span class=\"line\">→ → → → → return fac(1) * 2</span><br><span class=\"line\">→ → → → → → return 1</span><br><span class=\"line\">最终返回值：1 * 2 * 3 * 4 * 5 * 6 = 720</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://s2.loli.net/2025/07/06/BuCyzem6ORcAEbL.jpg\" alt=\"recursion.jpg\"></p>\n<h2 id=\"构成递归的必要条件\"><a href=\"#构成递归的必要条件\" class=\"headerlink\" title=\"构成递归的必要条件\"></a>构成递归的必要条件</h2><ul>\n<li><p>1、子问题必须与原问题结构相同，且规模更小；</p>\n</li>\n<li><p>2、必须有终止条件，否则将无限调用；</p>\n</li>\n<li><p>3、问题最终需能归结为基本情形求解。</p>\n</li>\n</ul>\n<p>以经典的<strong>斐波那契数列</strong>为例：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Fib(0) = 1</span><br><span class=\"line\">Fib(1) = 1</span><br><span class=\"line\">Fib(n) = Fib(n-1) + Fib(n-2)  （n &gt; 1）</span><br></pre></td></tr></table></figure>\n\n<p>虽然写法简单，但由于重复计算多，效率低，因此在实际编程中经常结合<strong>记忆化搜索</strong>或<strong>动态规划</strong>来优化。</p>\n<h2 id=\"生活中的递归现象\"><a href=\"#生活中的递归现象\" class=\"headerlink\" title=\"生活中的递归现象\"></a>生活中的递归现象</h2><p>递归不仅仅是代码技巧，也出现在生活和艺术中，例如：</p>\n<ul>\n<li><p><strong>德罗斯特效应</strong>：一个图像中包含缩小版的自己，一层套一层；</p>\n</li>\n<li><p><strong>镜中蜡烛</strong>：两面镜子之间放置蜡烛，可以看到无限反射；</p>\n</li>\n<li><p><strong>搬箱子问题</strong>：你要搬 100 个箱子，先搬一个，再解决“搬 99 个箱子”的问题……</p>\n</li>\n</ul>\n<p>这类递归式的思维方式，正是递归定义的日常化体现。</p>\n<h2 id=\"实战演练\"><a href=\"#实战演练\" class=\"headerlink\" title=\"实战演练\"></a>实战演练</h2><h3 id=\"递归的经典应用：斐波那契数列\"><a href=\"#递归的经典应用：斐波那契数列\" class=\"headerlink\" title=\"递归的经典应用：斐波那契数列\"></a>递归的经典应用：斐波那契数列</h3><blockquote>\n<p>斐波那契数列（Fibonacci Sequence）是递归最经典的应用之一。<br>它的定义是：一个数等于前两个数之和。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fib</span>(<span class=\"params\">n</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>(<span class=\"string\">&quot;请输入一个正整数 n：&quot;</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;第 <span class=\"subst\">&#123;n&#125;</span> 个斐波那契数是：<span class=\"subst\">&#123;fib(n)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：这种方式虽然直观，但性能较差，时间复杂度是指数级（约为 O(2ⁿ)），不适合计算较大的 n。</p>\n</blockquote>\n<p>输出示例（输入 10）：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第 10 个斐波那契数是：55</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法题：卖鸭子\"><a href=\"#算法题：卖鸭子\" class=\"headerlink\" title=\"算法题：卖鸭子\"></a>算法题：卖鸭子</h4><p>一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子</p>\n<p>递归终止的条件是当达到第 7 个村庄时递归停止，设经过的村庄数为 n 则有剩余的鸭子为总数为每次剩余的鸭子数位 sum &#x3D; sum-(sum&#x2F;2+1)<br>算法构造：当 n&#x3D;7 时 sum &#x3D; 2;当 0&lt;n&lt;7 时 sum &#x3D;2*m+2;</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Questionone</span>&#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">answer</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> sum)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum = <span class=\"number\">2</span>*sum+<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n<span class=\"number\">-1</span>&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;第&quot;</span>&lt;&lt;n<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;个村庄&quot;</span>&lt;&lt;<span class=\"string\">&quot;卖出&quot;</span>&lt;&lt;<span class=\"number\">2</span>*sum+<span class=\"number\">2</span>-sum&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> answer(n,sum);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> SUM = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>  N =  <span class=\"number\">7</span>;</span><br><span class=\"line\">    Questionone question;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;总数：&quot;</span>&lt;&lt;question.answer(N,SUM)&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典算法题：角谷定理\"><a href=\"#经典算法题：角谷定理\" class=\"headerlink\" title=\"经典算法题：角谷定理\"></a>经典算法题：角谷定理</h3><p>题目：<br>输入一个自然数，若为偶数，则把它除以 2，若为奇数，则把它乘以 3 加 1。经过如此有限次运算后，总可以得到自然数值 1。求经过多少次可得到自然数 1。</p>\n<p>算法分析：<br>递归的终止条件是最后值为 1；设输入的值为 n 先进项判断，若 n &#x3D; 1 则输出 n;<br>若 n 不为 1；则对他进行偶数判断，若为偶数除 2，若为奇数则乘 3 加 1；然后在进行偶数判断，直到 n &#x3D; 1 为止；<br>算法构造<br>n&#x3D;1 时 输出 n；n!&#x3D;1 时 偶数判断 偶数 n &#x3D; n&#x2F;2;若是奇数 n &#x3D; 3*n+1</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">questiontwo</span>&#123;</span></span><br><span class=\"line\">    public:</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"title function_\">answer</span><span class=\"params\">(<span class=\"type\">int</span> sum)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((sum%<span class=\"number\">2</span>) == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    sum = <span class=\"number\">3</span>*sum+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> answer(sum);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    sum = sum/<span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> answer(sum);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> c ;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;请输入一个数&quot;</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;c;</span><br><span class=\"line\">    questiontwo question2;</span><br><span class=\"line\">    question2.answer(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典算法题：电话号码\"><a href=\"#经典算法题：电话号码\" class=\"headerlink\" title=\"经典算法题：电话号码\"></a>经典算法题：电话号码</h3><p>题目：<br>电话号码对应的字符组合：在电话或者手机上，一个数字对应着字母 ABC，7 对应着 PQRS。那么数字串 27 所对应的字符可能组合就有 3*4 种（如 AP,BR 等）。现在输入一个 3 到 11 位长的电话号码，请打印出这个电话号码对应的字符的所有可能组合和组合数。</p>\n<p>题目分析：<br>根据题意可知：2 对应的是 ABC 3 对应的是 DEF 4 对应的是 GHI 5 对应的 JKL 6 对应的是 MNO 7 对应的是 PQRS 8 对应的是 TUV 9 对应的是 WXYZ</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">questionthree</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * @param number      电话号码</span></span><br><span class=\"line\"><span class=\"comment\">    * @param answer    辅助数组</span></span><br><span class=\"line\"><span class=\"comment\">    * @param index  电话位数中对应的第几位循环</span></span><br><span class=\"line\"><span class=\"comment\">    * @param n  电话位数</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    public <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">Answer</span><span class=\"params\">(<span class=\"type\">int</span> []number, <span class=\"type\">int</span> []answer,<span class=\"type\">int</span></span></span><br><span class=\"line\"><span class=\"params\">    index,<span class=\"type\">int</span> n)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>[][] word =&#123;&#123;&#125;,&#123;&#125;,&#123;<span class=\"string\">&#x27;A&#x27;</span>,<span class=\"string\">&#x27;B&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;D&#x27;</span>,<span class=\"string\">&#x27;E&#x27;</span>,<span class=\"string\">&#x27;F&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;G&#x27;</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;I&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;J&#x27;</span>,<span class=\"string\">&#x27;K&#x27;</span>,<span class=\"string\">&#x27;L&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;M&#x27;</span>,<span class=\"string\">&#x27;N&#x27;</span>,<span class=\"string\">&#x27;O&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;P&#x27;</span>,<span class=\"string\">&#x27;Q&#x27;</span>,<span class=\"string\">&#x27;R&#x27;</span>,<span class=\"string\">&#x27;s&#x27;</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"string\">&#x27;T&#x27;</span>,<span class=\"string\">&#x27;U&#x27;</span>,<span class=\"string\">&#x27;V&#x27;</span>&#125;,&#123;<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;X&#x27;</span>,<span class=\"string\">&#x27;Y&#x27;</span>,<span class=\"string\">&#x27;Z&#x27;</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> []sum = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index == n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;n; i++)&#123;</span><br><span class=\"line\">                System.out.print(word[number[i]][answer[i]]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;;&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(answer[index] = <span class=\"number\">0</span>; answer[index] &lt; sum [number[index]]; answer[index]++)&#123;</span><br><span class=\"line\">            Answer(number,answer,index+<span class=\"number\">1</span>,n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] number = &#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] answer = new <span class=\"type\">int</span>[number.length];</span><br><span class=\"line\">        Answer(number, answer, <span class=\"number\">0</span>, number.length);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"经典算法题：柿子分配\"><a href=\"#经典算法题：柿子分配\" class=\"headerlink\" title=\"经典算法题：柿子分配\"></a>经典算法题：柿子分配</h3><p>题目：<br>日本著名数学游戏专家中村义作教授提出这样一个问题：父亲将 2520 个桔子分给六个儿子。分完 后父亲说：“老大将分给你的桔子的 1&#x2F;8 给老二；老二拿到后连同原先的桔子分 1&#x2F;7 给老三；老三拿到后连同原先的桔子分 1&#x2F;6 给老四；老四拿到后连同原先的桔子分 1&#x2F;5 给老五；老五拿到后连同原先的桔子分 1&#x2F;4 给老六；老六拿到后连同原先的桔子分 1&#x2F;3 给老大”。结果大家手中的桔子正好一 样多。问六兄弟原来手中各有多少桔子？</p>\n<p>题目分析：<br>解决此问题主要使用递归运算。由题目可以看出原来手中的加上得到的满足关系式：StartNum &#x3D; 420 * (n -2)&#x2F;(n - 1)  分给下一个人的橘子数：GiveNum &#x3D; AfterGetNum &#x2F; n;   下一个人的橘子数：nextStartNum &#x3D; 420*(n-1)&#x2F;(n-2) - GiveNum;   下一个人加上之前得到的橘子的总数：afterGetNum &#x3D; nextStartNum + GiveNum;   以此使用递归算法可以算出各个孩子原来手中的橘子数。</p>\n<p>源代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">questionfour</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * @param n  表示第几个儿子</span></span><br><span class=\"line\"><span class=\"comment\">    * @param befor  表示为分配之前就的桔子数</span></span><br><span class=\"line\"><span class=\"comment\">    * @param After    表示分配之后的桔子数</span></span><br><span class=\"line\"><span class=\"comment\">    * @param m        分配的比例</span></span><br><span class=\"line\"><span class=\"comment\">    * @return</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    public <span class=\"type\">int</span> <span class=\"title function_\">answer</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> befornum, <span class=\"type\">int</span> afternum,<span class=\"type\">int</span> m )</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">6</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;老&quot;</span>+n+<span class=\"string\">&quot;原有的桔子数&quot;</span>+befornum);</span><br><span class=\"line\">            <span class=\"comment\">//分给下一个人的桔子数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> givenum = afternum/m;</span><br><span class=\"line\">            <span class=\"comment\">//下一个人的桔子数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> nextBeforenum = <span class=\"number\">420</span>*(m<span class=\"number\">-1</span>)/(m<span class=\"number\">-2</span>)-givenum;</span><br><span class=\"line\">            <span class=\"comment\">//下一人加上之前的桔子数的总数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> afterGetnum = nextBeforenum+givenum;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> answer(n+<span class=\"number\">1</span>,nextBeforenum,afterGetnum,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        questionfour question4 = new questionfour();</span><br><span class=\"line\">        question4.answer(<span class=\"number\">1</span>, <span class=\"number\">240</span>, <span class=\"number\">240</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>递归是一种将<strong>大问题分解为小问题</strong>、逐层求解再合并结果的强大方法。掌握递归不仅是解题利器，更能帮助你建立更抽象、更系统的问题解决能力。</p>\n"},{"title":"桂林电子科技大学 ACM 暑假课 | 7 月 21 日 ACM 作业题解","date":"2020-07-15T01:57:14.000Z","_content":"\n# 桂林电子科技大学暑假课 ACM 作业题解合集\n\n本文整理了桂电暑假 ACM 训练营 7 月 21 日作业的 10 道典型题目及参考代码，并附带简明题解说明，供学习和复习使用。\n\n---\n\n## 1. A 简单数学题：判断数字各位是否全不相同\n\n**题目描述：**\n\n给定一个数字 `n`，判断它的每一位数字是否都不相同。\n\n**输入：**  \n一个数字 `n`，满足 `1 < n < 1000000`\n\n**输出：**  \n若各位数字均不相同，输出 `YES`，否则 `NO`。\n\n**参考代码（C）：**\n\n```c\n#include<stdio.h>\n#include<stdbool.h>\n\nint main() {\n    char A[10];\n    bool used[300] = {false};\n    scanf(\"%s\", A);\n    for (int i = 0; A[i] != '\\0'; i++) {\n        if (used[A[i]]) {\n            printf(\"NO\");\n            return 0;\n        }\n        used[A[i]] = true;\n    }\n    printf(\"YES\");\n    return 0;\n}\n```\n\n**题解**\n\n- 使用数组 `A[10]` 存放输入的数字字符，最多 10 位，足够。\n\n- 用布尔数组 `result` 标记每个字符是否出现过，出现重复即输出`NO`。\n\n- 也可以用计数变量统计每个数字出现次数，出现超过一次即输出 `NO`。\n\n## 2.B 二进制转换\n\n**题目描述**\n\n将给定数字 n 转换为二进制表示。\n\n**输入**\n一个数字 n，满足 1 < n < 10^5。\n\n**输出**\n输出数字 n 的二进制表示。\n\n**参考程序**\n\n```C\n#include <stdio.h>\n\nint main() {\n    int num[10001], i = 0, n;\n    scanf(\"%d\", &n);\n    while (n > 0) {\n        num[i++] = n % 2;\n        n /= 2;\n    }\n    while (i--)\n        printf(\"%d\", num[i]);\n    return 0;\n}\n\n```\n\n**题解**\n\n- 通过取余操作不断除以 2，将结果倒序存储，最后正序输出即可。\n\n## 3.C 经典字符串问题 — 判断回文串\n\n**题目描述**\n\n给定一个字符串，判断它是否为回文串（正反相同）。\n\n**输入**\n\n- 第一行一个数字 t，表示测试组数，0 < t < 100。\n\n- 接下来每组两行：\n\n  - 第一行为字符串长度 n (1 < n < 1000)\n\n  - 第二行为长度为 n 的字符串。\n\n**输出**\n\n每组数据输出 `YES`（回文）或 `NO`（非回文）。\n\n**参考程序**\n\n```C\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, t, i, isPalindrome;\n    char str[1001];\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d\", &n);\n        scanf(\"%s\", str);\n        isPalindrome = 1;\n        for (i = 0; i < n; i++) {\n            if (str[i] != str[n - i - 1]) {\n                isPalindrome = 0;\n                break;\n            }\n        }\n        printf(isPalindrome ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n```\n\n**题解**\n\n- 字符串回文判断，比较对应位置字符是否相等。\n- 也可用整形数反转法判断数字是否回文（参考代码略）。\n\n## 4.D 排序\n\n**题目描述**\n\n给定长度为 n 的序列，对其从小到大排序后输出。\n\n**输入**\n\n- 第一行为 n，1 < n < 1000\n\n- 第二行 n 个整数。\n\n**输出**\n排序后的序列，空格分隔。\n\n样例\n输入：\n\n```text\n10\n2 5 7 8 10 1 6 11 20 35\n```\n\n输出：\n\n```text\n1 2 5 6 7 8 10 11 20 35\n```\n\n**参考程序**\n\n```C\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.begin(), a.end());\n    for (int i = 0; i < n; i++) cout << a[i] << \" \";\n    return 0;\n}\n```\n\n**题解**\n\n- C++的 sort 函数使用方便。\n- 若需要从大到小排序，可以传入自定义比较函数。\n\n## 5.E 改作文\n\n**题目描述**\n\nLZH 是个超差劲的学生呢。\nLLF 每次批改他的英语作业都会很生气\nLLF 批改作文是这样计算得分的 ：\n文章里共有 n 个字母，第 i（i<=n）个字母可能大写得一分（小写 0 分），也可能小写得一分（大写 0 分） 毕竟 LLF 是经常喜怒无常的呢，看心情给分。\n同时 lzh 又是个 unlucky boy 英语作文每次都必得零分（运气很差呢，每次都恰好得零分）\n现在你掌握了时间回溯大法，可以穿越时空，回到过去，因为 LZH 跟你进行了 PY 交易，你要帮他在 LLF 批改作文时得满分，所以你要趁机修改他的作文\n现在给出 lzh 的作文\n要求帮他修改到满分\n\n**输入**\n\n- 第一行有一个数 n 代表文章长度 (1<n<1000)\n\n- 第二行 有 n 个字母 代表 LZH 的作文\n\n**输出**\n输出此时可以让 LLF 给满分的作文\n\n**样例输入**\n\n```text\n 10\n adsadaAStY\n```\n\n**样例输出**\n\n```text\nADSADAasTy\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\nchar str[1001];\nint main(){\nint n,i;\nscanf(\"%d\",&n);\nscanf(\"%s\",&str);\nfor(i=0;i<n;i++){\nif(str[i]>='a'&&str[i]<='z')\nstr[i]=str[i]+'A'-'a';\nelse if(str[i]>='A'&&str[i]<='Z')\nstr[i]=str[i]+'a'-'A';}\nputs(str);\nreturn 0;\n}\n```\n\n题解：一定要注意细节，这道题就这么多\n\n## F: 抽签 game\n\n**题目描述**\n\n由于 LZH 在国庆之前偷偷把作业给 AK 掉了，于是 LLF 提议玩一个小游戏，将写有数字的 N 个纸片放入盒子 LZH 每次可以从盒子中抽取一个纸片，并将其放回盒子中，LZH 一共可以抽取四次，LLF 给出一个数字 M，如果 LZH 四次抽到的数字之和等于 M，那么 LZH 就会平安无事，否则 LLF 会给他最喜爱的大嘴巴子。但是 LZH 玩了几次抽签游戏，每次都获得了他最喜爱的大嘴巴子，他怀疑 LLF 在搞他，于是他恼羞成怒，怒把盒子打开看看里面的到底能不能抽四次的数字之和等于 M，\n现在给你一个盒子 要求你帮 LZH 检查一下盒子里面的卡片是否真的可以满足上述条件\n\n**输入**\n\n- 第一行有一个数 n 代表卡片数量 1<n<50\n\n- 第二行有一个数 M，M 的意义如题 1<m<10000000\n\n- 第三行有 n 个数，代表 n 张卡片上面所写的数值 1<每个数字<10000000\n\n**输出**\n\n- 如果抽四次可以满足上述条件 输出 YES\n\n- 否则输出 NO\n\n**样例输入**\n\n```text\n5\n10\n1 2 3 4 5\n```\n\n**样例输出**\n\n```text\nYES\n```\n\n**参考程序**\n\n```C\n#include <stdio.h>\nint main(){\n    int str[50],i,j,k,l,n,m;\n    scanf(\"%d\",&n);\n    scanf(\"%d\",&m);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&str[i]);\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            for(k=0;k<n;k++){\n                for(l=0;l<n;l++){\n                if(str[i]+str[j]+str[k]+str[l]==m){\n                    printf(\"YES\");\n                    return 0;\n                }\n                }\n            }\n        }\n    }\n    printf(\"NO\");\n    return 0;\n}\n```\n\n题解：就是穷举嘛，一个个试\n\n## G: help 庞学姐\n\n**题目描述：**\n\n庞学姐和最帅的郑学长在玩密室逃脱，经历了千辛万苦，他们终于走到了最后一关，\n最后一关是一个 n*m 的迷宫，里面有许多障碍物，这时上帝给了他们一张地图，上面给出了障碍物和终点分布，因为郑学长身手比较敏捷，所以可以无视障碍物，直接到达终点，\n但是庞学姐只是一个肥宅，他无法穿越障碍物，只能一步一步走到终点\n并且他只会往 上 下 左 右 四个方向走\n“ * “代表此处可通 “ ? “代表此处为障碍物\n现在给你迷宫的地图，请帮助庞学姐找到最短到终点的路。\n起点坐标为（1，1） 终点坐标为（n,m)迷宫：\n\n```text\n****?\n*??*?\n**?*?\n??**?\n*****\n```\n\n**输入**\n\n- 第一行为两个数 n,m 意义如上 1<n,m<50\n\n- 下面 n 行 每行有 m 个字符 “ \\* “代表此处可通 “ ? “代表此处为障碍物\n\n- 题目保证 起点和终点为 “ \\* “\n\n**输出**\n\n- 输出使庞学姐走出迷宫的最少步数\n\n- 题目保证有解\n\n**样例输入**\n\n```text\n5 5\n****?\n*??*?\n**?*?\n??**?\n*****\n```\n\n**样例输出**\n\n```text\n8\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\nint n,m;\nchar mp[51][51];\nint vis[51][51];\nint dx[]={-1,1,0,0},dy[]={0,0,1,-1};\nint ans=0,step=0,min=999999;\nvoid dfs(int x,int y,int step){\n    if(x<0||x>=n||y<0||y>m) return ;\n    if(x==n-1&&y==m-1){ans=1;\n    if(step<min) min=step;\n    return ;}\n    for(int i=0;i<4;i++){\n        int nowx=x+dx[i];\n        int nowy=y+dy[i];\n        if(mp[nowx][nowy]=='*'&&vis[nowx][nowy]==0){\n            vis[nowx][nowy]=1;\n            dfs(nowx,nowy,step+1);\n            vis[nowx][nowy]=0;\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)\n    scanf(\"%s\",mp[i]);\n    dfs(0,0,0);\n    printf(\"%d\",min);\n    return 0;\n}\n```\n\n题解：涉及搜索请移步搜索\n\n## H: 一根绳上的蚂蚁\n\n**题目描述：**\n\nn 只蚂蚁以每秒 1cm 的速度在长为 L cm 的绳子上爬行，当蚂蚁爬到绳子端点时就会自动掉落，由于绳子太细，两只蚂蚁相遇时，他们不能交错通过，只能各自反向爬回去。\n对于每只蚂蚁，我们知道它距离绳左端的距离 Xi，和它当前的头朝向，请计算所有蚂蚁经过复杂的爬行后，全部落下绳子的时刻。\n\n![](https://img.alicdn.com/imgextra/i2/2/O1CN01qrix2e1kCpWtKF3ac_!!2-rate.png_400x400.jpg)\n\n**输入**\n\n- 第一行为一个整数 L 代表绳子长度 （1<L<=10^6)\n\n- 第二行一个整数 n 代表蚂蚁个数 (1<n<=10^6)\n\n- 以下 n 行 每行有 Xi 和一个字母（R 或 L） Xi 代表蚂蚁距离左端的距离 字母代表当前的方向 （R 代表头朝右，L 代表头朝左）\n\n**输出**\n\n输出所有蚂蚁都掉落时的时刻\n\n**样例输入**\n\n```text\n10\n3\n2 R\n6 L\n7 L\n```\n\n**样例输出**\n\n```text\n8\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\nint main(){\n    int t,l,y,max=0,sum;\n    char x;\n    scanf(\"%d\",&l);\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d %c\",&y,&x);\n        if(x=='R')\n        sum=l-y;\n        else\n        sum=y;\n        if(sum>max)\n        max=sum;\n    }\n    printf(\"%d\",max);\n    return 0;\n}\n```\n\n题解：蚂蚁相撞从计算机的视角来看待这个问题就当成一个他们擦肩而过对最终的结果毫无影响，反正我们考虑的是最晚掉下去的蚂蚁而不在乎是那只蚂蚁。最后掉下去，所以很显然的，计算那只蚂蚁离两端最远就行了。\n\n## I: 小学数学题\n\n**题目描述：**\n\n求这个数 答案可能很大 因此输出这个数对 1e9+7 取余； （10^9+7）\n\n1<N<10^5\n\n**输入**\n\n第一行一个 t 代表测试组数\n下面 t 行 每行有一个数 N 意义如题\n\n**输出**\n\n输出有 t 行\n每行输出一个答案\n\n**样例输入**\n\n```text\n2\n2\n5\n```\n\n**样例输出**\n\n```text\n11\n120\n```\n\n**提示**\n\n- 取余的加法运算律（a+b）%m=（a%m+b%m）%m\n\n- 取余的乘法运算律 (a*b) % m = 【(a%m) * (b%m)】 % m\n\n- 计算机每秒进行 10^7 次运算\n\n- int 类型可以存的最大整数为 2^32-1;\n\n- long long 类型可以存的最大整数为 2^64 -1;\n\n**参考程序**\n\n```C\n#include<cstdio>\nusing namespace std;\nlong long now,ans,p=1e9+7;\nint t,n;\nint main(){\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d\",&n);\n        ans=0;now=1;\n        for(int i=0;i<=n;i++){\n            ans+=now*(n+1-i)%p;\n            ans%=p;\n            now=(now*2)%p;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n题解：根据提示编写程序。\n\n## J: 超简单的 A+B\n\n**题目描述：**\n\n求两个不超过 200 位的非负整数的和。\n\n**输入**\n\n有两行，每行是一个不超过 200 位的非负整数，可能有多余的前导 0。\n\n**输出**\n\n一行，即相加后的结果。结果里不能有多余的前导 0，即如果结果是 342，那么就不能输出为 0342。\n\n**样例输入**\n\n```text\n22222222222222222222\n33333333333333333333\n```\n\n**样例输出**\n\n```text\n55555555555555555555\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\n#include<string.h>\nchar s[10100],ss[10100];\nint a[10100],b[10100];\nint len;\n\nvoid jia()     //自定义函数\"jia\"(名字low了一点（好像不是一点，但容易理解不是吗）)\n{\n    int l1 = strlen(s);     //\"strlen\"是一个计算字符串长度的函数\n    int l2 = strlen(ss);    //将输入的两个字符串的长度赋值给l1,l2\n    if (l1 > l2)\n        len = l1;      //将len赋值为l1,l2中大的那个\n    else\n        len = l2;\n//      for (int i = 0 ; i <= len ; i++)  //清零（这里for循环和下面三句memset都为将字符串清零 ）\n//          a[i] = b[i] = c[i] = 0;\n    memset(a,0,sizeof(a));    //清零too(只能清零，不能干别的)\n    memset(b,0,sizeof(b));    //这是清零函数（字符串）\n                                        //两个for循环是将输入的两个字符串倒过来\n    for (int i = l1 - 1 ; i >= 0 ; i--)    //再将字符串里的字符转换为数字赋值给a,b整型数组\n        a[l1 - i - 1] = s[i] - '0';        //但为什么大数要用字符串存呢？\n    for (int i = l2 - 1 ; i >= 0 ; i--)    //因为大数太大，用任何整型变量都存不下\n        b[l2 - i - 1] = ss[i] - '0';       //为什么要把字符串倒过来赋值呢？\n                                    //因为大数与大数是一位一位运算的，还要涉及进位等\n    for (int i = 0 ; i < len ; i++)\n    {\n        a[i] = a[i] + b[i];    //运算\n        a[i+1]+= a[i] / 10;    //如有进位，在后一位上加上\n        a[i] = a[i] % 10;      //原来那一位减掉进位了的\n    }\n    if (a[len] != 0) len++;    //如果有进位就多显示一位（这句话很重要）\n\n    while (a[len - 1] == 0 && len>1) len--;      //我叫它while去零法\n\n    for (int i = len - 1 ;i >= 0 ;i--)  //输出结果\n        printf(\"%d\",a[i]);\n}\n\nint main()\n{\nscanf(\"%s%s\",s,ss);\njia();\n    return 0;\n}\n```\n\n题解：高精度计算基本内容请掌握。\n","source":"_posts/06-ACM-homework-7.21.md","raw":"---\ntitle: 桂林电子科技大学 ACM 暑假课 | 7 月 21 日 ACM 作业题解\ndate: 2020-07-15 09:57:14\ntags:\n  - 作业题解\n  - ACM 算法\ncategories:\n  - 算法入门\n---\n\n# 桂林电子科技大学暑假课 ACM 作业题解合集\n\n本文整理了桂电暑假 ACM 训练营 7 月 21 日作业的 10 道典型题目及参考代码，并附带简明题解说明，供学习和复习使用。\n\n---\n\n## 1. A 简单数学题：判断数字各位是否全不相同\n\n**题目描述：**\n\n给定一个数字 `n`，判断它的每一位数字是否都不相同。\n\n**输入：**  \n一个数字 `n`，满足 `1 < n < 1000000`\n\n**输出：**  \n若各位数字均不相同，输出 `YES`，否则 `NO`。\n\n**参考代码（C）：**\n\n```c\n#include<stdio.h>\n#include<stdbool.h>\n\nint main() {\n    char A[10];\n    bool used[300] = {false};\n    scanf(\"%s\", A);\n    for (int i = 0; A[i] != '\\0'; i++) {\n        if (used[A[i]]) {\n            printf(\"NO\");\n            return 0;\n        }\n        used[A[i]] = true;\n    }\n    printf(\"YES\");\n    return 0;\n}\n```\n\n**题解**\n\n- 使用数组 `A[10]` 存放输入的数字字符，最多 10 位，足够。\n\n- 用布尔数组 `result` 标记每个字符是否出现过，出现重复即输出`NO`。\n\n- 也可以用计数变量统计每个数字出现次数，出现超过一次即输出 `NO`。\n\n## 2.B 二进制转换\n\n**题目描述**\n\n将给定数字 n 转换为二进制表示。\n\n**输入**\n一个数字 n，满足 1 < n < 10^5。\n\n**输出**\n输出数字 n 的二进制表示。\n\n**参考程序**\n\n```C\n#include <stdio.h>\n\nint main() {\n    int num[10001], i = 0, n;\n    scanf(\"%d\", &n);\n    while (n > 0) {\n        num[i++] = n % 2;\n        n /= 2;\n    }\n    while (i--)\n        printf(\"%d\", num[i]);\n    return 0;\n}\n\n```\n\n**题解**\n\n- 通过取余操作不断除以 2，将结果倒序存储，最后正序输出即可。\n\n## 3.C 经典字符串问题 — 判断回文串\n\n**题目描述**\n\n给定一个字符串，判断它是否为回文串（正反相同）。\n\n**输入**\n\n- 第一行一个数字 t，表示测试组数，0 < t < 100。\n\n- 接下来每组两行：\n\n  - 第一行为字符串长度 n (1 < n < 1000)\n\n  - 第二行为长度为 n 的字符串。\n\n**输出**\n\n每组数据输出 `YES`（回文）或 `NO`（非回文）。\n\n**参考程序**\n\n```C\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int n, t, i, isPalindrome;\n    char str[1001];\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d\", &n);\n        scanf(\"%s\", str);\n        isPalindrome = 1;\n        for (i = 0; i < n; i++) {\n            if (str[i] != str[n - i - 1]) {\n                isPalindrome = 0;\n                break;\n            }\n        }\n        printf(isPalindrome ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n```\n\n**题解**\n\n- 字符串回文判断，比较对应位置字符是否相等。\n- 也可用整形数反转法判断数字是否回文（参考代码略）。\n\n## 4.D 排序\n\n**题目描述**\n\n给定长度为 n 的序列，对其从小到大排序后输出。\n\n**输入**\n\n- 第一行为 n，1 < n < 1000\n\n- 第二行 n 个整数。\n\n**输出**\n排序后的序列，空格分隔。\n\n样例\n输入：\n\n```text\n10\n2 5 7 8 10 1 6 11 20 35\n```\n\n输出：\n\n```text\n1 2 5 6 7 8 10 11 20 35\n```\n\n**参考程序**\n\n```C\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a.begin(), a.end());\n    for (int i = 0; i < n; i++) cout << a[i] << \" \";\n    return 0;\n}\n```\n\n**题解**\n\n- C++的 sort 函数使用方便。\n- 若需要从大到小排序，可以传入自定义比较函数。\n\n## 5.E 改作文\n\n**题目描述**\n\nLZH 是个超差劲的学生呢。\nLLF 每次批改他的英语作业都会很生气\nLLF 批改作文是这样计算得分的 ：\n文章里共有 n 个字母，第 i（i<=n）个字母可能大写得一分（小写 0 分），也可能小写得一分（大写 0 分） 毕竟 LLF 是经常喜怒无常的呢，看心情给分。\n同时 lzh 又是个 unlucky boy 英语作文每次都必得零分（运气很差呢，每次都恰好得零分）\n现在你掌握了时间回溯大法，可以穿越时空，回到过去，因为 LZH 跟你进行了 PY 交易，你要帮他在 LLF 批改作文时得满分，所以你要趁机修改他的作文\n现在给出 lzh 的作文\n要求帮他修改到满分\n\n**输入**\n\n- 第一行有一个数 n 代表文章长度 (1<n<1000)\n\n- 第二行 有 n 个字母 代表 LZH 的作文\n\n**输出**\n输出此时可以让 LLF 给满分的作文\n\n**样例输入**\n\n```text\n 10\n adsadaAStY\n```\n\n**样例输出**\n\n```text\nADSADAasTy\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\nchar str[1001];\nint main(){\nint n,i;\nscanf(\"%d\",&n);\nscanf(\"%s\",&str);\nfor(i=0;i<n;i++){\nif(str[i]>='a'&&str[i]<='z')\nstr[i]=str[i]+'A'-'a';\nelse if(str[i]>='A'&&str[i]<='Z')\nstr[i]=str[i]+'a'-'A';}\nputs(str);\nreturn 0;\n}\n```\n\n题解：一定要注意细节，这道题就这么多\n\n## F: 抽签 game\n\n**题目描述**\n\n由于 LZH 在国庆之前偷偷把作业给 AK 掉了，于是 LLF 提议玩一个小游戏，将写有数字的 N 个纸片放入盒子 LZH 每次可以从盒子中抽取一个纸片，并将其放回盒子中，LZH 一共可以抽取四次，LLF 给出一个数字 M，如果 LZH 四次抽到的数字之和等于 M，那么 LZH 就会平安无事，否则 LLF 会给他最喜爱的大嘴巴子。但是 LZH 玩了几次抽签游戏，每次都获得了他最喜爱的大嘴巴子，他怀疑 LLF 在搞他，于是他恼羞成怒，怒把盒子打开看看里面的到底能不能抽四次的数字之和等于 M，\n现在给你一个盒子 要求你帮 LZH 检查一下盒子里面的卡片是否真的可以满足上述条件\n\n**输入**\n\n- 第一行有一个数 n 代表卡片数量 1<n<50\n\n- 第二行有一个数 M，M 的意义如题 1<m<10000000\n\n- 第三行有 n 个数，代表 n 张卡片上面所写的数值 1<每个数字<10000000\n\n**输出**\n\n- 如果抽四次可以满足上述条件 输出 YES\n\n- 否则输出 NO\n\n**样例输入**\n\n```text\n5\n10\n1 2 3 4 5\n```\n\n**样例输出**\n\n```text\nYES\n```\n\n**参考程序**\n\n```C\n#include <stdio.h>\nint main(){\n    int str[50],i,j,k,l,n,m;\n    scanf(\"%d\",&n);\n    scanf(\"%d\",&m);\n    for(i=0;i<n;i++)\n    scanf(\"%d\",&str[i]);\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n            for(k=0;k<n;k++){\n                for(l=0;l<n;l++){\n                if(str[i]+str[j]+str[k]+str[l]==m){\n                    printf(\"YES\");\n                    return 0;\n                }\n                }\n            }\n        }\n    }\n    printf(\"NO\");\n    return 0;\n}\n```\n\n题解：就是穷举嘛，一个个试\n\n## G: help 庞学姐\n\n**题目描述：**\n\n庞学姐和最帅的郑学长在玩密室逃脱，经历了千辛万苦，他们终于走到了最后一关，\n最后一关是一个 n*m 的迷宫，里面有许多障碍物，这时上帝给了他们一张地图，上面给出了障碍物和终点分布，因为郑学长身手比较敏捷，所以可以无视障碍物，直接到达终点，\n但是庞学姐只是一个肥宅，他无法穿越障碍物，只能一步一步走到终点\n并且他只会往 上 下 左 右 四个方向走\n“ * “代表此处可通 “ ? “代表此处为障碍物\n现在给你迷宫的地图，请帮助庞学姐找到最短到终点的路。\n起点坐标为（1，1） 终点坐标为（n,m)迷宫：\n\n```text\n****?\n*??*?\n**?*?\n??**?\n*****\n```\n\n**输入**\n\n- 第一行为两个数 n,m 意义如上 1<n,m<50\n\n- 下面 n 行 每行有 m 个字符 “ \\* “代表此处可通 “ ? “代表此处为障碍物\n\n- 题目保证 起点和终点为 “ \\* “\n\n**输出**\n\n- 输出使庞学姐走出迷宫的最少步数\n\n- 题目保证有解\n\n**样例输入**\n\n```text\n5 5\n****?\n*??*?\n**?*?\n??**?\n*****\n```\n\n**样例输出**\n\n```text\n8\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\nint n,m;\nchar mp[51][51];\nint vis[51][51];\nint dx[]={-1,1,0,0},dy[]={0,0,1,-1};\nint ans=0,step=0,min=999999;\nvoid dfs(int x,int y,int step){\n    if(x<0||x>=n||y<0||y>m) return ;\n    if(x==n-1&&y==m-1){ans=1;\n    if(step<min) min=step;\n    return ;}\n    for(int i=0;i<4;i++){\n        int nowx=x+dx[i];\n        int nowy=y+dy[i];\n        if(mp[nowx][nowy]=='*'&&vis[nowx][nowy]==0){\n            vis[nowx][nowy]=1;\n            dfs(nowx,nowy,step+1);\n            vis[nowx][nowy]=0;\n        }\n    }\n}\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++)\n    scanf(\"%s\",mp[i]);\n    dfs(0,0,0);\n    printf(\"%d\",min);\n    return 0;\n}\n```\n\n题解：涉及搜索请移步搜索\n\n## H: 一根绳上的蚂蚁\n\n**题目描述：**\n\nn 只蚂蚁以每秒 1cm 的速度在长为 L cm 的绳子上爬行，当蚂蚁爬到绳子端点时就会自动掉落，由于绳子太细，两只蚂蚁相遇时，他们不能交错通过，只能各自反向爬回去。\n对于每只蚂蚁，我们知道它距离绳左端的距离 Xi，和它当前的头朝向，请计算所有蚂蚁经过复杂的爬行后，全部落下绳子的时刻。\n\n![](https://img.alicdn.com/imgextra/i2/2/O1CN01qrix2e1kCpWtKF3ac_!!2-rate.png_400x400.jpg)\n\n**输入**\n\n- 第一行为一个整数 L 代表绳子长度 （1<L<=10^6)\n\n- 第二行一个整数 n 代表蚂蚁个数 (1<n<=10^6)\n\n- 以下 n 行 每行有 Xi 和一个字母（R 或 L） Xi 代表蚂蚁距离左端的距离 字母代表当前的方向 （R 代表头朝右，L 代表头朝左）\n\n**输出**\n\n输出所有蚂蚁都掉落时的时刻\n\n**样例输入**\n\n```text\n10\n3\n2 R\n6 L\n7 L\n```\n\n**样例输出**\n\n```text\n8\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\nint main(){\n    int t,l,y,max=0,sum;\n    char x;\n    scanf(\"%d\",&l);\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d %c\",&y,&x);\n        if(x=='R')\n        sum=l-y;\n        else\n        sum=y;\n        if(sum>max)\n        max=sum;\n    }\n    printf(\"%d\",max);\n    return 0;\n}\n```\n\n题解：蚂蚁相撞从计算机的视角来看待这个问题就当成一个他们擦肩而过对最终的结果毫无影响，反正我们考虑的是最晚掉下去的蚂蚁而不在乎是那只蚂蚁。最后掉下去，所以很显然的，计算那只蚂蚁离两端最远就行了。\n\n## I: 小学数学题\n\n**题目描述：**\n\n求这个数 答案可能很大 因此输出这个数对 1e9+7 取余； （10^9+7）\n\n1<N<10^5\n\n**输入**\n\n第一行一个 t 代表测试组数\n下面 t 行 每行有一个数 N 意义如题\n\n**输出**\n\n输出有 t 行\n每行输出一个答案\n\n**样例输入**\n\n```text\n2\n2\n5\n```\n\n**样例输出**\n\n```text\n11\n120\n```\n\n**提示**\n\n- 取余的加法运算律（a+b）%m=（a%m+b%m）%m\n\n- 取余的乘法运算律 (a*b) % m = 【(a%m) * (b%m)】 % m\n\n- 计算机每秒进行 10^7 次运算\n\n- int 类型可以存的最大整数为 2^32-1;\n\n- long long 类型可以存的最大整数为 2^64 -1;\n\n**参考程序**\n\n```C\n#include<cstdio>\nusing namespace std;\nlong long now,ans,p=1e9+7;\nint t,n;\nint main(){\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d\",&n);\n        ans=0;now=1;\n        for(int i=0;i<=n;i++){\n            ans+=now*(n+1-i)%p;\n            ans%=p;\n            now=(now*2)%p;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```\n\n题解：根据提示编写程序。\n\n## J: 超简单的 A+B\n\n**题目描述：**\n\n求两个不超过 200 位的非负整数的和。\n\n**输入**\n\n有两行，每行是一个不超过 200 位的非负整数，可能有多余的前导 0。\n\n**输出**\n\n一行，即相加后的结果。结果里不能有多余的前导 0，即如果结果是 342，那么就不能输出为 0342。\n\n**样例输入**\n\n```text\n22222222222222222222\n33333333333333333333\n```\n\n**样例输出**\n\n```text\n55555555555555555555\n```\n\n**参考程序**\n\n```C\n#include<stdio.h>\n#include<string.h>\nchar s[10100],ss[10100];\nint a[10100],b[10100];\nint len;\n\nvoid jia()     //自定义函数\"jia\"(名字low了一点（好像不是一点，但容易理解不是吗）)\n{\n    int l1 = strlen(s);     //\"strlen\"是一个计算字符串长度的函数\n    int l2 = strlen(ss);    //将输入的两个字符串的长度赋值给l1,l2\n    if (l1 > l2)\n        len = l1;      //将len赋值为l1,l2中大的那个\n    else\n        len = l2;\n//      for (int i = 0 ; i <= len ; i++)  //清零（这里for循环和下面三句memset都为将字符串清零 ）\n//          a[i] = b[i] = c[i] = 0;\n    memset(a,0,sizeof(a));    //清零too(只能清零，不能干别的)\n    memset(b,0,sizeof(b));    //这是清零函数（字符串）\n                                        //两个for循环是将输入的两个字符串倒过来\n    for (int i = l1 - 1 ; i >= 0 ; i--)    //再将字符串里的字符转换为数字赋值给a,b整型数组\n        a[l1 - i - 1] = s[i] - '0';        //但为什么大数要用字符串存呢？\n    for (int i = l2 - 1 ; i >= 0 ; i--)    //因为大数太大，用任何整型变量都存不下\n        b[l2 - i - 1] = ss[i] - '0';       //为什么要把字符串倒过来赋值呢？\n                                    //因为大数与大数是一位一位运算的，还要涉及进位等\n    for (int i = 0 ; i < len ; i++)\n    {\n        a[i] = a[i] + b[i];    //运算\n        a[i+1]+= a[i] / 10;    //如有进位，在后一位上加上\n        a[i] = a[i] % 10;      //原来那一位减掉进位了的\n    }\n    if (a[len] != 0) len++;    //如果有进位就多显示一位（这句话很重要）\n\n    while (a[len - 1] == 0 && len>1) len--;      //我叫它while去零法\n\n    for (int i = len - 1 ;i >= 0 ;i--)  //输出结果\n        printf(\"%d\",a[i]);\n}\n\nint main()\n{\nscanf(\"%s%s\",s,ss);\njia();\n    return 0;\n}\n```\n\n题解：高精度计算基本内容请掌握。\n","slug":"06-ACM-homework-7.21","published":1,"updated":"2025-07-09T00:42:33.964Z","comments":1,"layout":"post","photos":[],"_id":"cmcvbtktk000014nf75446rdb","content":"<h1 id=\"桂林电子科技大学暑假课-ACM-作业题解合集\"><a href=\"#桂林电子科技大学暑假课-ACM-作业题解合集\" class=\"headerlink\" title=\"桂林电子科技大学暑假课 ACM 作业题解合集\"></a>桂林电子科技大学暑假课 ACM 作业题解合集</h1><p>本文整理了桂电暑假 ACM 训练营 7 月 21 日作业的 10 道典型题目及参考代码，并附带简明题解说明，供学习和复习使用。</p>\n<hr>\n<h2 id=\"1-A-简单数学题：判断数字各位是否全不相同\"><a href=\"#1-A-简单数学题：判断数字各位是否全不相同\" class=\"headerlink\" title=\"1. A 简单数学题：判断数字各位是否全不相同\"></a>1. A 简单数学题：判断数字各位是否全不相同</h2><p><strong>题目描述：</strong></p>\n<p>给定一个数字 <code>n</code>，判断它的每一位数字是否都不相同。</p>\n<p><strong>输入：</strong><br>一个数字 <code>n</code>，满足 <code>1 &lt; n &lt; 1000000</code></p>\n<p><strong>输出：</strong><br>若各位数字均不相同，输出 <code>YES</code>，否则 <code>NO</code>。</p>\n<p><strong>参考代码（C）：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> A[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">bool</span> used[<span class=\"number\">300</span>] = &#123;<span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, A);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; A[i] != <span class=\"string\">&#x27;\\0&#x27;</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (used[A[i]]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        used[A[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li><p>使用数组 <code>A[10]</code> 存放输入的数字字符，最多 10 位，足够。</p>\n</li>\n<li><p>用布尔数组 <code>result</code> 标记每个字符是否出现过，出现重复即输出<code>NO</code>。</p>\n</li>\n<li><p>也可以用计数变量统计每个数字出现次数，出现超过一次即输出 <code>NO</code>。</p>\n</li>\n</ul>\n<h2 id=\"2-B-二进制转换\"><a href=\"#2-B-二进制转换\" class=\"headerlink\" title=\"2.B 二进制转换\"></a>2.B 二进制转换</h2><p><strong>题目描述</strong></p>\n<p>将给定数字 n 转换为二进制表示。</p>\n<p><strong>输入</strong><br>一个数字 n，满足 1 &lt; n &lt; 10^5。</p>\n<p><strong>输出</strong><br>输出数字 n 的二进制表示。</p>\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num[<span class=\"number\">10001</span>], i = <span class=\"number\">0</span>, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        num[i++] = n % <span class=\"number\">2</span>;</span><br><span class=\"line\">        n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, num[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li>通过取余操作不断除以 2，将结果倒序存储，最后正序输出即可。</li>\n</ul>\n<h2 id=\"3-C-经典字符串问题-—-判断回文串\"><a href=\"#3-C-经典字符串问题-—-判断回文串\" class=\"headerlink\" title=\"3.C 经典字符串问题 — 判断回文串\"></a>3.C 经典字符串问题 — 判断回文串</h2><p><strong>题目描述</strong></p>\n<p>给定一个字符串，判断它是否为回文串（正反相同）。</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行一个数字 t，表示测试组数，0 &lt; t &lt; 100。</p>\n</li>\n<li><p>接下来每组两行：</p>\n<ul>\n<li><p>第一行为字符串长度 n (1 &lt; n &lt; 1000)</p>\n</li>\n<li><p>第二行为长度为 n 的字符串。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<p>每组数据输出 <code>YES</code>（回文）或 <code>NO</code>（非回文）。</p>\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, t, i, isPalindrome;</span><br><span class=\"line\">    <span class=\"type\">char</span> str[<span class=\"number\">1001</span>];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, str);</span><br><span class=\"line\">        isPalindrome = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[i] != str[n - i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                isPalindrome = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(isPalindrome ? <span class=\"string\">&quot;YES\\n&quot;</span> : <span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li>字符串回文判断，比较对应位置字符是否相等。</li>\n<li>也可用整形数反转法判断数字是否回文（参考代码略）。</li>\n</ul>\n<h2 id=\"4-D-排序\"><a href=\"#4-D-排序\" class=\"headerlink\" title=\"4.D 排序\"></a>4.D 排序</h2><p><strong>题目描述</strong></p>\n<p>给定长度为 n 的序列，对其从小到大排序后输出。</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行为 n，1 &lt; n &lt; 1000</p>\n</li>\n<li><p>第二行 n 个整数。</p>\n</li>\n</ul>\n<p><strong>输出</strong><br>排序后的序列，空格分隔。</p>\n<p>样例<br>输入：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">2 5 7 8 10 1 6 11 20 35</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 5 6 7 8 10 11 20 35</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; <span class=\"title function_\">a</span><span class=\"params\">(n)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"built_in\">cin</span> &gt;&gt; a[i];</span><br><span class=\"line\">    sort(a.begin(), a.end());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"built_in\">cout</span> &lt;&lt; a[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li>C++的 sort 函数使用方便。</li>\n<li>若需要从大到小排序，可以传入自定义比较函数。</li>\n</ul>\n<h2 id=\"5-E-改作文\"><a href=\"#5-E-改作文\" class=\"headerlink\" title=\"5.E 改作文\"></a>5.E 改作文</h2><p><strong>题目描述</strong></p>\n<p>LZH 是个超差劲的学生呢。<br>LLF 每次批改他的英语作业都会很生气<br>LLF 批改作文是这样计算得分的 ：<br>文章里共有 n 个字母，第 i（i&lt;&#x3D;n）个字母可能大写得一分（小写 0 分），也可能小写得一分（大写 0 分） 毕竟 LLF 是经常喜怒无常的呢，看心情给分。<br>同时 lzh 又是个 unlucky boy 英语作文每次都必得零分（运气很差呢，每次都恰好得零分）<br>现在你掌握了时间回溯大法，可以穿越时空，回到过去，因为 LZH 跟你进行了 PY 交易，你要帮他在 LLF 批改作文时得满分，所以你要趁机修改他的作文<br>现在给出 lzh 的作文<br>要求帮他修改到满分</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行有一个数 n 代表文章长度 (1&lt;n&lt;1000)</p>\n</li>\n<li><p>第二行 有 n 个字母 代表 LZH 的作文</p>\n</li>\n</ul>\n<p><strong>输出</strong><br>输出此时可以让 LLF 给满分的作文</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">adsadaAStY</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADSADAasTy</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">1001</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> n,i;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,&amp;str);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(str[i]&gt;=<span class=\"string\">&#x27;a&#x27;</span>&amp;&amp;str[i]&lt;=<span class=\"string\">&#x27;z&#x27;</span>)</span><br><span class=\"line\">str[i]=str[i]+<span class=\"string\">&#x27;A&#x27;</span>-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str[i]&gt;=<span class=\"string\">&#x27;A&#x27;</span>&amp;&amp;str[i]&lt;=<span class=\"string\">&#x27;Z&#x27;</span>)</span><br><span class=\"line\">str[i]=str[i]+<span class=\"string\">&#x27;a&#x27;</span>-<span class=\"string\">&#x27;A&#x27;</span>;&#125;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(str);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：一定要注意细节，这道题就这么多</p>\n<h2 id=\"F-抽签-game\"><a href=\"#F-抽签-game\" class=\"headerlink\" title=\"F: 抽签 game\"></a>F: 抽签 game</h2><p><strong>题目描述</strong></p>\n<p>由于 LZH 在国庆之前偷偷把作业给 AK 掉了，于是 LLF 提议玩一个小游戏，将写有数字的 N 个纸片放入盒子 LZH 每次可以从盒子中抽取一个纸片，并将其放回盒子中，LZH 一共可以抽取四次，LLF 给出一个数字 M，如果 LZH 四次抽到的数字之和等于 M，那么 LZH 就会平安无事，否则 LLF 会给他最喜爱的大嘴巴子。但是 LZH 玩了几次抽签游戏，每次都获得了他最喜爱的大嘴巴子，他怀疑 LLF 在搞他，于是他恼羞成怒，怒把盒子打开看看里面的到底能不能抽四次的数字之和等于 M，<br>现在给你一个盒子 要求你帮 LZH 检查一下盒子里面的卡片是否真的可以满足上述条件</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行有一个数 n 代表卡片数量 1&lt;n&lt;50</p>\n</li>\n<li><p>第二行有一个数 M，M 的意义如题 1&lt;m&lt;10000000</p>\n</li>\n<li><p>第三行有 n 个数，代表 n 张卡片上面所写的数值 1&lt;每个数字&lt;10000000</p>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<ul>\n<li><p>如果抽四次可以满足上述条件 输出 YES</p>\n</li>\n<li><p>否则输出 NO</p>\n</li>\n</ul>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">10</span><br><span class=\"line\">1 2 3 4 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> str[<span class=\"number\">50</span>],i,j,k,l,n,m;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;str[i]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(k=<span class=\"number\">0</span>;k&lt;n;k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(l=<span class=\"number\">0</span>;l&lt;n;l++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i]+str[j]+str[k]+str[l]==m)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：就是穷举嘛，一个个试</p>\n<h2 id=\"G-help-庞学姐\"><a href=\"#G-help-庞学姐\" class=\"headerlink\" title=\"G: help 庞学姐\"></a>G: help 庞学姐</h2><p><strong>题目描述：</strong></p>\n<p>庞学姐和最帅的郑学长在玩密室逃脱，经历了千辛万苦，他们终于走到了最后一关，<br>最后一关是一个 n*m 的迷宫，里面有许多障碍物，这时上帝给了他们一张地图，上面给出了障碍物和终点分布，因为郑学长身手比较敏捷，所以可以无视障碍物，直接到达终点，<br>但是庞学姐只是一个肥宅，他无法穿越障碍物，只能一步一步走到终点<br>并且他只会往 上 下 左 右 四个方向走<br>“ * “代表此处可通 “ ? “代表此处为障碍物<br>现在给你迷宫的地图，请帮助庞学姐找到最短到终点的路。<br>起点坐标为（1，1） 终点坐标为（n,m)迷宫：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">****?</span><br><span class=\"line\">*??*?</span><br><span class=\"line\">**?*?</span><br><span class=\"line\">??**?</span><br><span class=\"line\">*****</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行为两个数 n,m 意义如上 1&lt;n,m&lt;50</p>\n</li>\n<li><p>下面 n 行 每行有 m 个字符 “ * “代表此处可通 “ ? “代表此处为障碍物</p>\n</li>\n<li><p>题目保证 起点和终点为 “ * “</p>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<ul>\n<li><p>输出使庞学姐走出迷宫的最少步数</p>\n</li>\n<li><p>题目保证有解</p>\n</li>\n</ul>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 5</span><br><span class=\"line\">****?</span><br><span class=\"line\">*??*?</span><br><span class=\"line\">**?*?</span><br><span class=\"line\">??**?</span><br><span class=\"line\">*****</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">char</span> mp[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> ans=<span class=\"number\">0</span>,step=<span class=\"number\">0</span>,min=<span class=\"number\">999999</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> step)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>||x&gt;=n||y&lt;<span class=\"number\">0</span>||y&gt;m) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==n<span class=\"number\">-1</span>&amp;&amp;y==m<span class=\"number\">-1</span>)&#123;ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(step&lt;min) min=step;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nowx=x+dx[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> nowy=y+dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nowx][nowy]==<span class=\"string\">&#x27;*&#x27;</span>&amp;&amp;vis[nowx][nowy]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            vis[nowx][nowy]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(nowx,nowy,step+<span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[nowx][nowy]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,mp[i]);</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,min);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：涉及搜索请移步搜索</p>\n<h2 id=\"H-一根绳上的蚂蚁\"><a href=\"#H-一根绳上的蚂蚁\" class=\"headerlink\" title=\"H: 一根绳上的蚂蚁\"></a>H: 一根绳上的蚂蚁</h2><p><strong>题目描述：</strong></p>\n<p>n 只蚂蚁以每秒 1cm 的速度在长为 L cm 的绳子上爬行，当蚂蚁爬到绳子端点时就会自动掉落，由于绳子太细，两只蚂蚁相遇时，他们不能交错通过，只能各自反向爬回去。<br>对于每只蚂蚁，我们知道它距离绳左端的距离 Xi，和它当前的头朝向，请计算所有蚂蚁经过复杂的爬行后，全部落下绳子的时刻。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i2/2/O1CN01qrix2e1kCpWtKF3ac_!!2-rate.png_400x400.jpg\" class=\"lazyload\" data-srcset=\"https://img.alicdn.com/imgextra/i2/2/O1CN01qrix2e1kCpWtKF3ac_!!2-rate.png_400x400.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行为一个整数 L 代表绳子长度 （1&lt;L&lt;&#x3D;10^6)</p>\n</li>\n<li><p>第二行一个整数 n 代表蚂蚁个数 (1&lt;n&lt;&#x3D;10^6)</p>\n</li>\n<li><p>以下 n 行 每行有 Xi 和一个字母（R 或 L） Xi 代表蚂蚁距离左端的距离 字母代表当前的方向 （R 代表头朝右，L 代表头朝左）</p>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<p>输出所有蚂蚁都掉落时的时刻</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">3</span><br><span class=\"line\">2 R</span><br><span class=\"line\">6 L</span><br><span class=\"line\">7 L</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t,l,y,max=<span class=\"number\">0</span>,sum;</span><br><span class=\"line\">    <span class=\"type\">char</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;l);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %c&quot;</span>,&amp;y,&amp;x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"string\">&#x27;R&#x27;</span>)</span><br><span class=\"line\">        sum=l-y;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        sum=y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum&gt;max)</span><br><span class=\"line\">        max=sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,max);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：蚂蚁相撞从计算机的视角来看待这个问题就当成一个他们擦肩而过对最终的结果毫无影响，反正我们考虑的是最晚掉下去的蚂蚁而不在乎是那只蚂蚁。最后掉下去，所以很显然的，计算那只蚂蚁离两端最远就行了。</p>\n<h2 id=\"I-小学数学题\"><a href=\"#I-小学数学题\" class=\"headerlink\" title=\"I: 小学数学题\"></a>I: 小学数学题</h2><p><strong>题目描述：</strong></p>\n<p>求这个数 答案可能很大 因此输出这个数对 1e9+7 取余； （10^9+7）</p>\n<p>1&lt;N&lt;10^5</p>\n<p><strong>输入</strong></p>\n<p>第一行一个 t 代表测试组数<br>下面 t 行 每行有一个数 N 意义如题</p>\n<p><strong>输出</strong></p>\n<p>输出有 t 行<br>每行输出一个答案</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11</span><br><span class=\"line\">120</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示</strong></p>\n<ul>\n<li><p>取余的加法运算律（a+b）%m&#x3D;（a%m+b%m）%m</p>\n</li>\n<li><p>取余的乘法运算律 (a*b) % m &#x3D; 【(a%m) * (b%m)】 % m</p>\n</li>\n<li><p>计算机每秒进行 10^7 次运算</p>\n</li>\n<li><p>int 类型可以存的最大整数为 2^32-1;</p>\n</li>\n<li><p>long long 类型可以存的最大整数为 2^64 -1;</p>\n</li>\n</ul>\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> now,ans,p=<span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">        ans=<span class=\"number\">0</span>;now=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            ans+=now*(n+<span class=\"number\">1</span>-i)%p;</span><br><span class=\"line\">            ans%=p;</span><br><span class=\"line\">            now=(now*<span class=\"number\">2</span>)%p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：根据提示编写程序。</p>\n<h2 id=\"J-超简单的-A-B\"><a href=\"#J-超简单的-A-B\" class=\"headerlink\" title=\"J: 超简单的 A+B\"></a>J: 超简单的 A+B</h2><p><strong>题目描述：</strong></p>\n<p>求两个不超过 200 位的非负整数的和。</p>\n<p><strong>输入</strong></p>\n<p>有两行，每行是一个不超过 200 位的非负整数，可能有多余的前导 0。</p>\n<p><strong>输出</strong></p>\n<p>一行，即相加后的结果。结果里不能有多余的前导 0，即如果结果是 342，那么就不能输出为 0342。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22222222222222222222</span><br><span class=\"line\">33333333333333333333</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">55555555555555555555</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">10100</span>],ss[<span class=\"number\">10100</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">10100</span>],b[<span class=\"number\">10100</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">jia</span><span class=\"params\">()</span>     <span class=\"comment\">//自定义函数&quot;jia&quot;(名字low了一点（好像不是一点，但容易理解不是吗）)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l1 = <span class=\"built_in\">strlen</span>(s);     <span class=\"comment\">//&quot;strlen&quot;是一个计算字符串长度的函数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> l2 = <span class=\"built_in\">strlen</span>(ss);    <span class=\"comment\">//将输入的两个字符串的长度赋值给l1,l2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 &gt; l2)</span><br><span class=\"line\">        len = l1;      <span class=\"comment\">//将len赋值为l1,l2中大的那个</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        len = l2;</span><br><span class=\"line\"><span class=\"comment\">//      for (int i = 0 ; i &lt;= len ; i++)  //清零（这里for循环和下面三句memset都为将字符串清零 ）</span></span><br><span class=\"line\"><span class=\"comment\">//          a[i] = b[i] = c[i] = 0;</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(a));    <span class=\"comment\">//清零too(只能清零，不能干别的)</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(b,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(b));    <span class=\"comment\">//这是清零函数（字符串）</span></span><br><span class=\"line\">                                        <span class=\"comment\">//两个for循环是将输入的两个字符串倒过来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l1 - <span class=\"number\">1</span> ; i &gt;= <span class=\"number\">0</span> ; i--)    <span class=\"comment\">//再将字符串里的字符转换为数字赋值给a,b整型数组</span></span><br><span class=\"line\">        a[l1 - i - <span class=\"number\">1</span>] = s[i] - <span class=\"string\">&#x27;0&#x27;</span>;        <span class=\"comment\">//但为什么大数要用字符串存呢？</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l2 - <span class=\"number\">1</span> ; i &gt;= <span class=\"number\">0</span> ; i--)    <span class=\"comment\">//因为大数太大，用任何整型变量都存不下</span></span><br><span class=\"line\">        b[l2 - i - <span class=\"number\">1</span>] = ss[i] - <span class=\"string\">&#x27;0&#x27;</span>;       <span class=\"comment\">//为什么要把字符串倒过来赋值呢？</span></span><br><span class=\"line\">                                    <span class=\"comment\">//因为大数与大数是一位一位运算的，还要涉及进位等</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span> ; i &lt; len ; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a[i] = a[i] + b[i];    <span class=\"comment\">//运算</span></span><br><span class=\"line\">        a[i+<span class=\"number\">1</span>]+= a[i] / <span class=\"number\">10</span>;    <span class=\"comment\">//如有进位，在后一位上加上</span></span><br><span class=\"line\">        a[i] = a[i] % <span class=\"number\">10</span>;      <span class=\"comment\">//原来那一位减掉进位了的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[len] != <span class=\"number\">0</span>) len++;    <span class=\"comment\">//如果有进位就多显示一位（这句话很重要）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[len - <span class=\"number\">1</span>] == <span class=\"number\">0</span> &amp;&amp; len&gt;<span class=\"number\">1</span>) len--;      <span class=\"comment\">//我叫它while去零法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = len - <span class=\"number\">1</span> ;i &gt;= <span class=\"number\">0</span> ;i--)  <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%s&quot;</span>,s,ss);</span><br><span class=\"line\">jia();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：高精度计算基本内容请掌握。</p>\n","excerpt":"","more":"<h1 id=\"桂林电子科技大学暑假课-ACM-作业题解合集\"><a href=\"#桂林电子科技大学暑假课-ACM-作业题解合集\" class=\"headerlink\" title=\"桂林电子科技大学暑假课 ACM 作业题解合集\"></a>桂林电子科技大学暑假课 ACM 作业题解合集</h1><p>本文整理了桂电暑假 ACM 训练营 7 月 21 日作业的 10 道典型题目及参考代码，并附带简明题解说明，供学习和复习使用。</p>\n<hr>\n<h2 id=\"1-A-简单数学题：判断数字各位是否全不相同\"><a href=\"#1-A-简单数学题：判断数字各位是否全不相同\" class=\"headerlink\" title=\"1. A 简单数学题：判断数字各位是否全不相同\"></a>1. A 简单数学题：判断数字各位是否全不相同</h2><p><strong>题目描述：</strong></p>\n<p>给定一个数字 <code>n</code>，判断它的每一位数字是否都不相同。</p>\n<p><strong>输入：</strong><br>一个数字 <code>n</code>，满足 <code>1 &lt; n &lt; 1000000</code></p>\n<p><strong>输出：</strong><br>若各位数字均不相同，输出 <code>YES</code>，否则 <code>NO</code>。</p>\n<p><strong>参考代码（C）：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdbool.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> A[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">bool</span> used[<span class=\"number\">300</span>] = &#123;<span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, A);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; A[i] != <span class=\"string\">&#x27;\\0&#x27;</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (used[A[i]]) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        used[A[i]] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li><p>使用数组 <code>A[10]</code> 存放输入的数字字符，最多 10 位，足够。</p>\n</li>\n<li><p>用布尔数组 <code>result</code> 标记每个字符是否出现过，出现重复即输出<code>NO</code>。</p>\n</li>\n<li><p>也可以用计数变量统计每个数字出现次数，出现超过一次即输出 <code>NO</code>。</p>\n</li>\n</ul>\n<h2 id=\"2-B-二进制转换\"><a href=\"#2-B-二进制转换\" class=\"headerlink\" title=\"2.B 二进制转换\"></a>2.B 二进制转换</h2><p><strong>题目描述</strong></p>\n<p>将给定数字 n 转换为二进制表示。</p>\n<p><strong>输入</strong><br>一个数字 n，满足 1 &lt; n &lt; 10^5。</p>\n<p><strong>输出</strong><br>输出数字 n 的二进制表示。</p>\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num[<span class=\"number\">10001</span>], i = <span class=\"number\">0</span>, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        num[i++] = n % <span class=\"number\">2</span>;</span><br><span class=\"line\">        n /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i--)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, num[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li>通过取余操作不断除以 2，将结果倒序存储，最后正序输出即可。</li>\n</ul>\n<h2 id=\"3-C-经典字符串问题-—-判断回文串\"><a href=\"#3-C-经典字符串问题-—-判断回文串\" class=\"headerlink\" title=\"3.C 经典字符串问题 — 判断回文串\"></a>3.C 经典字符串问题 — 判断回文串</h2><p><strong>题目描述</strong></p>\n<p>给定一个字符串，判断它是否为回文串（正反相同）。</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行一个数字 t，表示测试组数，0 &lt; t &lt; 100。</p>\n</li>\n<li><p>接下来每组两行：</p>\n<ul>\n<li><p>第一行为字符串长度 n (1 &lt; n &lt; 1000)</p>\n</li>\n<li><p>第二行为长度为 n 的字符串。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<p>每组数据输出 <code>YES</code>（回文）或 <code>NO</code>（非回文）。</p>\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, t, i, isPalindrome;</span><br><span class=\"line\">    <span class=\"type\">char</span> str[<span class=\"number\">1001</span>];</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t--) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, str);</span><br><span class=\"line\">        isPalindrome = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[i] != str[n - i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                isPalindrome = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(isPalindrome ? <span class=\"string\">&quot;YES\\n&quot;</span> : <span class=\"string\">&quot;NO\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li>字符串回文判断，比较对应位置字符是否相等。</li>\n<li>也可用整形数反转法判断数字是否回文（参考代码略）。</li>\n</ul>\n<h2 id=\"4-D-排序\"><a href=\"#4-D-排序\" class=\"headerlink\" title=\"4.D 排序\"></a>4.D 排序</h2><p><strong>题目描述</strong></p>\n<p>给定长度为 n 的序列，对其从小到大排序后输出。</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行为 n，1 &lt; n &lt; 1000</p>\n</li>\n<li><p>第二行 n 个整数。</p>\n</li>\n</ul>\n<p><strong>输出</strong><br>排序后的序列，空格分隔。</p>\n<p>样例<br>输入：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">2 5 7 8 10 1 6 11 20 35</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 5 6 7 8 10 11 20 35</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; <span class=\"title function_\">a</span><span class=\"params\">(n)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"built_in\">cin</span> &gt;&gt; a[i];</span><br><span class=\"line\">    sort(a.begin(), a.end());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) <span class=\"built_in\">cout</span> &lt;&lt; a[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解</strong></p>\n<ul>\n<li>C++的 sort 函数使用方便。</li>\n<li>若需要从大到小排序，可以传入自定义比较函数。</li>\n</ul>\n<h2 id=\"5-E-改作文\"><a href=\"#5-E-改作文\" class=\"headerlink\" title=\"5.E 改作文\"></a>5.E 改作文</h2><p><strong>题目描述</strong></p>\n<p>LZH 是个超差劲的学生呢。<br>LLF 每次批改他的英语作业都会很生气<br>LLF 批改作文是这样计算得分的 ：<br>文章里共有 n 个字母，第 i（i&lt;&#x3D;n）个字母可能大写得一分（小写 0 分），也可能小写得一分（大写 0 分） 毕竟 LLF 是经常喜怒无常的呢，看心情给分。<br>同时 lzh 又是个 unlucky boy 英语作文每次都必得零分（运气很差呢，每次都恰好得零分）<br>现在你掌握了时间回溯大法，可以穿越时空，回到过去，因为 LZH 跟你进行了 PY 交易，你要帮他在 LLF 批改作文时得满分，所以你要趁机修改他的作文<br>现在给出 lzh 的作文<br>要求帮他修改到满分</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行有一个数 n 代表文章长度 (1&lt;n&lt;1000)</p>\n</li>\n<li><p>第二行 有 n 个字母 代表 LZH 的作文</p>\n</li>\n</ul>\n<p><strong>输出</strong><br>输出此时可以让 LLF 给满分的作文</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">adsadaAStY</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADSADAasTy</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">1001</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> n,i;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,&amp;str);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(str[i]&gt;=<span class=\"string\">&#x27;a&#x27;</span>&amp;&amp;str[i]&lt;=<span class=\"string\">&#x27;z&#x27;</span>)</span><br><span class=\"line\">str[i]=str[i]+<span class=\"string\">&#x27;A&#x27;</span>-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(str[i]&gt;=<span class=\"string\">&#x27;A&#x27;</span>&amp;&amp;str[i]&lt;=<span class=\"string\">&#x27;Z&#x27;</span>)</span><br><span class=\"line\">str[i]=str[i]+<span class=\"string\">&#x27;a&#x27;</span>-<span class=\"string\">&#x27;A&#x27;</span>;&#125;</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(str);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：一定要注意细节，这道题就这么多</p>\n<h2 id=\"F-抽签-game\"><a href=\"#F-抽签-game\" class=\"headerlink\" title=\"F: 抽签 game\"></a>F: 抽签 game</h2><p><strong>题目描述</strong></p>\n<p>由于 LZH 在国庆之前偷偷把作业给 AK 掉了，于是 LLF 提议玩一个小游戏，将写有数字的 N 个纸片放入盒子 LZH 每次可以从盒子中抽取一个纸片，并将其放回盒子中，LZH 一共可以抽取四次，LLF 给出一个数字 M，如果 LZH 四次抽到的数字之和等于 M，那么 LZH 就会平安无事，否则 LLF 会给他最喜爱的大嘴巴子。但是 LZH 玩了几次抽签游戏，每次都获得了他最喜爱的大嘴巴子，他怀疑 LLF 在搞他，于是他恼羞成怒，怒把盒子打开看看里面的到底能不能抽四次的数字之和等于 M，<br>现在给你一个盒子 要求你帮 LZH 检查一下盒子里面的卡片是否真的可以满足上述条件</p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行有一个数 n 代表卡片数量 1&lt;n&lt;50</p>\n</li>\n<li><p>第二行有一个数 M，M 的意义如题 1&lt;m&lt;10000000</p>\n</li>\n<li><p>第三行有 n 个数，代表 n 张卡片上面所写的数值 1&lt;每个数字&lt;10000000</p>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<ul>\n<li><p>如果抽四次可以满足上述条件 输出 YES</p>\n</li>\n<li><p>否则输出 NO</p>\n</li>\n</ul>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">10</span><br><span class=\"line\">1 2 3 4 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> str[<span class=\"number\">50</span>],i,j,k,l,n,m;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;str[i]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(k=<span class=\"number\">0</span>;k&lt;n;k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(l=<span class=\"number\">0</span>;l&lt;n;l++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i]+str[j]+str[k]+str[l]==m)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;YES&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;NO&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：就是穷举嘛，一个个试</p>\n<h2 id=\"G-help-庞学姐\"><a href=\"#G-help-庞学姐\" class=\"headerlink\" title=\"G: help 庞学姐\"></a>G: help 庞学姐</h2><p><strong>题目描述：</strong></p>\n<p>庞学姐和最帅的郑学长在玩密室逃脱，经历了千辛万苦，他们终于走到了最后一关，<br>最后一关是一个 n*m 的迷宫，里面有许多障碍物，这时上帝给了他们一张地图，上面给出了障碍物和终点分布，因为郑学长身手比较敏捷，所以可以无视障碍物，直接到达终点，<br>但是庞学姐只是一个肥宅，他无法穿越障碍物，只能一步一步走到终点<br>并且他只会往 上 下 左 右 四个方向走<br>“ * “代表此处可通 “ ? “代表此处为障碍物<br>现在给你迷宫的地图，请帮助庞学姐找到最短到终点的路。<br>起点坐标为（1，1） 终点坐标为（n,m)迷宫：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">****?</span><br><span class=\"line\">*??*?</span><br><span class=\"line\">**?*?</span><br><span class=\"line\">??**?</span><br><span class=\"line\">*****</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行为两个数 n,m 意义如上 1&lt;n,m&lt;50</p>\n</li>\n<li><p>下面 n 行 每行有 m 个字符 “ * “代表此处可通 “ ? “代表此处为障碍物</p>\n</li>\n<li><p>题目保证 起点和终点为 “ * “</p>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<ul>\n<li><p>输出使庞学姐走出迷宫的最少步数</p>\n</li>\n<li><p>题目保证有解</p>\n</li>\n</ul>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 5</span><br><span class=\"line\">****?</span><br><span class=\"line\">*??*?</span><br><span class=\"line\">**?*?</span><br><span class=\"line\">??**?</span><br><span class=\"line\">*****</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">char</span> mp[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> ans=<span class=\"number\">0</span>,step=<span class=\"number\">0</span>,min=<span class=\"number\">999999</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> step)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>||x&gt;=n||y&lt;<span class=\"number\">0</span>||y&gt;m) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==n<span class=\"number\">-1</span>&amp;&amp;y==m<span class=\"number\">-1</span>)&#123;ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(step&lt;min) min=step;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nowx=x+dx[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> nowy=y+dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nowx][nowy]==<span class=\"string\">&#x27;*&#x27;</span>&amp;&amp;vis[nowx][nowy]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            vis[nowx][nowy]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            dfs(nowx,nowy,step+<span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[nowx][nowy]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>,mp[i]);</span><br><span class=\"line\">    dfs(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,min);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：涉及搜索请移步搜索</p>\n<h2 id=\"H-一根绳上的蚂蚁\"><a href=\"#H-一根绳上的蚂蚁\" class=\"headerlink\" title=\"H: 一根绳上的蚂蚁\"></a>H: 一根绳上的蚂蚁</h2><p><strong>题目描述：</strong></p>\n<p>n 只蚂蚁以每秒 1cm 的速度在长为 L cm 的绳子上爬行，当蚂蚁爬到绳子端点时就会自动掉落，由于绳子太细，两只蚂蚁相遇时，他们不能交错通过，只能各自反向爬回去。<br>对于每只蚂蚁，我们知道它距离绳左端的距离 Xi，和它当前的头朝向，请计算所有蚂蚁经过复杂的爬行后，全部落下绳子的时刻。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i2/2/O1CN01qrix2e1kCpWtKF3ac_!!2-rate.png_400x400.jpg\"></p>\n<p><strong>输入</strong></p>\n<ul>\n<li><p>第一行为一个整数 L 代表绳子长度 （1&lt;L&lt;&#x3D;10^6)</p>\n</li>\n<li><p>第二行一个整数 n 代表蚂蚁个数 (1&lt;n&lt;&#x3D;10^6)</p>\n</li>\n<li><p>以下 n 行 每行有 Xi 和一个字母（R 或 L） Xi 代表蚂蚁距离左端的距离 字母代表当前的方向 （R 代表头朝右，L 代表头朝左）</p>\n</li>\n</ul>\n<p><strong>输出</strong></p>\n<p>输出所有蚂蚁都掉落时的时刻</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br><span class=\"line\">3</span><br><span class=\"line\">2 R</span><br><span class=\"line\">6 L</span><br><span class=\"line\">7 L</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t,l,y,max=<span class=\"number\">0</span>,sum;</span><br><span class=\"line\">    <span class=\"type\">char</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;l);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %c&quot;</span>,&amp;y,&amp;x);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"string\">&#x27;R&#x27;</span>)</span><br><span class=\"line\">        sum=l-y;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        sum=y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum&gt;max)</span><br><span class=\"line\">        max=sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,max);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：蚂蚁相撞从计算机的视角来看待这个问题就当成一个他们擦肩而过对最终的结果毫无影响，反正我们考虑的是最晚掉下去的蚂蚁而不在乎是那只蚂蚁。最后掉下去，所以很显然的，计算那只蚂蚁离两端最远就行了。</p>\n<h2 id=\"I-小学数学题\"><a href=\"#I-小学数学题\" class=\"headerlink\" title=\"I: 小学数学题\"></a>I: 小学数学题</h2><p><strong>题目描述：</strong></p>\n<p>求这个数 答案可能很大 因此输出这个数对 1e9+7 取余； （10^9+7）</p>\n<p>1&lt;N&lt;10^5</p>\n<p><strong>输入</strong></p>\n<p>第一行一个 t 代表测试组数<br>下面 t 行 每行有一个数 N 意义如题</p>\n<p><strong>输出</strong></p>\n<p>输出有 t 行<br>每行输出一个答案</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11</span><br><span class=\"line\">120</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示</strong></p>\n<ul>\n<li><p>取余的加法运算律（a+b）%m&#x3D;（a%m+b%m）%m</p>\n</li>\n<li><p>取余的乘法运算律 (a*b) % m &#x3D; 【(a%m) * (b%m)】 % m</p>\n</li>\n<li><p>计算机每秒进行 10^7 次运算</p>\n</li>\n<li><p>int 类型可以存的最大整数为 2^32-1;</p>\n</li>\n<li><p>long long 类型可以存的最大整数为 2^64 -1;</p>\n</li>\n</ul>\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> now,ans,p=<span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;t);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">        ans=<span class=\"number\">0</span>;now=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            ans+=now*(n+<span class=\"number\">1</span>-i)%p;</span><br><span class=\"line\">            ans%=p;</span><br><span class=\"line\">            now=(now*<span class=\"number\">2</span>)%p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld\\n&quot;</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：根据提示编写程序。</p>\n<h2 id=\"J-超简单的-A-B\"><a href=\"#J-超简单的-A-B\" class=\"headerlink\" title=\"J: 超简单的 A+B\"></a>J: 超简单的 A+B</h2><p><strong>题目描述：</strong></p>\n<p>求两个不超过 200 位的非负整数的和。</p>\n<p><strong>输入</strong></p>\n<p>有两行，每行是一个不超过 200 位的非负整数，可能有多余的前导 0。</p>\n<p><strong>输出</strong></p>\n<p>一行，即相加后的结果。结果里不能有多余的前导 0，即如果结果是 342，那么就不能输出为 0342。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">22222222222222222222</span><br><span class=\"line\">33333333333333333333</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">55555555555555555555</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">10100</span>],ss[<span class=\"number\">10100</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">10100</span>],b[<span class=\"number\">10100</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> len;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">jia</span><span class=\"params\">()</span>     <span class=\"comment\">//自定义函数&quot;jia&quot;(名字low了一点（好像不是一点，但容易理解不是吗）)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l1 = <span class=\"built_in\">strlen</span>(s);     <span class=\"comment\">//&quot;strlen&quot;是一个计算字符串长度的函数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> l2 = <span class=\"built_in\">strlen</span>(ss);    <span class=\"comment\">//将输入的两个字符串的长度赋值给l1,l2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l1 &gt; l2)</span><br><span class=\"line\">        len = l1;      <span class=\"comment\">//将len赋值为l1,l2中大的那个</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        len = l2;</span><br><span class=\"line\"><span class=\"comment\">//      for (int i = 0 ; i &lt;= len ; i++)  //清零（这里for循环和下面三句memset都为将字符串清零 ）</span></span><br><span class=\"line\"><span class=\"comment\">//          a[i] = b[i] = c[i] = 0;</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(a,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(a));    <span class=\"comment\">//清零too(只能清零，不能干别的)</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(b,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(b));    <span class=\"comment\">//这是清零函数（字符串）</span></span><br><span class=\"line\">                                        <span class=\"comment\">//两个for循环是将输入的两个字符串倒过来</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l1 - <span class=\"number\">1</span> ; i &gt;= <span class=\"number\">0</span> ; i--)    <span class=\"comment\">//再将字符串里的字符转换为数字赋值给a,b整型数组</span></span><br><span class=\"line\">        a[l1 - i - <span class=\"number\">1</span>] = s[i] - <span class=\"string\">&#x27;0&#x27;</span>;        <span class=\"comment\">//但为什么大数要用字符串存呢？</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l2 - <span class=\"number\">1</span> ; i &gt;= <span class=\"number\">0</span> ; i--)    <span class=\"comment\">//因为大数太大，用任何整型变量都存不下</span></span><br><span class=\"line\">        b[l2 - i - <span class=\"number\">1</span>] = ss[i] - <span class=\"string\">&#x27;0&#x27;</span>;       <span class=\"comment\">//为什么要把字符串倒过来赋值呢？</span></span><br><span class=\"line\">                                    <span class=\"comment\">//因为大数与大数是一位一位运算的，还要涉及进位等</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span> ; i &lt; len ; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        a[i] = a[i] + b[i];    <span class=\"comment\">//运算</span></span><br><span class=\"line\">        a[i+<span class=\"number\">1</span>]+= a[i] / <span class=\"number\">10</span>;    <span class=\"comment\">//如有进位，在后一位上加上</span></span><br><span class=\"line\">        a[i] = a[i] % <span class=\"number\">10</span>;      <span class=\"comment\">//原来那一位减掉进位了的</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a[len] != <span class=\"number\">0</span>) len++;    <span class=\"comment\">//如果有进位就多显示一位（这句话很重要）</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (a[len - <span class=\"number\">1</span>] == <span class=\"number\">0</span> &amp;&amp; len&gt;<span class=\"number\">1</span>) len--;      <span class=\"comment\">//我叫它while去零法</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = len - <span class=\"number\">1</span> ;i &gt;= <span class=\"number\">0</span> ;i--)  <span class=\"comment\">//输出结果</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,a[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%s&quot;</span>,s,ss);</span><br><span class=\"line\">jia();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：高精度计算基本内容请掌握。</p>\n"},{"title":"ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维","date":"2020-07-15T01:57:14.000Z","_content":"\n# ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维\n\n## 什么是贪心算法？\n\n> **贪心算法（Greedy Algorithm）** 是一种在每一步选择中都采取当前状态下最优（即最有利）选择的策略，期望通过局部最优最终达到全局最优。\n\n它的核心思想是：\n\n> **局部最优 ➜ 全局最优**\n\n但需要特别注意的是：**贪心策略并不总是适用于所有问题**，它只适合满足以下两个条件的问题：\n\n- ✅ **最优子结构**：问题的最优解包含其子问题的最优解；\n- ✅ **无后效性**：某一步的选择不会影响后续的选择过程。\n\n如果问题不满足这两个性质，使用贪心算法可能得不到正确解。\n\n---\n\n## 贪心算法的基本思路\n\n贪心算法虽然没有统一的模板，但通常遵循以下解决步骤：\n\n1. **建立数学模型**：用合理的数据结构和变量表达问题；\n2. **拆解为子问题**：将原问题划分为一系列阶段性子问题；\n3. **定义贪心策略**：找出每一步的“最优选择”规则；\n4. **按策略求解子问题**：每次都按照贪心策略做选择；\n5. **组合局部最优解**：最终汇总各步的选择，构成整体解。\n\n---\n\n## 贪心算法存在的问题\n\n- 不能保证最终求得的解一定是全局最优；\n- 不适用于所有需要求最大值或最小值的问题；\n- 只能求满足某些特定约束条件下的可行解。\n\n---\n\n## 贪心算法适用的问题\n\n贪心算法适用的前提是：**局部最优策略能够导致全局最优解**。  \n实际上，适用场景较少。判断一个问题是否适合贪心算法，通常可以通过实际数据测试和理论分析来确定。\n\n---\n\n## 贪心选择性质\n\n- **贪心选择性质**：问题的整体最优解可通过一系列局部最优选择构建。  \n  换言之，在做每一步选择时，只关注当前问题的最优选择，不考虑后续子问题的解。\n\n- 贪心算法通过迭代进行，每次选择都会简化问题规模，形成更小的子问题。\n\n- **最优子结构性质**：问题的最优解包含其子问题的最优解。  \n  这是贪心算法能正确求解问题的关键。\n\n---\n\n## 贪心算法的实现框架\n\n```pseudo\n从初始解开始：\nwhile (未达到目标) {\n    根据贪心策略选择当前最优的决策；\n    将该决策加入解中，简化问题规模；\n}\n最终，所有决策组合成问题的一个可行解。\n```\n\n## ✨ 示例：找零钱问题\n\n**目标**：用尽量少的硬币凑出某个金额  \n**硬币面额**：25 分、10 分、5 分、1 分  \n**贪心策略**：每次选择当前面值最大的硬币\n\n```python\ndef greedy_coin_change(amount):\n    coins = [25, 10, 5, 1]\n    res = []\n    for coin in coins:\n        while amount >= coin:\n            amount -= coin\n            res.append(coin)\n    return res\n\nprint(greedy_coin_change(63))  # 输出：[25, 25, 10, 1, 1, 1]\n\n```\n\n贪心策略：每次优先选面值最大的硬币。\n\n选择步骤：\n\n- 63 分 ——> 选择 2 个 25 分硬币，剩余 63 - 50 = 13 分\n\n- 13 分 ——> 选择 1 个 10 分硬币，剩余 13 - 10 = 3 分\n\n- 3 分 ——> 选择 0 个 5 分硬币（3 分不足 5 分），剩余 3 分\n\n- 3 分 ——> 选择 3 个 1 分硬币，剩余 3 - 3 = 0 分，完成！\n\n硬币组合：25 分 × 2 + 10 分 × 1 + 1 分 × 3 = 63 分\n\n```\n[63元]\n  |\n  v\n[用25元硬币×2] ---> [剩余13元]\n                          |\n                          v\n                  [用10元硬币×1] ---> [剩余3元]\n                                      |\n                                      v\n                            [用5元硬币? 不够]\n                                      |\n                                      v\n                            [用1元硬币×3] ---> [剩余0元，完成]\n```\n\n## 贪心算法经典算法题\n\n### 背包问题\n\n题目：\n有一个背包，容量为 M = 150，有 7 个物品，物品可分割成任意大小。  \n要求尽可能使装入背包的物品总价值最大，但不能超过总容量。\n\n| 物品 | A   | B   | C   | D   | E   | F   | G   |\n| ---- | --- | --- | --- | --- | --- | --- | --- |\n| 重量 | 35  | 30  | 60  | 50  | 40  | 10  | 25  |\n| 价值 | 10  | 40  | 30  | 50  | 35  | 40  | 30  |\n\n---\n\n目标与约束\n\n- **目标函数**：最大化总价值 \\( \\sum p_i \\)\n- **约束条件**：总重量不超过背包容量\n\n$$\n\\sum w_i \\leq M \\quad (M=150)\n$$\n\n---\n\n贪心策略分析\n\n针对该问题，考虑三种贪心策略：\n\n1. **每次选择价值最高的物品装入背包**\n2. **每次选择重量最小的物品装入背包**\n3. **每次选择单位重量价值最高的物品装入背包**\n\n---\n\n策略有效性探讨\n\n- **策略 1：选择价值最大物品**  \n  不一定最优。  \n  反例：\n\n  - 容量 \\( W=30 \\)\n  - 物品：A(28kg,30 价), B(12kg,20 价), C(12kg,20 价)  \n    该策略先选 A，背包剩余空间不足以选 B 和 C。但选 B 和 C 总价值 40，优于选 A 的 30。\n\n- **策略 2：选择重量最小物品**  \n  同样不一定最优，类似策略 1 的反例适用。\n\n- **策略 3：选择单位重量价值最高物品**  \n  是解决分数背包的经典策略，通常最优。  \n  但若单位价值相同，则需结合次级规则（如优先选重量小的物品）来避免歧义。\n\n---\n\n```python\n# 背包问题的贪心算法实现（分数背包）\n\n# 物品信息：重量和价值\nitems = [\n    {\"name\": \"A\", \"weight\": 35, \"value\": 10},\n    {\"name\": \"B\", \"weight\": 30, \"value\": 40},\n    {\"name\": \"C\", \"weight\": 60, \"value\": 30},\n    {\"name\": \"D\", \"weight\": 50, \"value\": 50},\n    {\"name\": \"E\", \"weight\": 40, \"value\": 35},\n    {\"name\": \"F\", \"weight\": 10, \"value\": 40},\n    {\"name\": \"G\", \"weight\": 25, \"value\": 30},\n]\n\ncapacity = 150  # 背包容量\n\n# 计算单位价值（价值/重量）\nfor item in items:\n    item[\"unit_value\"] = item[\"value\"] / item[\"weight\"]\n\n# 按单位价值从高到低排序\nitems.sort(key=lambda x: x[\"unit_value\"], reverse=True)\n\ntotal_value = 0  # 总价值\ntotal_weight = 0  # 总重量\nselected_items = []  # 记录装入背包的物品及其比例\n\nfor item in items:\n    if total_weight + item[\"weight\"] <= capacity:\n        # 能全部装入\n        total_weight += item[\"weight\"]\n        total_value += item[\"value\"]\n        selected_items.append((item[\"name\"], 1))  # 1表示全部装入\n    else:\n        # 装入剩余容量的部分\n        remain = capacity - total_weight\n        fraction = remain / item[\"weight\"]\n        total_weight += remain\n        total_value += item[\"value\"] * fraction\n        selected_items.append((item[\"name\"], fraction))\n        break  # 背包满了，停止装入\n\n# 输出结果\nprint(f\"背包总重量: {total_weight:.2f}\")\nprint(f\"背包总价值: {total_value:.2f}\")\nprint(\"装入背包的物品及比例:\")\nfor name, frac in selected_items:\n    if frac == 1:\n        print(f\"  {name} - 全部装入\")\n    else:\n        print(f\"  {name} - 装入 {frac:.2%}\")\n\n```\n\n### 分发糖果（Leetcode 题目）\n\n题目：\n\n老师想给站成一排的 N 个孩子分发糖果，分配规则如下：\n\n- 每个孩子至少分配到 1 个糖果；\n- 相邻的孩子中，评分更高的孩子必须获得更多的糖果。\n\n那么，老师至少需要准备多少颗糖果呢？\n\n---\n\n题目示例\n\n- 示例 1：\n\n  输入：`[1,0,2]`  \n  输出：`5`  \n  解释：可以分配糖果为 `[2,1,2]`。\n\n- 示例 2：\n\n  输入：`[1,2,2]`  \n  输出：`4`  \n  解释：可以分配糖果为 `[1,2,1]`，第三个孩子得到 1 颗糖果，满足条件。\n\n---\n\n规则分析\n\n设相邻的两个孩子为 A 和 B，A 在 B 左边，则：\n\n- **左规则**：当 `ratings[B] > ratings[A]` 时，B 得到的糖果数比 A 多；\n- **右规则**：当 `ratings[A] > ratings[B]` 时，A 得到的糖果数比 B 多。\n\n要满足所有相邻孩子都符合这两个规则，意味着每个孩子的糖果数既满足左规则又满足右规则。\n\n算法思路\n\n1. **初始化**：先给每个孩子 1 颗糖果。\n\n2. **从左到右遍历**，根据左规则更新糖果数：\n\n   - 若当前孩子评分比左边孩子高，则当前孩子的糖果数为左边孩子糖果数 + 1；\n   - 否则保持不变。\n\n3. **从右到左遍历**，根据右规则更新糖果数：\n\n   - 若当前孩子评分比右边孩子高，且糖果数不够，则更新为右边孩子糖果数 + 1。\n\n4. 最后，所有孩子糖果数取两次遍历后的最大值即满足左右规则，计算总和即为所需糖果总数。\n\n---\n\n代码实现（C++）\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        if (n == 0) return 0;\n\n        // 每个孩子至少分配1颗糖果\n        vector<int> candies(n, 1);\n\n        // 左规则遍历：从左到右\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n\n        // 右规则遍历：从右到左\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\n                candies[i] = candies[i + 1] + 1;\n            }\n        }\n\n        // 计算糖果总数\n        int total = 0;\n        for (int c : candies) {\n            total += c;\n        }\n\n        return total;\n    }\n};\n```\n","source":"_posts/05-ACM-algorithm-greedy.md","raw":"---\ntitle: ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维\ndate: 2020-07-15 09:57:14\ntags:\n  - 贪心算法\n  - ACM竞赛入门算法\ncategories:\n  - 算法入门\n---\n\n# ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维\n\n## 什么是贪心算法？\n\n> **贪心算法（Greedy Algorithm）** 是一种在每一步选择中都采取当前状态下最优（即最有利）选择的策略，期望通过局部最优最终达到全局最优。\n\n它的核心思想是：\n\n> **局部最优 ➜ 全局最优**\n\n但需要特别注意的是：**贪心策略并不总是适用于所有问题**，它只适合满足以下两个条件的问题：\n\n- ✅ **最优子结构**：问题的最优解包含其子问题的最优解；\n- ✅ **无后效性**：某一步的选择不会影响后续的选择过程。\n\n如果问题不满足这两个性质，使用贪心算法可能得不到正确解。\n\n---\n\n## 贪心算法的基本思路\n\n贪心算法虽然没有统一的模板，但通常遵循以下解决步骤：\n\n1. **建立数学模型**：用合理的数据结构和变量表达问题；\n2. **拆解为子问题**：将原问题划分为一系列阶段性子问题；\n3. **定义贪心策略**：找出每一步的“最优选择”规则；\n4. **按策略求解子问题**：每次都按照贪心策略做选择；\n5. **组合局部最优解**：最终汇总各步的选择，构成整体解。\n\n---\n\n## 贪心算法存在的问题\n\n- 不能保证最终求得的解一定是全局最优；\n- 不适用于所有需要求最大值或最小值的问题；\n- 只能求满足某些特定约束条件下的可行解。\n\n---\n\n## 贪心算法适用的问题\n\n贪心算法适用的前提是：**局部最优策略能够导致全局最优解**。  \n实际上，适用场景较少。判断一个问题是否适合贪心算法，通常可以通过实际数据测试和理论分析来确定。\n\n---\n\n## 贪心选择性质\n\n- **贪心选择性质**：问题的整体最优解可通过一系列局部最优选择构建。  \n  换言之，在做每一步选择时，只关注当前问题的最优选择，不考虑后续子问题的解。\n\n- 贪心算法通过迭代进行，每次选择都会简化问题规模，形成更小的子问题。\n\n- **最优子结构性质**：问题的最优解包含其子问题的最优解。  \n  这是贪心算法能正确求解问题的关键。\n\n---\n\n## 贪心算法的实现框架\n\n```pseudo\n从初始解开始：\nwhile (未达到目标) {\n    根据贪心策略选择当前最优的决策；\n    将该决策加入解中，简化问题规模；\n}\n最终，所有决策组合成问题的一个可行解。\n```\n\n## ✨ 示例：找零钱问题\n\n**目标**：用尽量少的硬币凑出某个金额  \n**硬币面额**：25 分、10 分、5 分、1 分  \n**贪心策略**：每次选择当前面值最大的硬币\n\n```python\ndef greedy_coin_change(amount):\n    coins = [25, 10, 5, 1]\n    res = []\n    for coin in coins:\n        while amount >= coin:\n            amount -= coin\n            res.append(coin)\n    return res\n\nprint(greedy_coin_change(63))  # 输出：[25, 25, 10, 1, 1, 1]\n\n```\n\n贪心策略：每次优先选面值最大的硬币。\n\n选择步骤：\n\n- 63 分 ——> 选择 2 个 25 分硬币，剩余 63 - 50 = 13 分\n\n- 13 分 ——> 选择 1 个 10 分硬币，剩余 13 - 10 = 3 分\n\n- 3 分 ——> 选择 0 个 5 分硬币（3 分不足 5 分），剩余 3 分\n\n- 3 分 ——> 选择 3 个 1 分硬币，剩余 3 - 3 = 0 分，完成！\n\n硬币组合：25 分 × 2 + 10 分 × 1 + 1 分 × 3 = 63 分\n\n```\n[63元]\n  |\n  v\n[用25元硬币×2] ---> [剩余13元]\n                          |\n                          v\n                  [用10元硬币×1] ---> [剩余3元]\n                                      |\n                                      v\n                            [用5元硬币? 不够]\n                                      |\n                                      v\n                            [用1元硬币×3] ---> [剩余0元，完成]\n```\n\n## 贪心算法经典算法题\n\n### 背包问题\n\n题目：\n有一个背包，容量为 M = 150，有 7 个物品，物品可分割成任意大小。  \n要求尽可能使装入背包的物品总价值最大，但不能超过总容量。\n\n| 物品 | A   | B   | C   | D   | E   | F   | G   |\n| ---- | --- | --- | --- | --- | --- | --- | --- |\n| 重量 | 35  | 30  | 60  | 50  | 40  | 10  | 25  |\n| 价值 | 10  | 40  | 30  | 50  | 35  | 40  | 30  |\n\n---\n\n目标与约束\n\n- **目标函数**：最大化总价值 \\( \\sum p_i \\)\n- **约束条件**：总重量不超过背包容量\n\n$$\n\\sum w_i \\leq M \\quad (M=150)\n$$\n\n---\n\n贪心策略分析\n\n针对该问题，考虑三种贪心策略：\n\n1. **每次选择价值最高的物品装入背包**\n2. **每次选择重量最小的物品装入背包**\n3. **每次选择单位重量价值最高的物品装入背包**\n\n---\n\n策略有效性探讨\n\n- **策略 1：选择价值最大物品**  \n  不一定最优。  \n  反例：\n\n  - 容量 \\( W=30 \\)\n  - 物品：A(28kg,30 价), B(12kg,20 价), C(12kg,20 价)  \n    该策略先选 A，背包剩余空间不足以选 B 和 C。但选 B 和 C 总价值 40，优于选 A 的 30。\n\n- **策略 2：选择重量最小物品**  \n  同样不一定最优，类似策略 1 的反例适用。\n\n- **策略 3：选择单位重量价值最高物品**  \n  是解决分数背包的经典策略，通常最优。  \n  但若单位价值相同，则需结合次级规则（如优先选重量小的物品）来避免歧义。\n\n---\n\n```python\n# 背包问题的贪心算法实现（分数背包）\n\n# 物品信息：重量和价值\nitems = [\n    {\"name\": \"A\", \"weight\": 35, \"value\": 10},\n    {\"name\": \"B\", \"weight\": 30, \"value\": 40},\n    {\"name\": \"C\", \"weight\": 60, \"value\": 30},\n    {\"name\": \"D\", \"weight\": 50, \"value\": 50},\n    {\"name\": \"E\", \"weight\": 40, \"value\": 35},\n    {\"name\": \"F\", \"weight\": 10, \"value\": 40},\n    {\"name\": \"G\", \"weight\": 25, \"value\": 30},\n]\n\ncapacity = 150  # 背包容量\n\n# 计算单位价值（价值/重量）\nfor item in items:\n    item[\"unit_value\"] = item[\"value\"] / item[\"weight\"]\n\n# 按单位价值从高到低排序\nitems.sort(key=lambda x: x[\"unit_value\"], reverse=True)\n\ntotal_value = 0  # 总价值\ntotal_weight = 0  # 总重量\nselected_items = []  # 记录装入背包的物品及其比例\n\nfor item in items:\n    if total_weight + item[\"weight\"] <= capacity:\n        # 能全部装入\n        total_weight += item[\"weight\"]\n        total_value += item[\"value\"]\n        selected_items.append((item[\"name\"], 1))  # 1表示全部装入\n    else:\n        # 装入剩余容量的部分\n        remain = capacity - total_weight\n        fraction = remain / item[\"weight\"]\n        total_weight += remain\n        total_value += item[\"value\"] * fraction\n        selected_items.append((item[\"name\"], fraction))\n        break  # 背包满了，停止装入\n\n# 输出结果\nprint(f\"背包总重量: {total_weight:.2f}\")\nprint(f\"背包总价值: {total_value:.2f}\")\nprint(\"装入背包的物品及比例:\")\nfor name, frac in selected_items:\n    if frac == 1:\n        print(f\"  {name} - 全部装入\")\n    else:\n        print(f\"  {name} - 装入 {frac:.2%}\")\n\n```\n\n### 分发糖果（Leetcode 题目）\n\n题目：\n\n老师想给站成一排的 N 个孩子分发糖果，分配规则如下：\n\n- 每个孩子至少分配到 1 个糖果；\n- 相邻的孩子中，评分更高的孩子必须获得更多的糖果。\n\n那么，老师至少需要准备多少颗糖果呢？\n\n---\n\n题目示例\n\n- 示例 1：\n\n  输入：`[1,0,2]`  \n  输出：`5`  \n  解释：可以分配糖果为 `[2,1,2]`。\n\n- 示例 2：\n\n  输入：`[1,2,2]`  \n  输出：`4`  \n  解释：可以分配糖果为 `[1,2,1]`，第三个孩子得到 1 颗糖果，满足条件。\n\n---\n\n规则分析\n\n设相邻的两个孩子为 A 和 B，A 在 B 左边，则：\n\n- **左规则**：当 `ratings[B] > ratings[A]` 时，B 得到的糖果数比 A 多；\n- **右规则**：当 `ratings[A] > ratings[B]` 时，A 得到的糖果数比 B 多。\n\n要满足所有相邻孩子都符合这两个规则，意味着每个孩子的糖果数既满足左规则又满足右规则。\n\n算法思路\n\n1. **初始化**：先给每个孩子 1 颗糖果。\n\n2. **从左到右遍历**，根据左规则更新糖果数：\n\n   - 若当前孩子评分比左边孩子高，则当前孩子的糖果数为左边孩子糖果数 + 1；\n   - 否则保持不变。\n\n3. **从右到左遍历**，根据右规则更新糖果数：\n\n   - 若当前孩子评分比右边孩子高，且糖果数不够，则更新为右边孩子糖果数 + 1。\n\n4. 最后，所有孩子糖果数取两次遍历后的最大值即满足左右规则，计算总和即为所需糖果总数。\n\n---\n\n代码实现（C++）\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int n = ratings.size();\n        if (n == 0) return 0;\n\n        // 每个孩子至少分配1颗糖果\n        vector<int> candies(n, 1);\n\n        // 左规则遍历：从左到右\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n\n        // 右规则遍历：从右到左\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\n                candies[i] = candies[i + 1] + 1;\n            }\n        }\n\n        // 计算糖果总数\n        int total = 0;\n        for (int c : candies) {\n            total += c;\n        }\n\n        return total;\n    }\n};\n```\n","slug":"05-ACM-algorithm-greedy","published":1,"updated":"2025-07-09T02:17:48.279Z","_id":"cmcvbtktn000114nfbjeq5u89","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"ACM-算法入门-·-贪心篇：从局部最优到整体最优的策略思维\"><a href=\"#ACM-算法入门-·-贪心篇：从局部最优到整体最优的策略思维\" class=\"headerlink\" title=\"ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维\"></a>ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维</h1><h2 id=\"什么是贪心算法？\"><a href=\"#什么是贪心算法？\" class=\"headerlink\" title=\"什么是贪心算法？\"></a>什么是贪心算法？</h2><blockquote>\n<p><strong>贪心算法（Greedy Algorithm）</strong> 是一种在每一步选择中都采取当前状态下最优（即最有利）选择的策略，期望通过局部最优最终达到全局最优。</p>\n</blockquote>\n<p>它的核心思想是：</p>\n<blockquote>\n<p><strong>局部最优 ➜ 全局最优</strong></p>\n</blockquote>\n<p>但需要特别注意的是：<strong>贪心策略并不总是适用于所有问题</strong>，它只适合满足以下两个条件的问题：</p>\n<ul>\n<li>✅ <strong>最优子结构</strong>：问题的最优解包含其子问题的最优解；</li>\n<li>✅ <strong>无后效性</strong>：某一步的选择不会影响后续的选择过程。</li>\n</ul>\n<p>如果问题不满足这两个性质，使用贪心算法可能得不到正确解。</p>\n<hr>\n<h2 id=\"贪心算法的基本思路\"><a href=\"#贪心算法的基本思路\" class=\"headerlink\" title=\"贪心算法的基本思路\"></a>贪心算法的基本思路</h2><p>贪心算法虽然没有统一的模板，但通常遵循以下解决步骤：</p>\n<ol>\n<li><strong>建立数学模型</strong>：用合理的数据结构和变量表达问题；</li>\n<li><strong>拆解为子问题</strong>：将原问题划分为一系列阶段性子问题；</li>\n<li><strong>定义贪心策略</strong>：找出每一步的“最优选择”规则；</li>\n<li><strong>按策略求解子问题</strong>：每次都按照贪心策略做选择；</li>\n<li><strong>组合局部最优解</strong>：最终汇总各步的选择，构成整体解。</li>\n</ol>\n<hr>\n<h2 id=\"贪心算法存在的问题\"><a href=\"#贪心算法存在的问题\" class=\"headerlink\" title=\"贪心算法存在的问题\"></a>贪心算法存在的问题</h2><ul>\n<li>不能保证最终求得的解一定是全局最优；</li>\n<li>不适用于所有需要求最大值或最小值的问题；</li>\n<li>只能求满足某些特定约束条件下的可行解。</li>\n</ul>\n<hr>\n<h2 id=\"贪心算法适用的问题\"><a href=\"#贪心算法适用的问题\" class=\"headerlink\" title=\"贪心算法适用的问题\"></a>贪心算法适用的问题</h2><p>贪心算法适用的前提是：<strong>局部最优策略能够导致全局最优解</strong>。<br>实际上，适用场景较少。判断一个问题是否适合贪心算法，通常可以通过实际数据测试和理论分析来确定。</p>\n<hr>\n<h2 id=\"贪心选择性质\"><a href=\"#贪心选择性质\" class=\"headerlink\" title=\"贪心选择性质\"></a>贪心选择性质</h2><ul>\n<li><p><strong>贪心选择性质</strong>：问题的整体最优解可通过一系列局部最优选择构建。<br>换言之，在做每一步选择时，只关注当前问题的最优选择，不考虑后续子问题的解。</p>\n</li>\n<li><p>贪心算法通过迭代进行，每次选择都会简化问题规模，形成更小的子问题。</p>\n</li>\n<li><p><strong>最优子结构性质</strong>：问题的最优解包含其子问题的最优解。<br>这是贪心算法能正确求解问题的关键。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"贪心算法的实现框架\"><a href=\"#贪心算法的实现框架\" class=\"headerlink\" title=\"贪心算法的实现框架\"></a>贪心算法的实现框架</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从初始解开始：</span><br><span class=\"line\">while (未达到目标) &#123;</span><br><span class=\"line\">    根据贪心策略选择当前最优的决策；</span><br><span class=\"line\">    将该决策加入解中，简化问题规模；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">最终，所有决策组合成问题的一个可行解。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"✨-示例：找零钱问题\"><a href=\"#✨-示例：找零钱问题\" class=\"headerlink\" title=\"✨ 示例：找零钱问题\"></a>✨ 示例：找零钱问题</h2><p><strong>目标</strong>：用尽量少的硬币凑出某个金额<br><strong>硬币面额</strong>：25 分、10 分、5 分、1 分<br><strong>贪心策略</strong>：每次选择当前面值最大的硬币</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">greedy_coin_change</span>(<span class=\"params\">amount</span>):</span><br><span class=\"line\">    coins = [<span class=\"number\">25</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> coin <span class=\"keyword\">in</span> coins:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> amount &gt;= coin:</span><br><span class=\"line\">            amount -= coin</span><br><span class=\"line\">            res.append(coin)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(greedy_coin_change(<span class=\"number\">63</span>))  <span class=\"comment\"># 输出：[25, 25, 10, 1, 1, 1]</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>贪心策略：每次优先选面值最大的硬币。</p>\n<p>选择步骤：</p>\n<ul>\n<li><p>63 分 ——&gt; 选择 2 个 25 分硬币，剩余 63 - 50 &#x3D; 13 分</p>\n</li>\n<li><p>13 分 ——&gt; 选择 1 个 10 分硬币，剩余 13 - 10 &#x3D; 3 分</p>\n</li>\n<li><p>3 分 ——&gt; 选择 0 个 5 分硬币（3 分不足 5 分），剩余 3 分</p>\n</li>\n<li><p>3 分 ——&gt; 选择 3 个 1 分硬币，剩余 3 - 3 &#x3D; 0 分，完成！</p>\n</li>\n</ul>\n<p>硬币组合：25 分 × 2 + 10 分 × 1 + 1 分 × 3 &#x3D; 63 分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[63元]</span><br><span class=\"line\">  |</span><br><span class=\"line\">  v</span><br><span class=\"line\">[用25元硬币×2] ---&gt; [剩余13元]</span><br><span class=\"line\">                          |</span><br><span class=\"line\">                          v</span><br><span class=\"line\">                  [用10元硬币×1] ---&gt; [剩余3元]</span><br><span class=\"line\">                                      |</span><br><span class=\"line\">                                      v</span><br><span class=\"line\">                            [用5元硬币? 不够]</span><br><span class=\"line\">                                      |</span><br><span class=\"line\">                                      v</span><br><span class=\"line\">                            [用1元硬币×3] ---&gt; [剩余0元，完成]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"贪心算法经典算法题\"><a href=\"#贪心算法经典算法题\" class=\"headerlink\" title=\"贪心算法经典算法题\"></a>贪心算法经典算法题</h2><h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><p>题目：<br>有一个背包，容量为 M &#x3D; 150，有 7 个物品，物品可分割成任意大小。<br>要求尽可能使装入背包的物品总价值最大，但不能超过总容量。</p>\n<table>\n<thead>\n<tr>\n<th>物品</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n<th>D</th>\n<th>E</th>\n<th>F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>重量</td>\n<td>35</td>\n<td>30</td>\n<td>60</td>\n<td>50</td>\n<td>40</td>\n<td>10</td>\n<td>25</td>\n</tr>\n<tr>\n<td>价值</td>\n<td>10</td>\n<td>40</td>\n<td>30</td>\n<td>50</td>\n<td>35</td>\n<td>40</td>\n<td>30</td>\n</tr>\n</tbody></table>\n<hr>\n<p>目标与约束</p>\n<ul>\n<li><strong>目标函数</strong>：最大化总价值 ( \\sum p_i )</li>\n<li><strong>约束条件</strong>：总重量不超过背包容量</li>\n</ul>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mi>M</mi><mspace width=\"1em\"/><mo stretchy=\"false\">(</mo><mi>M</mi><mo>=</mo><mn>150</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\n\\sum w_i \\leq M \\quad (M=150)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.6em;vertical-align:-0.55em;\"></span><span class=\"mop op-symbol large-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">150</span><span class=\"mclose\">)</span></span></span></span></span>\n\n<hr>\n<p>贪心策略分析</p>\n<p>针对该问题，考虑三种贪心策略：</p>\n<ol>\n<li><strong>每次选择价值最高的物品装入背包</strong></li>\n<li><strong>每次选择重量最小的物品装入背包</strong></li>\n<li><strong>每次选择单位重量价值最高的物品装入背包</strong></li>\n</ol>\n<hr>\n<p>策略有效性探讨</p>\n<ul>\n<li><p><strong>策略 1：选择价值最大物品</strong><br>不一定最优。<br>反例：</p>\n<ul>\n<li>容量 ( W&#x3D;30 )</li>\n<li>物品：A(28kg,30 价), B(12kg,20 价), C(12kg,20 价)<br>该策略先选 A，背包剩余空间不足以选 B 和 C。但选 B 和 C 总价值 40，优于选 A 的 30。</li>\n</ul>\n</li>\n<li><p><strong>策略 2：选择重量最小物品</strong><br>同样不一定最优，类似策略 1 的反例适用。</p>\n</li>\n<li><p><strong>策略 3：选择单位重量价值最高物品</strong><br>是解决分数背包的经典策略，通常最优。<br>但若单位价值相同，则需结合次级规则（如优先选重量小的物品）来避免歧义。</p>\n</li>\n</ul>\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 背包问题的贪心算法实现（分数背包）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 物品信息：重量和价值</span></span><br><span class=\"line\">items = [</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">35</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">30</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">40</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">60</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">50</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">40</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">35</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;F&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">10</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">40</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;G&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">25</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">capacity = <span class=\"number\">150</span>  <span class=\"comment\"># 背包容量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算单位价值（价值/重量）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> items:</span><br><span class=\"line\">    item[<span class=\"string\">&quot;unit_value&quot;</span>] = item[<span class=\"string\">&quot;value&quot;</span>] / item[<span class=\"string\">&quot;weight&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按单位价值从高到低排序</span></span><br><span class=\"line\">items.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"string\">&quot;unit_value&quot;</span>], reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">total_value = <span class=\"number\">0</span>  <span class=\"comment\"># 总价值</span></span><br><span class=\"line\">total_weight = <span class=\"number\">0</span>  <span class=\"comment\"># 总重量</span></span><br><span class=\"line\">selected_items = []  <span class=\"comment\"># 记录装入背包的物品及其比例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> items:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total_weight + item[<span class=\"string\">&quot;weight&quot;</span>] &lt;= capacity:</span><br><span class=\"line\">        <span class=\"comment\"># 能全部装入</span></span><br><span class=\"line\">        total_weight += item[<span class=\"string\">&quot;weight&quot;</span>]</span><br><span class=\"line\">        total_value += item[<span class=\"string\">&quot;value&quot;</span>]</span><br><span class=\"line\">        selected_items.append((item[<span class=\"string\">&quot;name&quot;</span>], <span class=\"number\">1</span>))  <span class=\"comment\"># 1表示全部装入</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 装入剩余容量的部分</span></span><br><span class=\"line\">        remain = capacity - total_weight</span><br><span class=\"line\">        fraction = remain / item[<span class=\"string\">&quot;weight&quot;</span>]</span><br><span class=\"line\">        total_weight += remain</span><br><span class=\"line\">        total_value += item[<span class=\"string\">&quot;value&quot;</span>] * fraction</span><br><span class=\"line\">        selected_items.append((item[<span class=\"string\">&quot;name&quot;</span>], fraction))</span><br><span class=\"line\">        <span class=\"keyword\">break</span>  <span class=\"comment\"># 背包满了，停止装入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;背包总重量: <span class=\"subst\">&#123;total_weight:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;背包总价值: <span class=\"subst\">&#123;total_value:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;装入背包的物品及比例:&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> name, frac <span class=\"keyword\">in</span> selected_items:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> frac == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  <span class=\"subst\">&#123;name&#125;</span> - 全部装入&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  <span class=\"subst\">&#123;name&#125;</span> - 装入 <span class=\"subst\">&#123;frac:<span class=\"number\">.2</span>%&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分发糖果（Leetcode-题目）\"><a href=\"#分发糖果（Leetcode-题目）\" class=\"headerlink\" title=\"分发糖果（Leetcode 题目）\"></a>分发糖果（Leetcode 题目）</h3><p>题目：</p>\n<p>老师想给站成一排的 N 个孩子分发糖果，分配规则如下：</p>\n<ul>\n<li>每个孩子至少分配到 1 个糖果；</li>\n<li>相邻的孩子中，评分更高的孩子必须获得更多的糖果。</li>\n</ul>\n<p>那么，老师至少需要准备多少颗糖果呢？</p>\n<hr>\n<p>题目示例</p>\n<ul>\n<li><p>示例 1：</p>\n<p>输入：<code>[1,0,2]</code><br>输出：<code>5</code><br>解释：可以分配糖果为 <code>[2,1,2]</code>。</p>\n</li>\n<li><p>示例 2：</p>\n<p>输入：<code>[1,2,2]</code><br>输出：<code>4</code><br>解释：可以分配糖果为 <code>[1,2,1]</code>，第三个孩子得到 1 颗糖果，满足条件。</p>\n</li>\n</ul>\n<hr>\n<p>规则分析</p>\n<p>设相邻的两个孩子为 A 和 B，A 在 B 左边，则：</p>\n<ul>\n<li><strong>左规则</strong>：当 <code>ratings[B] &gt; ratings[A]</code> 时，B 得到的糖果数比 A 多；</li>\n<li><strong>右规则</strong>：当 <code>ratings[A] &gt; ratings[B]</code> 时，A 得到的糖果数比 B 多。</li>\n</ul>\n<p>要满足所有相邻孩子都符合这两个规则，意味着每个孩子的糖果数既满足左规则又满足右规则。</p>\n<p>算法思路</p>\n<ol>\n<li><p><strong>初始化</strong>：先给每个孩子 1 颗糖果。</p>\n</li>\n<li><p><strong>从左到右遍历</strong>，根据左规则更新糖果数：</p>\n<ul>\n<li>若当前孩子评分比左边孩子高，则当前孩子的糖果数为左边孩子糖果数 + 1；</li>\n<li>否则保持不变。</li>\n</ul>\n</li>\n<li><p><strong>从右到左遍历</strong>，根据右规则更新糖果数：</p>\n<ul>\n<li>若当前孩子评分比右边孩子高，且糖果数不够，则更新为右边孩子糖果数 + 1。</li>\n</ul>\n</li>\n<li><p>最后，所有孩子糖果数取两次遍历后的最大值即满足左右规则，计算总和即为所需糖果总数。</p>\n</li>\n</ol>\n<hr>\n<p>代码实现（C++）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">candy</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = ratings.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 每个孩子至少分配1颗糖果</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">candies</span><span class=\"params\">(n, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 左规则遍历：从左到右</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                candies[i] = candies[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 右规则遍历：从右到左</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i + <span class=\"number\">1</span>] &amp;&amp; candies[i] &lt;= candies[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                candies[i] = candies[i + <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算糖果总数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> c : candies) &#123;</span><br><span class=\"line\">            total += c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1 id=\"ACM-算法入门-·-贪心篇：从局部最优到整体最优的策略思维\"><a href=\"#ACM-算法入门-·-贪心篇：从局部最优到整体最优的策略思维\" class=\"headerlink\" title=\"ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维\"></a>ACM 算法入门 · 贪心篇：从局部最优到整体最优的策略思维</h1><h2 id=\"什么是贪心算法？\"><a href=\"#什么是贪心算法？\" class=\"headerlink\" title=\"什么是贪心算法？\"></a>什么是贪心算法？</h2><blockquote>\n<p><strong>贪心算法（Greedy Algorithm）</strong> 是一种在每一步选择中都采取当前状态下最优（即最有利）选择的策略，期望通过局部最优最终达到全局最优。</p>\n</blockquote>\n<p>它的核心思想是：</p>\n<blockquote>\n<p><strong>局部最优 ➜ 全局最优</strong></p>\n</blockquote>\n<p>但需要特别注意的是：<strong>贪心策略并不总是适用于所有问题</strong>，它只适合满足以下两个条件的问题：</p>\n<ul>\n<li>✅ <strong>最优子结构</strong>：问题的最优解包含其子问题的最优解；</li>\n<li>✅ <strong>无后效性</strong>：某一步的选择不会影响后续的选择过程。</li>\n</ul>\n<p>如果问题不满足这两个性质，使用贪心算法可能得不到正确解。</p>\n<hr>\n<h2 id=\"贪心算法的基本思路\"><a href=\"#贪心算法的基本思路\" class=\"headerlink\" title=\"贪心算法的基本思路\"></a>贪心算法的基本思路</h2><p>贪心算法虽然没有统一的模板，但通常遵循以下解决步骤：</p>\n<ol>\n<li><strong>建立数学模型</strong>：用合理的数据结构和变量表达问题；</li>\n<li><strong>拆解为子问题</strong>：将原问题划分为一系列阶段性子问题；</li>\n<li><strong>定义贪心策略</strong>：找出每一步的“最优选择”规则；</li>\n<li><strong>按策略求解子问题</strong>：每次都按照贪心策略做选择；</li>\n<li><strong>组合局部最优解</strong>：最终汇总各步的选择，构成整体解。</li>\n</ol>\n<hr>\n<h2 id=\"贪心算法存在的问题\"><a href=\"#贪心算法存在的问题\" class=\"headerlink\" title=\"贪心算法存在的问题\"></a>贪心算法存在的问题</h2><ul>\n<li>不能保证最终求得的解一定是全局最优；</li>\n<li>不适用于所有需要求最大值或最小值的问题；</li>\n<li>只能求满足某些特定约束条件下的可行解。</li>\n</ul>\n<hr>\n<h2 id=\"贪心算法适用的问题\"><a href=\"#贪心算法适用的问题\" class=\"headerlink\" title=\"贪心算法适用的问题\"></a>贪心算法适用的问题</h2><p>贪心算法适用的前提是：<strong>局部最优策略能够导致全局最优解</strong>。<br>实际上，适用场景较少。判断一个问题是否适合贪心算法，通常可以通过实际数据测试和理论分析来确定。</p>\n<hr>\n<h2 id=\"贪心选择性质\"><a href=\"#贪心选择性质\" class=\"headerlink\" title=\"贪心选择性质\"></a>贪心选择性质</h2><ul>\n<li><p><strong>贪心选择性质</strong>：问题的整体最优解可通过一系列局部最优选择构建。<br>换言之，在做每一步选择时，只关注当前问题的最优选择，不考虑后续子问题的解。</p>\n</li>\n<li><p>贪心算法通过迭代进行，每次选择都会简化问题规模，形成更小的子问题。</p>\n</li>\n<li><p><strong>最优子结构性质</strong>：问题的最优解包含其子问题的最优解。<br>这是贪心算法能正确求解问题的关键。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"贪心算法的实现框架\"><a href=\"#贪心算法的实现框架\" class=\"headerlink\" title=\"贪心算法的实现框架\"></a>贪心算法的实现框架</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从初始解开始：</span><br><span class=\"line\">while (未达到目标) &#123;</span><br><span class=\"line\">    根据贪心策略选择当前最优的决策；</span><br><span class=\"line\">    将该决策加入解中，简化问题规模；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">最终，所有决策组合成问题的一个可行解。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"✨-示例：找零钱问题\"><a href=\"#✨-示例：找零钱问题\" class=\"headerlink\" title=\"✨ 示例：找零钱问题\"></a>✨ 示例：找零钱问题</h2><p><strong>目标</strong>：用尽量少的硬币凑出某个金额<br><strong>硬币面额</strong>：25 分、10 分、5 分、1 分<br><strong>贪心策略</strong>：每次选择当前面值最大的硬币</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">greedy_coin_change</span>(<span class=\"params\">amount</span>):</span><br><span class=\"line\">    coins = [<span class=\"number\">25</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> coin <span class=\"keyword\">in</span> coins:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> amount &gt;= coin:</span><br><span class=\"line\">            amount -= coin</span><br><span class=\"line\">            res.append(coin)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(greedy_coin_change(<span class=\"number\">63</span>))  <span class=\"comment\"># 输出：[25, 25, 10, 1, 1, 1]</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>贪心策略：每次优先选面值最大的硬币。</p>\n<p>选择步骤：</p>\n<ul>\n<li><p>63 分 ——&gt; 选择 2 个 25 分硬币，剩余 63 - 50 &#x3D; 13 分</p>\n</li>\n<li><p>13 分 ——&gt; 选择 1 个 10 分硬币，剩余 13 - 10 &#x3D; 3 分</p>\n</li>\n<li><p>3 分 ——&gt; 选择 0 个 5 分硬币（3 分不足 5 分），剩余 3 分</p>\n</li>\n<li><p>3 分 ——&gt; 选择 3 个 1 分硬币，剩余 3 - 3 &#x3D; 0 分，完成！</p>\n</li>\n</ul>\n<p>硬币组合：25 分 × 2 + 10 分 × 1 + 1 分 × 3 &#x3D; 63 分</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[63元]</span><br><span class=\"line\">  |</span><br><span class=\"line\">  v</span><br><span class=\"line\">[用25元硬币×2] ---&gt; [剩余13元]</span><br><span class=\"line\">                          |</span><br><span class=\"line\">                          v</span><br><span class=\"line\">                  [用10元硬币×1] ---&gt; [剩余3元]</span><br><span class=\"line\">                                      |</span><br><span class=\"line\">                                      v</span><br><span class=\"line\">                            [用5元硬币? 不够]</span><br><span class=\"line\">                                      |</span><br><span class=\"line\">                                      v</span><br><span class=\"line\">                            [用1元硬币×3] ---&gt; [剩余0元，完成]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"贪心算法经典算法题\"><a href=\"#贪心算法经典算法题\" class=\"headerlink\" title=\"贪心算法经典算法题\"></a>贪心算法经典算法题</h2><h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><p>题目：<br>有一个背包，容量为 M &#x3D; 150，有 7 个物品，物品可分割成任意大小。<br>要求尽可能使装入背包的物品总价值最大，但不能超过总容量。</p>\n<table>\n<thead>\n<tr>\n<th>物品</th>\n<th>A</th>\n<th>B</th>\n<th>C</th>\n<th>D</th>\n<th>E</th>\n<th>F</th>\n<th>G</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>重量</td>\n<td>35</td>\n<td>30</td>\n<td>60</td>\n<td>50</td>\n<td>40</td>\n<td>10</td>\n<td>25</td>\n</tr>\n<tr>\n<td>价值</td>\n<td>10</td>\n<td>40</td>\n<td>30</td>\n<td>50</td>\n<td>35</td>\n<td>40</td>\n<td>30</td>\n</tr>\n</tbody></table>\n<hr>\n<p>目标与约束</p>\n<ul>\n<li><strong>目标函数</strong>：最大化总价值 ( \\sum p_i )</li>\n<li><strong>约束条件</strong>：总重量不超过背包容量</li>\n</ul>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub><mo>≤</mo><mi>M</mi><mspace width=\"1em\"/><mo stretchy=\"false\">(</mo><mi>M</mi><mo>=</mo><mn>150</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\n\\sum w_i \\leq M \\quad (M=150)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.6em;vertical-align:-0.55em;\"></span><span class=\"mop op-symbol large-op\" style=\"position:relative;top:0em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3117em;\"><span style=\"top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">150</span><span class=\"mclose\">)</span></span></span></span></span>\n\n<hr>\n<p>贪心策略分析</p>\n<p>针对该问题，考虑三种贪心策略：</p>\n<ol>\n<li><strong>每次选择价值最高的物品装入背包</strong></li>\n<li><strong>每次选择重量最小的物品装入背包</strong></li>\n<li><strong>每次选择单位重量价值最高的物品装入背包</strong></li>\n</ol>\n<hr>\n<p>策略有效性探讨</p>\n<ul>\n<li><p><strong>策略 1：选择价值最大物品</strong><br>不一定最优。<br>反例：</p>\n<ul>\n<li>容量 ( W&#x3D;30 )</li>\n<li>物品：A(28kg,30 价), B(12kg,20 价), C(12kg,20 价)<br>该策略先选 A，背包剩余空间不足以选 B 和 C。但选 B 和 C 总价值 40，优于选 A 的 30。</li>\n</ul>\n</li>\n<li><p><strong>策略 2：选择重量最小物品</strong><br>同样不一定最优，类似策略 1 的反例适用。</p>\n</li>\n<li><p><strong>策略 3：选择单位重量价值最高物品</strong><br>是解决分数背包的经典策略，通常最优。<br>但若单位价值相同，则需结合次级规则（如优先选重量小的物品）来避免歧义。</p>\n</li>\n</ul>\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 背包问题的贪心算法实现（分数背包）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 物品信息：重量和价值</span></span><br><span class=\"line\">items = [</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">35</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">30</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">40</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">60</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">50</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">50</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">40</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">35</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;F&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">10</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">40</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;G&quot;</span>, <span class=\"string\">&quot;weight&quot;</span>: <span class=\"number\">25</span>, <span class=\"string\">&quot;value&quot;</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">capacity = <span class=\"number\">150</span>  <span class=\"comment\"># 背包容量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 计算单位价值（价值/重量）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> items:</span><br><span class=\"line\">    item[<span class=\"string\">&quot;unit_value&quot;</span>] = item[<span class=\"string\">&quot;value&quot;</span>] / item[<span class=\"string\">&quot;weight&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 按单位价值从高到低排序</span></span><br><span class=\"line\">items.sort(key=<span class=\"keyword\">lambda</span> x: x[<span class=\"string\">&quot;unit_value&quot;</span>], reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">total_value = <span class=\"number\">0</span>  <span class=\"comment\"># 总价值</span></span><br><span class=\"line\">total_weight = <span class=\"number\">0</span>  <span class=\"comment\"># 总重量</span></span><br><span class=\"line\">selected_items = []  <span class=\"comment\"># 记录装入背包的物品及其比例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> items:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> total_weight + item[<span class=\"string\">&quot;weight&quot;</span>] &lt;= capacity:</span><br><span class=\"line\">        <span class=\"comment\"># 能全部装入</span></span><br><span class=\"line\">        total_weight += item[<span class=\"string\">&quot;weight&quot;</span>]</span><br><span class=\"line\">        total_value += item[<span class=\"string\">&quot;value&quot;</span>]</span><br><span class=\"line\">        selected_items.append((item[<span class=\"string\">&quot;name&quot;</span>], <span class=\"number\">1</span>))  <span class=\"comment\"># 1表示全部装入</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 装入剩余容量的部分</span></span><br><span class=\"line\">        remain = capacity - total_weight</span><br><span class=\"line\">        fraction = remain / item[<span class=\"string\">&quot;weight&quot;</span>]</span><br><span class=\"line\">        total_weight += remain</span><br><span class=\"line\">        total_value += item[<span class=\"string\">&quot;value&quot;</span>] * fraction</span><br><span class=\"line\">        selected_items.append((item[<span class=\"string\">&quot;name&quot;</span>], fraction))</span><br><span class=\"line\">        <span class=\"keyword\">break</span>  <span class=\"comment\"># 背包满了，停止装入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;背包总重量: <span class=\"subst\">&#123;total_weight:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;背包总价值: <span class=\"subst\">&#123;total_value:<span class=\"number\">.2</span>f&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;装入背包的物品及比例:&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> name, frac <span class=\"keyword\">in</span> selected_items:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> frac == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  <span class=\"subst\">&#123;name&#125;</span> - 全部装入&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;  <span class=\"subst\">&#123;name&#125;</span> - 装入 <span class=\"subst\">&#123;frac:<span class=\"number\">.2</span>%&#125;</span>&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分发糖果（Leetcode-题目）\"><a href=\"#分发糖果（Leetcode-题目）\" class=\"headerlink\" title=\"分发糖果（Leetcode 题目）\"></a>分发糖果（Leetcode 题目）</h3><p>题目：</p>\n<p>老师想给站成一排的 N 个孩子分发糖果，分配规则如下：</p>\n<ul>\n<li>每个孩子至少分配到 1 个糖果；</li>\n<li>相邻的孩子中，评分更高的孩子必须获得更多的糖果。</li>\n</ul>\n<p>那么，老师至少需要准备多少颗糖果呢？</p>\n<hr>\n<p>题目示例</p>\n<ul>\n<li><p>示例 1：</p>\n<p>输入：<code>[1,0,2]</code><br>输出：<code>5</code><br>解释：可以分配糖果为 <code>[2,1,2]</code>。</p>\n</li>\n<li><p>示例 2：</p>\n<p>输入：<code>[1,2,2]</code><br>输出：<code>4</code><br>解释：可以分配糖果为 <code>[1,2,1]</code>，第三个孩子得到 1 颗糖果，满足条件。</p>\n</li>\n</ul>\n<hr>\n<p>规则分析</p>\n<p>设相邻的两个孩子为 A 和 B，A 在 B 左边，则：</p>\n<ul>\n<li><strong>左规则</strong>：当 <code>ratings[B] &gt; ratings[A]</code> 时，B 得到的糖果数比 A 多；</li>\n<li><strong>右规则</strong>：当 <code>ratings[A] &gt; ratings[B]</code> 时，A 得到的糖果数比 B 多。</li>\n</ul>\n<p>要满足所有相邻孩子都符合这两个规则，意味着每个孩子的糖果数既满足左规则又满足右规则。</p>\n<p>算法思路</p>\n<ol>\n<li><p><strong>初始化</strong>：先给每个孩子 1 颗糖果。</p>\n</li>\n<li><p><strong>从左到右遍历</strong>，根据左规则更新糖果数：</p>\n<ul>\n<li>若当前孩子评分比左边孩子高，则当前孩子的糖果数为左边孩子糖果数 + 1；</li>\n<li>否则保持不变。</li>\n</ul>\n</li>\n<li><p><strong>从右到左遍历</strong>，根据右规则更新糖果数：</p>\n<ul>\n<li>若当前孩子评分比右边孩子高，且糖果数不够，则更新为右边孩子糖果数 + 1。</li>\n</ul>\n</li>\n<li><p>最后，所有孩子糖果数取两次遍历后的最大值即满足左右规则，计算总和即为所需糖果总数。</p>\n</li>\n</ol>\n<hr>\n<p>代码实现（C++）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">candy</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = ratings.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 每个孩子至少分配1颗糖果</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">candies</span><span class=\"params\">(n, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 左规则遍历：从左到右</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                candies[i] = candies[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 右规则遍历：从右到左</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i + <span class=\"number\">1</span>] &amp;&amp; candies[i] &lt;= candies[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                candies[i] = candies[i + <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算糖果总数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> c : candies) &#123;</span><br><span class=\"line\">            total += c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"桂林电子科技大学 ACM 暑假课 | 7 月 23 日 ACM 作业题解","date":"2025-07-23T00:43:21.000Z","_content":"\n## 1.A. 找良好数组\n\n**题目描述**  \n给你一个数组 `a`，下标从 0 开始。  \n如果数组中的每个奇数下标为奇数，且每个偶数下标为偶数，则称其为“好数组”，否则为“坏数组”。  \n你可以任意交换两个元素（可以不相邻）。  \n请你判断是否可以通过最少交换变为好数组，并输出最小交换次数；若无法变成好数组，输出 `-1`。\n\n**输入**\n\n- 第一行一个整数 `t`（1 ≤ t ≤ 1000）表示测试用例组数。\n- 每组测试用例：\n  - 第一行一个整数 `n`（1 ≤ n ≤ 40）表示数组长度。\n  - 第二行 `n` 个整数 `a0, a1, ..., an−1`（0 ≤ ai ≤ 1000）。\n\n**输出**  \n每组数据输出一个整数：能变为好数组的最小交换次数，或 `-1` 表示无法实现。\n\n**样例输入**\n\n```\n4\n4\n3 2 7 6\n3\n3 2 6\n1\n7\n7\n4 9 2 1 18 3 0\n```\n\n**样例输出**\n\n```\n2\n1\n-1\n0\n```\n\n---\n\n## 2.B. B 进制加法\n\n**题目描述**  \n给定一个进制 `B`（2 ≤ B ≤ 36），以及两个 `B` 进制的正整数，求它们的和（结果仍为 `B` 进制）。\n\n**输入**\n\n```\n第1行：进制 B\n第2行：第一个 B 进制正整数\n第3行：第二个 B 进制正整数\n```\n\n**输出**  \n一个 B 进制的数，表示两个输入数的和。\n\n**样例输入**\n\n```\n4\n123\n321\n```\n\n**样例输出**\n\n```\n1110\n```\n\n---\n\n## 3.C. 高精度五则运算\n\n**题目描述**  \n输入两个大整数 A 和 B（A, B > 0，长度不超过 10^4），求它们的：和、差、积、商（整除）、余。\n\n**输入**\n\n```\nA\nB\n```\n\n**输出**  \n五行，依次输出：和、差、积、商、余。\n\n**样例输入**\n\n```\n1\n1\n```\n\n**样例输出**\n\n```\n2\n0\n1\n1\n0\n```\n\n---\n\n## 4.D. 栈操作\n\n**题目描述**  \n三种操作：\n\n- `p x`：将数字 `x` 压入栈中\n- `t`：输出栈顶元素（若栈为空输出 `no`）\n- `d`：删除栈顶元素（若栈为空不操作）\n\n**输入**\n\n```\n第一行一个整数 N（1 < N < 200）\n接下来的 N 行是操作指令\n```\n\n**输出**  \n每次 `t` 操作输出栈顶元素或 `no`\n\n**样例输入**\n\n```\n5\np 2\np 1\nt\nd\nt\n```\n\n**样例输出**\n\n```\n1\n2\n```\n\n---\n\n## 5.E. 队列操作\n\n**题目描述**  \n三种操作：\n\n- `p x`：将数字 `x` 入队\n- `t`：输出队首元素（若为空输出 `no`）\n- `d`：删除队首元素（若为空不操作）\n\n**输入**\n\n```\n第一行一个整数 N（1 < N < 200）\n接下来的 N 行是操作指令\n```\n\n**输出**  \n每次 `t` 操作输出队首元素或 `no`\n\n**样例输入**\n\n```\n7\np 1\np 2\nt\nd\nd\nd\nt\n```\n\n**样例输出**\n\n```\n1\nno\n```\n\n---\n\n## 6.F. 采药（完全背包）\n\n**题目描述**  \n有 n 株草药，每株采集需要 Ti 时间，价值 Vi，总共时间为 m，求最大价值。\n\n**输入**\n\n```\n第一行 t 表示测试组数\n每组：\n  一行两个整数 n m\n  接下来 n 行每行两个整数 Ti Vi\n```\n\n**输出**  \n每组输出一个整数，表示最大价值\n\n**样例输入**\n\n```\n1\n3 70\n71 100\n69 1\n1 2\n```\n\n**样例输出**\n\n```\n3\n```\n\n---\n\n## 7.G. 射击游戏（前缀和）\n\n**题目描述**  \n有 `n` 个靶子，每个靶子需要 `ai` 发子弹，`m` 次查询，每次给定区间 `[L,R]`，求其总子弹数。\n\n**输入**\n\n```\n第一行 n（1 < n < 1e5）\n第二行 n 个整数 ai\n第三行 m（1 < m < 1e5）\n接下来 m 行，每行两个数 L R（1-based）\n```\n\n**输出**  \nm 行，每行一个整数，表示每次所需子弹数\n\n**样例输入**\n\n```\n5\n1 2 3 4 5\n3\n1 2\n1 5\n3 5\n```\n\n**样例输出**\n\n```\n3\n15\n12\n```\n\n---\n\n## 8.H. 二分查找\n\n**题目描述**  \n长度为 `n` 的非降序列，进行 `m` 次查询，每次查询给出一个整数 `q`，输出其首次出现的位置（1-based），否则输出 `-1`。\n\n**输入**\n\n```\n第一行 n m\n第二行 n 个非降整数 ai\n第三行 m 个整数 q\n```\n\n**输出**  \n一行，m 个整数，用空格分隔，表示每个查询结果\n\n**样例输入**\n\n```\n11 3\n1 3 3 3 5 7 9 11 13 15 15\n1 3 6\n```\n\n**样例输出**\n\n```\n1 2 -1\n```\n\n---\n\n## 9.I. 神奇的四次方数（DP）\n\n**题目描述**  \n将整数 `m` 分解为若干个四次方数之和，要求最少项数。\n\n**输入**\n\n```\n一行，一个整数 m（1 ≤ m ≤ 100000）\n```\n\n**输出**\n\n```\n最少项数 n\n```\n\n**样例输入**\n\n```\n706\n```\n\n**样例输出**\n\n```\n2\n```\n\n---\n\n## 10.J. 栈合法序列个数（卡特兰数）\n\n**题目描述**  \n求长度为 `2n` 的合法出栈序列个数，等价于卡特兰数 `C_n`。\n\n**输入**\n\n```\n一行一个整数 n（1 ≤ n ≤ 18）\n```\n\n**输出**\n\n```\n合法序列个数\n```\n\n**样例输入**\n\n```\n3\n```\n\n**样例输出**\n\n```\n5\n```\n\n---\n\n## 11.K. FBI 树（分治 + 后序遍历）\n\n**题目描述**  \n给定一个长度为 `2^n` 的“01”字符串，构建 FBI 树并输出其**后序遍历**。\n\n- 若全是 0，则为 `B`；\n- 若全是 1，则为 `I`；\n- 否则为 `F`，其左右子树分别对应前一半和后一半。\n\n**输入**\n\n```\n第一行一个整数 n（1 ≤ n ≤ 10）\n第二行一个长度为 2^n 的 01 字符串\n```\n\n**输出**\n\n```\n后序遍历字符串\n```\n\n**样例输入**\n\n```\n3\n10001011\n```\n\n**样例输出**\n\n```\nIBFBBBFIBFIIIFF\n```\n","source":"_posts/08-ACM-homework-7-23.md","raw":"---\ntitle: 桂林电子科技大学 ACM 暑假课 | 7 月 23 日 ACM 作业题解\ndate: 2025-07-23 08:43:21\ntags:\n  - 作业题解\n  - ACM 算法\ncategories:\n  - 算法入门\n---\n\n## 1.A. 找良好数组\n\n**题目描述**  \n给你一个数组 `a`，下标从 0 开始。  \n如果数组中的每个奇数下标为奇数，且每个偶数下标为偶数，则称其为“好数组”，否则为“坏数组”。  \n你可以任意交换两个元素（可以不相邻）。  \n请你判断是否可以通过最少交换变为好数组，并输出最小交换次数；若无法变成好数组，输出 `-1`。\n\n**输入**\n\n- 第一行一个整数 `t`（1 ≤ t ≤ 1000）表示测试用例组数。\n- 每组测试用例：\n  - 第一行一个整数 `n`（1 ≤ n ≤ 40）表示数组长度。\n  - 第二行 `n` 个整数 `a0, a1, ..., an−1`（0 ≤ ai ≤ 1000）。\n\n**输出**  \n每组数据输出一个整数：能变为好数组的最小交换次数，或 `-1` 表示无法实现。\n\n**样例输入**\n\n```\n4\n4\n3 2 7 6\n3\n3 2 6\n1\n7\n7\n4 9 2 1 18 3 0\n```\n\n**样例输出**\n\n```\n2\n1\n-1\n0\n```\n\n---\n\n## 2.B. B 进制加法\n\n**题目描述**  \n给定一个进制 `B`（2 ≤ B ≤ 36），以及两个 `B` 进制的正整数，求它们的和（结果仍为 `B` 进制）。\n\n**输入**\n\n```\n第1行：进制 B\n第2行：第一个 B 进制正整数\n第3行：第二个 B 进制正整数\n```\n\n**输出**  \n一个 B 进制的数，表示两个输入数的和。\n\n**样例输入**\n\n```\n4\n123\n321\n```\n\n**样例输出**\n\n```\n1110\n```\n\n---\n\n## 3.C. 高精度五则运算\n\n**题目描述**  \n输入两个大整数 A 和 B（A, B > 0，长度不超过 10^4），求它们的：和、差、积、商（整除）、余。\n\n**输入**\n\n```\nA\nB\n```\n\n**输出**  \n五行，依次输出：和、差、积、商、余。\n\n**样例输入**\n\n```\n1\n1\n```\n\n**样例输出**\n\n```\n2\n0\n1\n1\n0\n```\n\n---\n\n## 4.D. 栈操作\n\n**题目描述**  \n三种操作：\n\n- `p x`：将数字 `x` 压入栈中\n- `t`：输出栈顶元素（若栈为空输出 `no`）\n- `d`：删除栈顶元素（若栈为空不操作）\n\n**输入**\n\n```\n第一行一个整数 N（1 < N < 200）\n接下来的 N 行是操作指令\n```\n\n**输出**  \n每次 `t` 操作输出栈顶元素或 `no`\n\n**样例输入**\n\n```\n5\np 2\np 1\nt\nd\nt\n```\n\n**样例输出**\n\n```\n1\n2\n```\n\n---\n\n## 5.E. 队列操作\n\n**题目描述**  \n三种操作：\n\n- `p x`：将数字 `x` 入队\n- `t`：输出队首元素（若为空输出 `no`）\n- `d`：删除队首元素（若为空不操作）\n\n**输入**\n\n```\n第一行一个整数 N（1 < N < 200）\n接下来的 N 行是操作指令\n```\n\n**输出**  \n每次 `t` 操作输出队首元素或 `no`\n\n**样例输入**\n\n```\n7\np 1\np 2\nt\nd\nd\nd\nt\n```\n\n**样例输出**\n\n```\n1\nno\n```\n\n---\n\n## 6.F. 采药（完全背包）\n\n**题目描述**  \n有 n 株草药，每株采集需要 Ti 时间，价值 Vi，总共时间为 m，求最大价值。\n\n**输入**\n\n```\n第一行 t 表示测试组数\n每组：\n  一行两个整数 n m\n  接下来 n 行每行两个整数 Ti Vi\n```\n\n**输出**  \n每组输出一个整数，表示最大价值\n\n**样例输入**\n\n```\n1\n3 70\n71 100\n69 1\n1 2\n```\n\n**样例输出**\n\n```\n3\n```\n\n---\n\n## 7.G. 射击游戏（前缀和）\n\n**题目描述**  \n有 `n` 个靶子，每个靶子需要 `ai` 发子弹，`m` 次查询，每次给定区间 `[L,R]`，求其总子弹数。\n\n**输入**\n\n```\n第一行 n（1 < n < 1e5）\n第二行 n 个整数 ai\n第三行 m（1 < m < 1e5）\n接下来 m 行，每行两个数 L R（1-based）\n```\n\n**输出**  \nm 行，每行一个整数，表示每次所需子弹数\n\n**样例输入**\n\n```\n5\n1 2 3 4 5\n3\n1 2\n1 5\n3 5\n```\n\n**样例输出**\n\n```\n3\n15\n12\n```\n\n---\n\n## 8.H. 二分查找\n\n**题目描述**  \n长度为 `n` 的非降序列，进行 `m` 次查询，每次查询给出一个整数 `q`，输出其首次出现的位置（1-based），否则输出 `-1`。\n\n**输入**\n\n```\n第一行 n m\n第二行 n 个非降整数 ai\n第三行 m 个整数 q\n```\n\n**输出**  \n一行，m 个整数，用空格分隔，表示每个查询结果\n\n**样例输入**\n\n```\n11 3\n1 3 3 3 5 7 9 11 13 15 15\n1 3 6\n```\n\n**样例输出**\n\n```\n1 2 -1\n```\n\n---\n\n## 9.I. 神奇的四次方数（DP）\n\n**题目描述**  \n将整数 `m` 分解为若干个四次方数之和，要求最少项数。\n\n**输入**\n\n```\n一行，一个整数 m（1 ≤ m ≤ 100000）\n```\n\n**输出**\n\n```\n最少项数 n\n```\n\n**样例输入**\n\n```\n706\n```\n\n**样例输出**\n\n```\n2\n```\n\n---\n\n## 10.J. 栈合法序列个数（卡特兰数）\n\n**题目描述**  \n求长度为 `2n` 的合法出栈序列个数，等价于卡特兰数 `C_n`。\n\n**输入**\n\n```\n一行一个整数 n（1 ≤ n ≤ 18）\n```\n\n**输出**\n\n```\n合法序列个数\n```\n\n**样例输入**\n\n```\n3\n```\n\n**样例输出**\n\n```\n5\n```\n\n---\n\n## 11.K. FBI 树（分治 + 后序遍历）\n\n**题目描述**  \n给定一个长度为 `2^n` 的“01”字符串，构建 FBI 树并输出其**后序遍历**。\n\n- 若全是 0，则为 `B`；\n- 若全是 1，则为 `I`；\n- 否则为 `F`，其左右子树分别对应前一半和后一半。\n\n**输入**\n\n```\n第一行一个整数 n（1 ≤ n ≤ 10）\n第二行一个长度为 2^n 的 01 字符串\n```\n\n**输出**\n\n```\n后序遍历字符串\n```\n\n**样例输入**\n\n```\n3\n10001011\n```\n\n**样例输出**\n\n```\nIBFBBBFIBFIIIFF\n```\n","slug":"08-ACM-homework-7-23","published":1,"updated":"2025-07-09T01:15:46.473Z","comments":1,"layout":"post","photos":[],"_id":"cmcvbtktp000314nf32czgrne","content":"<h2 id=\"1-A-找良好数组\"><a href=\"#1-A-找良好数组\" class=\"headerlink\" title=\"1.A. 找良好数组\"></a>1.A. 找良好数组</h2><p><strong>题目描述</strong><br>给你一个数组 <code>a</code>，下标从 0 开始。<br>如果数组中的每个奇数下标为奇数，且每个偶数下标为偶数，则称其为“好数组”，否则为“坏数组”。<br>你可以任意交换两个元素（可以不相邻）。<br>请你判断是否可以通过最少交换变为好数组，并输出最小交换次数；若无法变成好数组，输出 <code>-1</code>。</p>\n<p><strong>输入</strong></p>\n<ul>\n<li>第一行一个整数 <code>t</code>（1 ≤ t ≤ 1000）表示测试用例组数。</li>\n<li>每组测试用例：<ul>\n<li>第一行一个整数 <code>n</code>（1 ≤ n ≤ 40）表示数组长度。</li>\n<li>第二行 <code>n</code> 个整数 <code>a0, a1, ..., an−1</code>（0 ≤ ai ≤ 1000）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>输出</strong><br>每组数据输出一个整数：能变为好数组的最小交换次数，或 <code>-1</code> 表示无法实现。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">4</span><br><span class=\"line\">3 2 7 6</span><br><span class=\"line\">3</span><br><span class=\"line\">3 2 6</span><br><span class=\"line\">1</span><br><span class=\"line\">7</span><br><span class=\"line\">7</span><br><span class=\"line\">4 9 2 1 18 3 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">-1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-B-B-进制加法\"><a href=\"#2-B-B-进制加法\" class=\"headerlink\" title=\"2.B. B 进制加法\"></a>2.B. B 进制加法</h2><p><strong>题目描述</strong><br>给定一个进制 <code>B</code>（2 ≤ B ≤ 36），以及两个 <code>B</code> 进制的正整数，求它们的和（结果仍为 <code>B</code> 进制）。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第1行：进制 B</span><br><span class=\"line\">第2行：第一个 B 进制正整数</span><br><span class=\"line\">第3行：第二个 B 进制正整数</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>一个 B 进制的数，表示两个输入数的和。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">123</span><br><span class=\"line\">321</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-C-高精度五则运算\"><a href=\"#3-C-高精度五则运算\" class=\"headerlink\" title=\"3.C. 高精度五则运算\"></a>3.C. 高精度五则运算</h2><p><strong>题目描述</strong><br>输入两个大整数 A 和 B（A, B &gt; 0，长度不超过 10^4），求它们的：和、差、积、商（整除）、余。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>五行，依次输出：和、差、积、商、余。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-D-栈操作\"><a href=\"#4-D-栈操作\" class=\"headerlink\" title=\"4.D. 栈操作\"></a>4.D. 栈操作</h2><p><strong>题目描述</strong><br>三种操作：</p>\n<ul>\n<li><code>p x</code>：将数字 <code>x</code> 压入栈中</li>\n<li><code>t</code>：输出栈顶元素（若栈为空输出 <code>no</code>）</li>\n<li><code>d</code>：删除栈顶元素（若栈为空不操作）</li>\n</ul>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行一个整数 N（1 &lt; N &lt; 200）</span><br><span class=\"line\">接下来的 N 行是操作指令</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>每次 <code>t</code> 操作输出栈顶元素或 <code>no</code></p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">p 2</span><br><span class=\"line\">p 1</span><br><span class=\"line\">t</span><br><span class=\"line\">d</span><br><span class=\"line\">t</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5-E-队列操作\"><a href=\"#5-E-队列操作\" class=\"headerlink\" title=\"5.E. 队列操作\"></a>5.E. 队列操作</h2><p><strong>题目描述</strong><br>三种操作：</p>\n<ul>\n<li><code>p x</code>：将数字 <code>x</code> 入队</li>\n<li><code>t</code>：输出队首元素（若为空输出 <code>no</code>）</li>\n<li><code>d</code>：删除队首元素（若为空不操作）</li>\n</ul>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行一个整数 N（1 &lt; N &lt; 200）</span><br><span class=\"line\">接下来的 N 行是操作指令</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>每次 <code>t</code> 操作输出队首元素或 <code>no</code></p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7</span><br><span class=\"line\">p 1</span><br><span class=\"line\">p 2</span><br><span class=\"line\">t</span><br><span class=\"line\">d</span><br><span class=\"line\">d</span><br><span class=\"line\">d</span><br><span class=\"line\">t</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"6-F-采药（完全背包）\"><a href=\"#6-F-采药（完全背包）\" class=\"headerlink\" title=\"6.F. 采药（完全背包）\"></a>6.F. 采药（完全背包）</h2><p><strong>题目描述</strong><br>有 n 株草药，每株采集需要 Ti 时间，价值 Vi，总共时间为 m，求最大价值。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行 t 表示测试组数</span><br><span class=\"line\">每组：</span><br><span class=\"line\">  一行两个整数 n m</span><br><span class=\"line\">  接下来 n 行每行两个整数 Ti Vi</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>每组输出一个整数，表示最大价值</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3 70</span><br><span class=\"line\">71 100</span><br><span class=\"line\">69 1</span><br><span class=\"line\">1 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"7-G-射击游戏（前缀和）\"><a href=\"#7-G-射击游戏（前缀和）\" class=\"headerlink\" title=\"7.G. 射击游戏（前缀和）\"></a>7.G. 射击游戏（前缀和）</h2><p><strong>题目描述</strong><br>有 <code>n</code> 个靶子，每个靶子需要 <code>ai</code> 发子弹，<code>m</code> 次查询，每次给定区间 <code>[L,R]</code>，求其总子弹数。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行 n（1 &lt; n &lt; 1e5）</span><br><span class=\"line\">第二行 n 个整数 ai</span><br><span class=\"line\">第三行 m（1 &lt; m &lt; 1e5）</span><br><span class=\"line\">接下来 m 行，每行两个数 L R（1-based）</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>m 行，每行一个整数，表示每次所需子弹数</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 2 3 4 5</span><br><span class=\"line\">3</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 5</span><br><span class=\"line\">3 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">15</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"8-H-二分查找\"><a href=\"#8-H-二分查找\" class=\"headerlink\" title=\"8.H. 二分查找\"></a>8.H. 二分查找</h2><p><strong>题目描述</strong><br>长度为 <code>n</code> 的非降序列，进行 <code>m</code> 次查询，每次查询给出一个整数 <code>q</code>，输出其首次出现的位置（1-based），否则输出 <code>-1</code>。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行 n m</span><br><span class=\"line\">第二行 n 个非降整数 ai</span><br><span class=\"line\">第三行 m 个整数 q</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>一行，m 个整数，用空格分隔，表示每个查询结果</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11 3</span><br><span class=\"line\">1 3 3 3 5 7 9 11 13 15 15</span><br><span class=\"line\">1 3 6</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 -1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"9-I-神奇的四次方数（DP）\"><a href=\"#9-I-神奇的四次方数（DP）\" class=\"headerlink\" title=\"9.I. 神奇的四次方数（DP）\"></a>9.I. 神奇的四次方数（DP）</h2><p><strong>题目描述</strong><br>将整数 <code>m</code> 分解为若干个四次方数之和，要求最少项数。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一行，一个整数 m（1 ≤ m ≤ 100000）</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最少项数 n</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">706</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"10-J-栈合法序列个数（卡特兰数）\"><a href=\"#10-J-栈合法序列个数（卡特兰数）\" class=\"headerlink\" title=\"10.J. 栈合法序列个数（卡特兰数）\"></a>10.J. 栈合法序列个数（卡特兰数）</h2><p><strong>题目描述</strong><br>求长度为 <code>2n</code> 的合法出栈序列个数，等价于卡特兰数 <code>C_n</code>。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一行一个整数 n（1 ≤ n ≤ 18）</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">合法序列个数</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"11-K-FBI-树（分治-后序遍历）\"><a href=\"#11-K-FBI-树（分治-后序遍历）\" class=\"headerlink\" title=\"11.K. FBI 树（分治 + 后序遍历）\"></a>11.K. FBI 树（分治 + 后序遍历）</h2><p><strong>题目描述</strong><br>给定一个长度为 <code>2^n</code> 的“01”字符串，构建 FBI 树并输出其<strong>后序遍历</strong>。</p>\n<ul>\n<li>若全是 0，则为 <code>B</code>；</li>\n<li>若全是 1，则为 <code>I</code>；</li>\n<li>否则为 <code>F</code>，其左右子树分别对应前一半和后一半。</li>\n</ul>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行一个整数 n（1 ≤ n ≤ 10）</span><br><span class=\"line\">第二行一个长度为 2^n 的 01 字符串</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">后序遍历字符串</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">10001011</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IBFBBBFIBFIIIFF</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"1-A-找良好数组\"><a href=\"#1-A-找良好数组\" class=\"headerlink\" title=\"1.A. 找良好数组\"></a>1.A. 找良好数组</h2><p><strong>题目描述</strong><br>给你一个数组 <code>a</code>，下标从 0 开始。<br>如果数组中的每个奇数下标为奇数，且每个偶数下标为偶数，则称其为“好数组”，否则为“坏数组”。<br>你可以任意交换两个元素（可以不相邻）。<br>请你判断是否可以通过最少交换变为好数组，并输出最小交换次数；若无法变成好数组，输出 <code>-1</code>。</p>\n<p><strong>输入</strong></p>\n<ul>\n<li>第一行一个整数 <code>t</code>（1 ≤ t ≤ 1000）表示测试用例组数。</li>\n<li>每组测试用例：<ul>\n<li>第一行一个整数 <code>n</code>（1 ≤ n ≤ 40）表示数组长度。</li>\n<li>第二行 <code>n</code> 个整数 <code>a0, a1, ..., an−1</code>（0 ≤ ai ≤ 1000）。</li>\n</ul>\n</li>\n</ul>\n<p><strong>输出</strong><br>每组数据输出一个整数：能变为好数组的最小交换次数，或 <code>-1</code> 表示无法实现。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">4</span><br><span class=\"line\">3 2 7 6</span><br><span class=\"line\">3</span><br><span class=\"line\">3 2 6</span><br><span class=\"line\">1</span><br><span class=\"line\">7</span><br><span class=\"line\">7</span><br><span class=\"line\">4 9 2 1 18 3 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">1</span><br><span class=\"line\">-1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"2-B-B-进制加法\"><a href=\"#2-B-B-进制加法\" class=\"headerlink\" title=\"2.B. B 进制加法\"></a>2.B. B 进制加法</h2><p><strong>题目描述</strong><br>给定一个进制 <code>B</code>（2 ≤ B ≤ 36），以及两个 <code>B</code> 进制的正整数，求它们的和（结果仍为 <code>B</code> 进制）。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第1行：进制 B</span><br><span class=\"line\">第2行：第一个 B 进制正整数</span><br><span class=\"line\">第3行：第二个 B 进制正整数</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>一个 B 进制的数，表示两个输入数的和。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">123</span><br><span class=\"line\">321</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-C-高精度五则运算\"><a href=\"#3-C-高精度五则运算\" class=\"headerlink\" title=\"3.C. 高精度五则运算\"></a>3.C. 高精度五则运算</h2><p><strong>题目描述</strong><br>输入两个大整数 A 和 B（A, B &gt; 0，长度不超过 10^4），求它们的：和、差、积、商（整除）、余。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>五行，依次输出：和、差、积、商、余。</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"4-D-栈操作\"><a href=\"#4-D-栈操作\" class=\"headerlink\" title=\"4.D. 栈操作\"></a>4.D. 栈操作</h2><p><strong>题目描述</strong><br>三种操作：</p>\n<ul>\n<li><code>p x</code>：将数字 <code>x</code> 压入栈中</li>\n<li><code>t</code>：输出栈顶元素（若栈为空输出 <code>no</code>）</li>\n<li><code>d</code>：删除栈顶元素（若栈为空不操作）</li>\n</ul>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行一个整数 N（1 &lt; N &lt; 200）</span><br><span class=\"line\">接下来的 N 行是操作指令</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>每次 <code>t</code> 操作输出栈顶元素或 <code>no</code></p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">p 2</span><br><span class=\"line\">p 1</span><br><span class=\"line\">t</span><br><span class=\"line\">d</span><br><span class=\"line\">t</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"5-E-队列操作\"><a href=\"#5-E-队列操作\" class=\"headerlink\" title=\"5.E. 队列操作\"></a>5.E. 队列操作</h2><p><strong>题目描述</strong><br>三种操作：</p>\n<ul>\n<li><code>p x</code>：将数字 <code>x</code> 入队</li>\n<li><code>t</code>：输出队首元素（若为空输出 <code>no</code>）</li>\n<li><code>d</code>：删除队首元素（若为空不操作）</li>\n</ul>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行一个整数 N（1 &lt; N &lt; 200）</span><br><span class=\"line\">接下来的 N 行是操作指令</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>每次 <code>t</code> 操作输出队首元素或 <code>no</code></p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7</span><br><span class=\"line\">p 1</span><br><span class=\"line\">p 2</span><br><span class=\"line\">t</span><br><span class=\"line\">d</span><br><span class=\"line\">d</span><br><span class=\"line\">d</span><br><span class=\"line\">t</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">no</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"6-F-采药（完全背包）\"><a href=\"#6-F-采药（完全背包）\" class=\"headerlink\" title=\"6.F. 采药（完全背包）\"></a>6.F. 采药（完全背包）</h2><p><strong>题目描述</strong><br>有 n 株草药，每株采集需要 Ti 时间，价值 Vi，总共时间为 m，求最大价值。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行 t 表示测试组数</span><br><span class=\"line\">每组：</span><br><span class=\"line\">  一行两个整数 n m</span><br><span class=\"line\">  接下来 n 行每行两个整数 Ti Vi</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>每组输出一个整数，表示最大价值</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3 70</span><br><span class=\"line\">71 100</span><br><span class=\"line\">69 1</span><br><span class=\"line\">1 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"7-G-射击游戏（前缀和）\"><a href=\"#7-G-射击游戏（前缀和）\" class=\"headerlink\" title=\"7.G. 射击游戏（前缀和）\"></a>7.G. 射击游戏（前缀和）</h2><p><strong>题目描述</strong><br>有 <code>n</code> 个靶子，每个靶子需要 <code>ai</code> 发子弹，<code>m</code> 次查询，每次给定区间 <code>[L,R]</code>，求其总子弹数。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行 n（1 &lt; n &lt; 1e5）</span><br><span class=\"line\">第二行 n 个整数 ai</span><br><span class=\"line\">第三行 m（1 &lt; m &lt; 1e5）</span><br><span class=\"line\">接下来 m 行，每行两个数 L R（1-based）</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>m 行，每行一个整数，表示每次所需子弹数</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 2 3 4 5</span><br><span class=\"line\">3</span><br><span class=\"line\">1 2</span><br><span class=\"line\">1 5</span><br><span class=\"line\">3 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">15</span><br><span class=\"line\">12</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"8-H-二分查找\"><a href=\"#8-H-二分查找\" class=\"headerlink\" title=\"8.H. 二分查找\"></a>8.H. 二分查找</h2><p><strong>题目描述</strong><br>长度为 <code>n</code> 的非降序列，进行 <code>m</code> 次查询，每次查询给出一个整数 <code>q</code>，输出其首次出现的位置（1-based），否则输出 <code>-1</code>。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行 n m</span><br><span class=\"line\">第二行 n 个非降整数 ai</span><br><span class=\"line\">第三行 m 个整数 q</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong><br>一行，m 个整数，用空格分隔，表示每个查询结果</p>\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11 3</span><br><span class=\"line\">1 3 3 3 5 7 9 11 13 15 15</span><br><span class=\"line\">1 3 6</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 2 -1</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"9-I-神奇的四次方数（DP）\"><a href=\"#9-I-神奇的四次方数（DP）\" class=\"headerlink\" title=\"9.I. 神奇的四次方数（DP）\"></a>9.I. 神奇的四次方数（DP）</h2><p><strong>题目描述</strong><br>将整数 <code>m</code> 分解为若干个四次方数之和，要求最少项数。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一行，一个整数 m（1 ≤ m ≤ 100000）</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最少项数 n</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">706</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"10-J-栈合法序列个数（卡特兰数）\"><a href=\"#10-J-栈合法序列个数（卡特兰数）\" class=\"headerlink\" title=\"10.J. 栈合法序列个数（卡特兰数）\"></a>10.J. 栈合法序列个数（卡特兰数）</h2><p><strong>题目描述</strong><br>求长度为 <code>2n</code> 的合法出栈序列个数，等价于卡特兰数 <code>C_n</code>。</p>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一行一个整数 n（1 ≤ n ≤ 18）</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">合法序列个数</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"11-K-FBI-树（分治-后序遍历）\"><a href=\"#11-K-FBI-树（分治-后序遍历）\" class=\"headerlink\" title=\"11.K. FBI 树（分治 + 后序遍历）\"></a>11.K. FBI 树（分治 + 后序遍历）</h2><p><strong>题目描述</strong><br>给定一个长度为 <code>2^n</code> 的“01”字符串，构建 FBI 树并输出其<strong>后序遍历</strong>。</p>\n<ul>\n<li>若全是 0，则为 <code>B</code>；</li>\n<li>若全是 1，则为 <code>I</code>；</li>\n<li>否则为 <code>F</code>，其左右子树分别对应前一半和后一半。</li>\n</ul>\n<p><strong>输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一行一个整数 n（1 ≤ n ≤ 10）</span><br><span class=\"line\">第二行一个长度为 2^n 的 01 字符串</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">后序遍历字符串</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">10001011</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IBFBBBFIBFIIIFF</span><br></pre></td></tr></table></figure>\n"},{"title":"ACM 算法入门 · 搜索篇：优化向","date":"2025-07-25T01:17:38.000Z","_content":"\n# 🧭 ACM 算法入门 · 搜索篇（优化向）\n\n本篇将带你从搜索算法基础出发，结合实战与技巧，掌握高效的搜索策略与代码实现。\n\n---\n\n## 1️⃣ 什么是搜索算法？\n\n搜索算法是一种通过穷举可能状态，寻找满足条件解的算法方式。\n\n> 搜索过程 = **构造解答树 + 找到目标节点**\n\n它利用计算机的高性能，遍历问题的状态空间，找到通向目标的路径或解。\n\n---\n\n## 2️⃣ 深度优先搜索（DFS）\n\n### 🔍 定义\n\n深度优先搜索（Depth First Search）是一种回溯型搜索方法，形象比喻为“不撞南墙不回头”。\n\n### 🧠 原理说明\n\n- 从某个起点出发，尝试所有可能路径\n- 沿路径深入，直到到达终点或走不通\n- 回溯，换一条路径再试\n\n### ✨ 搜索流程：\n\n1. 标记当前位置为“已走”\n2. 遍历四个方向 / 所有可能状态\n3. 若合法、未访问 -> 递归进入\n4. 回溯：搜索完该路径后恢复现场\n\n### 🧩 示例场景：\n\n从起点 `A` 出发，目标是到达 `G`，若有多个路径，通过 DFS 可遍历所有可能路径。\n\n### 📦 模板代码\n\n```cpp\nvoid dfs(int x, int y) {\n    if (到达终点) {\n        更新最优解;\n        return;\n    }\n    for (每一个方向) {\n        if (新坐标合法且未访问) {\n            标记已访问;\n            dfs(新位置);\n            恢复现场; // 回溯\n        }\n    }\n}\n```\n\n### 📌 示例题（DFS）\n\n```cpp\n#include <stdio.h>\nint n, m;\nchar mp[51][51];\nint vis[51][51];\nint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1};\nint ans = 0, step = 0, min = 999999;\n\nvoid dfs(int x, int y, int step) {\n    if (x < 0 || x >= n || y < 0 || y >= m) return;\n    if (x == n - 1 && y == m - 1) {\n        ans = 1;\n        if (step < min) min = step;\n        return;\n    }\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (mp[nx][ny] == '*' && vis[nx][ny] == 0) {\n            vis[nx][ny] = 1;\n            dfs(nx, ny, step + 1);\n            vis[nx][ny] = 0;\n        }\n    }\n}\n```\n\n---\n\n## 3️⃣ 广度优先搜索（BFS）\n\n### 📘 定义\n\nBFS（Breadth First Search）是一种层级遍历策略，适合用于求**最短路径问题**。\n\n- 每次将当前层所有状态展开\n- 下一层再由当前层所有节点扩展而来\n- 利用**队列**实现（先进先出）\n\n### 🧠 应用举例：社交网络芒果商人问题\n\n- 从你出发，查找朋友是否是芒果销售商\n- 如果没有，再查找朋友的朋友\n- 用队列管理待查人，用集合标记访问过的人\n\n### 🧊 模板代码（最短路径）\n\n```cpp\nstruct Node {\n    int x, y, step;\n};\n\nint bfs() {\n    queue<Node> q;\n    q.push({0, 0, 0});\n    vis[0][0] = 1;\n\n    while (!q.empty()) {\n        Node f = q.front(); q.pop();\n\n        if (f.x == n-1 && f.y == m-1) return f.step;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = f.x + dx[i], ny = f.y + dy[i];\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\n            if (mp[nx][ny] == '*' && vis[nx][ny] == 0) {\n                vis[nx][ny] = 1;\n                q.push({nx, ny, f.step + 1});\n            }\n        }\n    }\n}\n```\n\n### ✅ BFS 特点：\n\n- 每一层搜索结果都是之前状态的基础\n- 一旦到达目标，**即为最短路径**\n- 缺点：空间大（需要存储整个搜索层）\n\n---\n\n## 4️⃣ 搜索进阶策略一览\n\n| 技术           | 描述                                   |\n| -------------- | -------------------------------------- |\n| 剪枝           | 提前排除非法或不必要的状态             |\n| 双向 BFS       | 从起点和终点同时扩展，降低搜索深度     |\n| A\\* 启发式搜索 | 利用估价函数 f(n)=g(n)+h(n) 定向搜索   |\n| IDDFS          | 迭代加深 DFS，适合空间紧张且目标层较深 |\n| 回溯法         | DFS 基础上加状态恢复操作，用于组合枚举 |\n\n---\n\n## 5️⃣ 搜索剪枝与优化技巧\n\n### 🔪 剪枝分类：\n\n1. **边界条件剪枝**：越界、重复访问\n2. **最优性剪枝**：当前路径代价超过已知最优\n3. **哈希状态压缩**：如 bitmask 表示状态，节省内存\n4. **路径排序（贪心 DFS）**：优先尝试可能更优的路径\n\n---\n\n## 6️⃣ 搜索算法对比\n\n| 算法     | 是否最短路径 | 空间复杂度 | 适用场景           |\n| -------- | ------------ | ---------- | ------------------ |\n| DFS      | 否           | O(depth)   | 所有路径，组合枚举 |\n| BFS      | 是           | O(n^2)     | 最短路径问题       |\n| 双向 BFS | 是           | O(n)       | 图结构路径问题     |\n| A\\*      | 是           | O(n log n) | 图搜索+启发函数    |\n| 回溯法   | 否（需配合） | O(n)       | 子集/排列类问题    |\n\n---\n\n## 🧠 小结\n\n搜索是所有算法题的基石，而搜索优化正是通向高效解法的关键。\n\n掌握以下内容：\n\n- DFS/BFS 实现与应用\n- 剪枝与回溯技巧\n- 搜索路径记录与状态设计\n- 进阶搜索方法（A\\*, IDDFS, 双向 BFS）\n\n---\n\n## 🔗 拓展阅读\n\n- 《算法竞赛入门经典》\n- 《算法图解》 by Aditya Bhargava\n- [ACWing 搜索专题](https://www.acwing.com/problem/)\n","source":"_posts/09-ACM-algorithm-search.md","raw":"---\ntitle: ACM 算法入门 · 搜索篇：优化向\ndate: 2025-07-25 09:17:38\ntags:\n  - 贪心算法\n  - ACM竞赛入门算法\ncategories:\n  - 算法入门\n---\n\n# 🧭 ACM 算法入门 · 搜索篇（优化向）\n\n本篇将带你从搜索算法基础出发，结合实战与技巧，掌握高效的搜索策略与代码实现。\n\n---\n\n## 1️⃣ 什么是搜索算法？\n\n搜索算法是一种通过穷举可能状态，寻找满足条件解的算法方式。\n\n> 搜索过程 = **构造解答树 + 找到目标节点**\n\n它利用计算机的高性能，遍历问题的状态空间，找到通向目标的路径或解。\n\n---\n\n## 2️⃣ 深度优先搜索（DFS）\n\n### 🔍 定义\n\n深度优先搜索（Depth First Search）是一种回溯型搜索方法，形象比喻为“不撞南墙不回头”。\n\n### 🧠 原理说明\n\n- 从某个起点出发，尝试所有可能路径\n- 沿路径深入，直到到达终点或走不通\n- 回溯，换一条路径再试\n\n### ✨ 搜索流程：\n\n1. 标记当前位置为“已走”\n2. 遍历四个方向 / 所有可能状态\n3. 若合法、未访问 -> 递归进入\n4. 回溯：搜索完该路径后恢复现场\n\n### 🧩 示例场景：\n\n从起点 `A` 出发，目标是到达 `G`，若有多个路径，通过 DFS 可遍历所有可能路径。\n\n### 📦 模板代码\n\n```cpp\nvoid dfs(int x, int y) {\n    if (到达终点) {\n        更新最优解;\n        return;\n    }\n    for (每一个方向) {\n        if (新坐标合法且未访问) {\n            标记已访问;\n            dfs(新位置);\n            恢复现场; // 回溯\n        }\n    }\n}\n```\n\n### 📌 示例题（DFS）\n\n```cpp\n#include <stdio.h>\nint n, m;\nchar mp[51][51];\nint vis[51][51];\nint dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, 1, -1};\nint ans = 0, step = 0, min = 999999;\n\nvoid dfs(int x, int y, int step) {\n    if (x < 0 || x >= n || y < 0 || y >= m) return;\n    if (x == n - 1 && y == m - 1) {\n        ans = 1;\n        if (step < min) min = step;\n        return;\n    }\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (mp[nx][ny] == '*' && vis[nx][ny] == 0) {\n            vis[nx][ny] = 1;\n            dfs(nx, ny, step + 1);\n            vis[nx][ny] = 0;\n        }\n    }\n}\n```\n\n---\n\n## 3️⃣ 广度优先搜索（BFS）\n\n### 📘 定义\n\nBFS（Breadth First Search）是一种层级遍历策略，适合用于求**最短路径问题**。\n\n- 每次将当前层所有状态展开\n- 下一层再由当前层所有节点扩展而来\n- 利用**队列**实现（先进先出）\n\n### 🧠 应用举例：社交网络芒果商人问题\n\n- 从你出发，查找朋友是否是芒果销售商\n- 如果没有，再查找朋友的朋友\n- 用队列管理待查人，用集合标记访问过的人\n\n### 🧊 模板代码（最短路径）\n\n```cpp\nstruct Node {\n    int x, y, step;\n};\n\nint bfs() {\n    queue<Node> q;\n    q.push({0, 0, 0});\n    vis[0][0] = 1;\n\n    while (!q.empty()) {\n        Node f = q.front(); q.pop();\n\n        if (f.x == n-1 && f.y == m-1) return f.step;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = f.x + dx[i], ny = f.y + dy[i];\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\n            if (mp[nx][ny] == '*' && vis[nx][ny] == 0) {\n                vis[nx][ny] = 1;\n                q.push({nx, ny, f.step + 1});\n            }\n        }\n    }\n}\n```\n\n### ✅ BFS 特点：\n\n- 每一层搜索结果都是之前状态的基础\n- 一旦到达目标，**即为最短路径**\n- 缺点：空间大（需要存储整个搜索层）\n\n---\n\n## 4️⃣ 搜索进阶策略一览\n\n| 技术           | 描述                                   |\n| -------------- | -------------------------------------- |\n| 剪枝           | 提前排除非法或不必要的状态             |\n| 双向 BFS       | 从起点和终点同时扩展，降低搜索深度     |\n| A\\* 启发式搜索 | 利用估价函数 f(n)=g(n)+h(n) 定向搜索   |\n| IDDFS          | 迭代加深 DFS，适合空间紧张且目标层较深 |\n| 回溯法         | DFS 基础上加状态恢复操作，用于组合枚举 |\n\n---\n\n## 5️⃣ 搜索剪枝与优化技巧\n\n### 🔪 剪枝分类：\n\n1. **边界条件剪枝**：越界、重复访问\n2. **最优性剪枝**：当前路径代价超过已知最优\n3. **哈希状态压缩**：如 bitmask 表示状态，节省内存\n4. **路径排序（贪心 DFS）**：优先尝试可能更优的路径\n\n---\n\n## 6️⃣ 搜索算法对比\n\n| 算法     | 是否最短路径 | 空间复杂度 | 适用场景           |\n| -------- | ------------ | ---------- | ------------------ |\n| DFS      | 否           | O(depth)   | 所有路径，组合枚举 |\n| BFS      | 是           | O(n^2)     | 最短路径问题       |\n| 双向 BFS | 是           | O(n)       | 图结构路径问题     |\n| A\\*      | 是           | O(n log n) | 图搜索+启发函数    |\n| 回溯法   | 否（需配合） | O(n)       | 子集/排列类问题    |\n\n---\n\n## 🧠 小结\n\n搜索是所有算法题的基石，而搜索优化正是通向高效解法的关键。\n\n掌握以下内容：\n\n- DFS/BFS 实现与应用\n- 剪枝与回溯技巧\n- 搜索路径记录与状态设计\n- 进阶搜索方法（A\\*, IDDFS, 双向 BFS）\n\n---\n\n## 🔗 拓展阅读\n\n- 《算法竞赛入门经典》\n- 《算法图解》 by Aditya Bhargava\n- [ACWing 搜索专题](https://www.acwing.com/problem/)\n","slug":"09-ACM-algorithm-search","published":1,"updated":"2025-07-09T01:21:36.198Z","comments":1,"layout":"post","photos":[],"_id":"cmcvbtktp000414nf645215d1","content":"<h1 id=\"🧭-ACM-算法入门-·-搜索篇（优化向）\"><a href=\"#🧭-ACM-算法入门-·-搜索篇（优化向）\" class=\"headerlink\" title=\"🧭 ACM 算法入门 · 搜索篇（优化向）\"></a>🧭 ACM 算法入门 · 搜索篇（优化向）</h1><p>本篇将带你从搜索算法基础出发，结合实战与技巧，掌握高效的搜索策略与代码实现。</p>\n<hr>\n<h2 id=\"1️⃣-什么是搜索算法？\"><a href=\"#1️⃣-什么是搜索算法？\" class=\"headerlink\" title=\"1️⃣ 什么是搜索算法？\"></a>1️⃣ 什么是搜索算法？</h2><p>搜索算法是一种通过穷举可能状态，寻找满足条件解的算法方式。</p>\n<blockquote>\n<p>搜索过程 &#x3D; <strong>构造解答树 + 找到目标节点</strong></p>\n</blockquote>\n<p>它利用计算机的高性能，遍历问题的状态空间，找到通向目标的路径或解。</p>\n<hr>\n<h2 id=\"2️⃣-深度优先搜索（DFS）\"><a href=\"#2️⃣-深度优先搜索（DFS）\" class=\"headerlink\" title=\"2️⃣ 深度优先搜索（DFS）\"></a>2️⃣ 深度优先搜索（DFS）</h2><h3 id=\"🔍-定义\"><a href=\"#🔍-定义\" class=\"headerlink\" title=\"🔍 定义\"></a>🔍 定义</h3><p>深度优先搜索（Depth First Search）是一种回溯型搜索方法，形象比喻为“不撞南墙不回头”。</p>\n<h3 id=\"🧠-原理说明\"><a href=\"#🧠-原理说明\" class=\"headerlink\" title=\"🧠 原理说明\"></a>🧠 原理说明</h3><ul>\n<li>从某个起点出发，尝试所有可能路径</li>\n<li>沿路径深入，直到到达终点或走不通</li>\n<li>回溯，换一条路径再试</li>\n</ul>\n<h3 id=\"✨-搜索流程：\"><a href=\"#✨-搜索流程：\" class=\"headerlink\" title=\"✨ 搜索流程：\"></a>✨ 搜索流程：</h3><ol>\n<li>标记当前位置为“已走”</li>\n<li>遍历四个方向 &#x2F; 所有可能状态</li>\n<li>若合法、未访问 -&gt; 递归进入</li>\n<li>回溯：搜索完该路径后恢复现场</li>\n</ol>\n<h3 id=\"🧩-示例场景：\"><a href=\"#🧩-示例场景：\" class=\"headerlink\" title=\"🧩 示例场景：\"></a>🧩 示例场景：</h3><p>从起点 <code>A</code> 出发，目标是到达 <code>G</code>，若有多个路径，通过 DFS 可遍历所有可能路径。</p>\n<h3 id=\"📦-模板代码\"><a href=\"#📦-模板代码\" class=\"headerlink\" title=\"📦 模板代码\"></a>📦 模板代码</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (到达终点) &#123;</span><br><span class=\"line\">        更新最优解;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (每一个方向) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (新坐标合法且未访问) &#123;</span><br><span class=\"line\">            标记已访问;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(新位置);</span><br><span class=\"line\">            恢复现场; <span class=\"comment\">// 回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📌-示例题（DFS）\"><a href=\"#📌-示例题（DFS）\" class=\"headerlink\" title=\"📌 示例题（DFS）\"></a>📌 示例题（DFS）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">char</span> mp[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>, step = <span class=\"number\">0</span>, min = <span class=\"number\">999999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> step)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step &lt; min) min = step;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mp[nx][ny] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; vis[nx][ny] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            vis[nx][ny] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(nx, ny, step + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[nx][ny] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3️⃣-广度优先搜索（BFS）\"><a href=\"#3️⃣-广度优先搜索（BFS）\" class=\"headerlink\" title=\"3️⃣ 广度优先搜索（BFS）\"></a>3️⃣ 广度优先搜索（BFS）</h2><h3 id=\"📘-定义\"><a href=\"#📘-定义\" class=\"headerlink\" title=\"📘 定义\"></a>📘 定义</h3><p>BFS（Breadth First Search）是一种层级遍历策略，适合用于求<strong>最短路径问题</strong>。</p>\n<ul>\n<li>每次将当前层所有状态展开</li>\n<li>下一层再由当前层所有节点扩展而来</li>\n<li>利用<strong>队列</strong>实现（先进先出）</li>\n</ul>\n<h3 id=\"🧠-应用举例：社交网络芒果商人问题\"><a href=\"#🧠-应用举例：社交网络芒果商人问题\" class=\"headerlink\" title=\"🧠 应用举例：社交网络芒果商人问题\"></a>🧠 应用举例：社交网络芒果商人问题</h3><ul>\n<li>从你出发，查找朋友是否是芒果销售商</li>\n<li>如果没有，再查找朋友的朋友</li>\n<li>用队列管理待查人，用集合标记访问过的人</li>\n</ul>\n<h3 id=\"🧊-模板代码（最短路径）\"><a href=\"#🧊-模板代码（最短路径）\" class=\"headerlink\" title=\"🧊 模板代码（最短路径）\"></a>🧊 模板代码（最短路径）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y, step;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;Node&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">    vis[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        Node f = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f.x == n<span class=\"number\">-1</span> &amp;&amp; f.y == m<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> f.step;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= n || ny &gt;= m) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp[nx][ny] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; vis[nx][ny] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                vis[nx][ny] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(&#123;nx, ny, f.step + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"✅-BFS-特点：\"><a href=\"#✅-BFS-特点：\" class=\"headerlink\" title=\"✅ BFS 特点：\"></a>✅ BFS 特点：</h3><ul>\n<li>每一层搜索结果都是之前状态的基础</li>\n<li>一旦到达目标，<strong>即为最短路径</strong></li>\n<li>缺点：空间大（需要存储整个搜索层）</li>\n</ul>\n<hr>\n<h2 id=\"4️⃣-搜索进阶策略一览\"><a href=\"#4️⃣-搜索进阶策略一览\" class=\"headerlink\" title=\"4️⃣ 搜索进阶策略一览\"></a>4️⃣ 搜索进阶策略一览</h2><table>\n<thead>\n<tr>\n<th>技术</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>剪枝</td>\n<td>提前排除非法或不必要的状态</td>\n</tr>\n<tr>\n<td>双向 BFS</td>\n<td>从起点和终点同时扩展，降低搜索深度</td>\n</tr>\n<tr>\n<td>A* 启发式搜索</td>\n<td>利用估价函数 f(n)&#x3D;g(n)+h(n) 定向搜索</td>\n</tr>\n<tr>\n<td>IDDFS</td>\n<td>迭代加深 DFS，适合空间紧张且目标层较深</td>\n</tr>\n<tr>\n<td>回溯法</td>\n<td>DFS 基础上加状态恢复操作，用于组合枚举</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"5️⃣-搜索剪枝与优化技巧\"><a href=\"#5️⃣-搜索剪枝与优化技巧\" class=\"headerlink\" title=\"5️⃣ 搜索剪枝与优化技巧\"></a>5️⃣ 搜索剪枝与优化技巧</h2><h3 id=\"🔪-剪枝分类：\"><a href=\"#🔪-剪枝分类：\" class=\"headerlink\" title=\"🔪 剪枝分类：\"></a>🔪 剪枝分类：</h3><ol>\n<li><strong>边界条件剪枝</strong>：越界、重复访问</li>\n<li><strong>最优性剪枝</strong>：当前路径代价超过已知最优</li>\n<li><strong>哈希状态压缩</strong>：如 bitmask 表示状态，节省内存</li>\n<li><strong>路径排序（贪心 DFS）</strong>：优先尝试可能更优的路径</li>\n</ol>\n<hr>\n<h2 id=\"6️⃣-搜索算法对比\"><a href=\"#6️⃣-搜索算法对比\" class=\"headerlink\" title=\"6️⃣ 搜索算法对比\"></a>6️⃣ 搜索算法对比</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>是否最短路径</th>\n<th>空间复杂度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DFS</td>\n<td>否</td>\n<td>O(depth)</td>\n<td>所有路径，组合枚举</td>\n</tr>\n<tr>\n<td>BFS</td>\n<td>是</td>\n<td>O(n^2)</td>\n<td>最短路径问题</td>\n</tr>\n<tr>\n<td>双向 BFS</td>\n<td>是</td>\n<td>O(n)</td>\n<td>图结构路径问题</td>\n</tr>\n<tr>\n<td>A*</td>\n<td>是</td>\n<td>O(n log n)</td>\n<td>图搜索+启发函数</td>\n</tr>\n<tr>\n<td>回溯法</td>\n<td>否（需配合）</td>\n<td>O(n)</td>\n<td>子集&#x2F;排列类问题</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧠-小结\"><a href=\"#🧠-小结\" class=\"headerlink\" title=\"🧠 小结\"></a>🧠 小结</h2><p>搜索是所有算法题的基石，而搜索优化正是通向高效解法的关键。</p>\n<p>掌握以下内容：</p>\n<ul>\n<li>DFS&#x2F;BFS 实现与应用</li>\n<li>剪枝与回溯技巧</li>\n<li>搜索路径记录与状态设计</li>\n<li>进阶搜索方法（A*, IDDFS, 双向 BFS）</li>\n</ul>\n<hr>\n<h2 id=\"🔗-拓展阅读\"><a href=\"#🔗-拓展阅读\" class=\"headerlink\" title=\"🔗 拓展阅读\"></a>🔗 拓展阅读</h2><ul>\n<li>《算法竞赛入门经典》</li>\n<li>《算法图解》 by Aditya Bhargava</li>\n<li><a href=\"https://www.acwing.com/problem/\">ACWing 搜索专题</a></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"🧭-ACM-算法入门-·-搜索篇（优化向）\"><a href=\"#🧭-ACM-算法入门-·-搜索篇（优化向）\" class=\"headerlink\" title=\"🧭 ACM 算法入门 · 搜索篇（优化向）\"></a>🧭 ACM 算法入门 · 搜索篇（优化向）</h1><p>本篇将带你从搜索算法基础出发，结合实战与技巧，掌握高效的搜索策略与代码实现。</p>\n<hr>\n<h2 id=\"1️⃣-什么是搜索算法？\"><a href=\"#1️⃣-什么是搜索算法？\" class=\"headerlink\" title=\"1️⃣ 什么是搜索算法？\"></a>1️⃣ 什么是搜索算法？</h2><p>搜索算法是一种通过穷举可能状态，寻找满足条件解的算法方式。</p>\n<blockquote>\n<p>搜索过程 &#x3D; <strong>构造解答树 + 找到目标节点</strong></p>\n</blockquote>\n<p>它利用计算机的高性能，遍历问题的状态空间，找到通向目标的路径或解。</p>\n<hr>\n<h2 id=\"2️⃣-深度优先搜索（DFS）\"><a href=\"#2️⃣-深度优先搜索（DFS）\" class=\"headerlink\" title=\"2️⃣ 深度优先搜索（DFS）\"></a>2️⃣ 深度优先搜索（DFS）</h2><h3 id=\"🔍-定义\"><a href=\"#🔍-定义\" class=\"headerlink\" title=\"🔍 定义\"></a>🔍 定义</h3><p>深度优先搜索（Depth First Search）是一种回溯型搜索方法，形象比喻为“不撞南墙不回头”。</p>\n<h3 id=\"🧠-原理说明\"><a href=\"#🧠-原理说明\" class=\"headerlink\" title=\"🧠 原理说明\"></a>🧠 原理说明</h3><ul>\n<li>从某个起点出发，尝试所有可能路径</li>\n<li>沿路径深入，直到到达终点或走不通</li>\n<li>回溯，换一条路径再试</li>\n</ul>\n<h3 id=\"✨-搜索流程：\"><a href=\"#✨-搜索流程：\" class=\"headerlink\" title=\"✨ 搜索流程：\"></a>✨ 搜索流程：</h3><ol>\n<li>标记当前位置为“已走”</li>\n<li>遍历四个方向 &#x2F; 所有可能状态</li>\n<li>若合法、未访问 -&gt; 递归进入</li>\n<li>回溯：搜索完该路径后恢复现场</li>\n</ol>\n<h3 id=\"🧩-示例场景：\"><a href=\"#🧩-示例场景：\" class=\"headerlink\" title=\"🧩 示例场景：\"></a>🧩 示例场景：</h3><p>从起点 <code>A</code> 出发，目标是到达 <code>G</code>，若有多个路径，通过 DFS 可遍历所有可能路径。</p>\n<h3 id=\"📦-模板代码\"><a href=\"#📦-模板代码\" class=\"headerlink\" title=\"📦 模板代码\"></a>📦 模板代码</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (到达终点) &#123;</span><br><span class=\"line\">        更新最优解;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (每一个方向) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (新坐标合法且未访问) &#123;</span><br><span class=\"line\">            标记已访问;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(新位置);</span><br><span class=\"line\">            恢复现场; <span class=\"comment\">// 回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"📌-示例题（DFS）\"><a href=\"#📌-示例题（DFS）\" class=\"headerlink\" title=\"📌 示例题（DFS）\"></a>📌 示例题（DFS）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">char</span> mp[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">51</span>][<span class=\"number\">51</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;, dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> ans = <span class=\"number\">0</span>, step = <span class=\"number\">0</span>, min = <span class=\"number\">999999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> step)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step &lt; min) min = step;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mp[nx][ny] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; vis[nx][ny] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            vis[nx][ny] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(nx, ny, step + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[nx][ny] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3️⃣-广度优先搜索（BFS）\"><a href=\"#3️⃣-广度优先搜索（BFS）\" class=\"headerlink\" title=\"3️⃣ 广度优先搜索（BFS）\"></a>3️⃣ 广度优先搜索（BFS）</h2><h3 id=\"📘-定义\"><a href=\"#📘-定义\" class=\"headerlink\" title=\"📘 定义\"></a>📘 定义</h3><p>BFS（Breadth First Search）是一种层级遍历策略，适合用于求<strong>最短路径问题</strong>。</p>\n<ul>\n<li>每次将当前层所有状态展开</li>\n<li>下一层再由当前层所有节点扩展而来</li>\n<li>利用<strong>队列</strong>实现（先进先出）</li>\n</ul>\n<h3 id=\"🧠-应用举例：社交网络芒果商人问题\"><a href=\"#🧠-应用举例：社交网络芒果商人问题\" class=\"headerlink\" title=\"🧠 应用举例：社交网络芒果商人问题\"></a>🧠 应用举例：社交网络芒果商人问题</h3><ul>\n<li>从你出发，查找朋友是否是芒果销售商</li>\n<li>如果没有，再查找朋友的朋友</li>\n<li>用队列管理待查人，用集合标记访问过的人</li>\n</ul>\n<h3 id=\"🧊-模板代码（最短路径）\"><a href=\"#🧊-模板代码（最短路径）\" class=\"headerlink\" title=\"🧊 模板代码（最短路径）\"></a>🧊 模板代码（最短路径）</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y, step;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;Node&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">    vis[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        Node f = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f.x == n<span class=\"number\">-1</span> &amp;&amp; f.y == m<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> f.step;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nx = f.x + dx[i], ny = f.y + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nx &lt; <span class=\"number\">0</span> || ny &lt; <span class=\"number\">0</span> || nx &gt;= n || ny &gt;= m) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mp[nx][ny] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; vis[nx][ny] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                vis[nx][ny] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(&#123;nx, ny, f.step + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"✅-BFS-特点：\"><a href=\"#✅-BFS-特点：\" class=\"headerlink\" title=\"✅ BFS 特点：\"></a>✅ BFS 特点：</h3><ul>\n<li>每一层搜索结果都是之前状态的基础</li>\n<li>一旦到达目标，<strong>即为最短路径</strong></li>\n<li>缺点：空间大（需要存储整个搜索层）</li>\n</ul>\n<hr>\n<h2 id=\"4️⃣-搜索进阶策略一览\"><a href=\"#4️⃣-搜索进阶策略一览\" class=\"headerlink\" title=\"4️⃣ 搜索进阶策略一览\"></a>4️⃣ 搜索进阶策略一览</h2><table>\n<thead>\n<tr>\n<th>技术</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>剪枝</td>\n<td>提前排除非法或不必要的状态</td>\n</tr>\n<tr>\n<td>双向 BFS</td>\n<td>从起点和终点同时扩展，降低搜索深度</td>\n</tr>\n<tr>\n<td>A* 启发式搜索</td>\n<td>利用估价函数 f(n)&#x3D;g(n)+h(n) 定向搜索</td>\n</tr>\n<tr>\n<td>IDDFS</td>\n<td>迭代加深 DFS，适合空间紧张且目标层较深</td>\n</tr>\n<tr>\n<td>回溯法</td>\n<td>DFS 基础上加状态恢复操作，用于组合枚举</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"5️⃣-搜索剪枝与优化技巧\"><a href=\"#5️⃣-搜索剪枝与优化技巧\" class=\"headerlink\" title=\"5️⃣ 搜索剪枝与优化技巧\"></a>5️⃣ 搜索剪枝与优化技巧</h2><h3 id=\"🔪-剪枝分类：\"><a href=\"#🔪-剪枝分类：\" class=\"headerlink\" title=\"🔪 剪枝分类：\"></a>🔪 剪枝分类：</h3><ol>\n<li><strong>边界条件剪枝</strong>：越界、重复访问</li>\n<li><strong>最优性剪枝</strong>：当前路径代价超过已知最优</li>\n<li><strong>哈希状态压缩</strong>：如 bitmask 表示状态，节省内存</li>\n<li><strong>路径排序（贪心 DFS）</strong>：优先尝试可能更优的路径</li>\n</ol>\n<hr>\n<h2 id=\"6️⃣-搜索算法对比\"><a href=\"#6️⃣-搜索算法对比\" class=\"headerlink\" title=\"6️⃣ 搜索算法对比\"></a>6️⃣ 搜索算法对比</h2><table>\n<thead>\n<tr>\n<th>算法</th>\n<th>是否最短路径</th>\n<th>空间复杂度</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DFS</td>\n<td>否</td>\n<td>O(depth)</td>\n<td>所有路径，组合枚举</td>\n</tr>\n<tr>\n<td>BFS</td>\n<td>是</td>\n<td>O(n^2)</td>\n<td>最短路径问题</td>\n</tr>\n<tr>\n<td>双向 BFS</td>\n<td>是</td>\n<td>O(n)</td>\n<td>图结构路径问题</td>\n</tr>\n<tr>\n<td>A*</td>\n<td>是</td>\n<td>O(n log n)</td>\n<td>图搜索+启发函数</td>\n</tr>\n<tr>\n<td>回溯法</td>\n<td>否（需配合）</td>\n<td>O(n)</td>\n<td>子集&#x2F;排列类问题</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"🧠-小结\"><a href=\"#🧠-小结\" class=\"headerlink\" title=\"🧠 小结\"></a>🧠 小结</h2><p>搜索是所有算法题的基石，而搜索优化正是通向高效解法的关键。</p>\n<p>掌握以下内容：</p>\n<ul>\n<li>DFS&#x2F;BFS 实现与应用</li>\n<li>剪枝与回溯技巧</li>\n<li>搜索路径记录与状态设计</li>\n<li>进阶搜索方法（A*, IDDFS, 双向 BFS）</li>\n</ul>\n<hr>\n<h2 id=\"🔗-拓展阅读\"><a href=\"#🔗-拓展阅读\" class=\"headerlink\" title=\"🔗 拓展阅读\"></a>🔗 拓展阅读</h2><ul>\n<li>《算法竞赛入门经典》</li>\n<li>《算法图解》 by Aditya Bhargava</li>\n<li><a href=\"https://www.acwing.com/problem/\">ACWing 搜索专题</a></li>\n</ul>\n"},{"title":"桂林电子科技大学 ACM 暑假课 | 7 月 22 日 ACM 作业题解","date":"2025-07-22T00:43:21.000Z","_content":"\n## A: 讲故事\n\n**题目描述：**\n\n一天，天上掉下来了一个可爱的小妹妹，小妹妹天天缠着你给她讲故事。并且让你在 N 天内给她讲 K(K ≤ N)个不同小故事。你把你知道的所有 K 个故事从 1 到 K 进行编号。她每天会要求你讲某一个小故事，例如第 i 天她会要求你给他讲第 ai 个小故事。\n\n由于小妹妹有间歇性失忆，所以她可能会在一些天内要求你讲你已经讲过的故事。如果你每天都按照她的要求来的话，可能会出现无法在 N 天内讲完 K 个故事的情况(小妹妹可能没有要求过讲某个故事)\n\n你为了完成任务可能在某些情况下，不得不拒绝她的要求，给她讲其他的小故事。但是你在第 i 天拒绝了小妹妹的请求的话，小妹妹对你的好感度就会下降 b\n\n如何在降低最小好感度的情况下在 N 天内讲完 K 给小故事。请输出最少降低的好感度。\n\n**输入：**\n\n- 第一行两个正整数，N K (1≤ K ≤N ≤ 10^5) N 为总天数，K 为需要讲述的故事个数\n\n- 第二行 N 个正整数 a1 a2 …… an (1 ≤ ai ≤ k) 第 n 天要求的故事序号\n\n- 第三行 N 个正整数 b1 b2 …… bn(1 ≤ bi ≤ 10^9) 第 i 天拒绝要求降低的好感度\n\n**输出：**\n\n一行，**满足条件**的前提下最少降低的好感度。\n\n**样例输入：**\n\n```text\n8 7\n1 1 3 1 5 3 7 1\n5 7 4 8 1 3 5 2\n```\n\n**样例输出：**\n\n```text\n10\n```\n\n**提示：**\n\n- 对样例一，最佳的方案是在 1, 6, 8 天把故事改为 2, 4, 6 号，降低的好感度为 a1 + a6 + a8 = 5 + 3 + 2 = 10\n\n- 对样例二，不需要做调整\n\n**参考程序：**\n\n```C\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nstruct data_p{int a;ll b;}num[100005];\nint n,k,maxl[100005],now=0;\nll ans;\nbool cmp(data_p x,data_p y){return x.b<y.b;}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&num[i].a);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&num[i].b);\n\n        if(num[ maxl[ num[i].a ] ].b<num[i].b)\n        maxl[num[i].a]=i;\n    }\n\n    for(int i=1;i<=k;i++)\n    {\n        if(!maxl[i])continue;\n        num[maxl[i]].b=1000000000;\n        now++;\n    }\n\n    sort(num+1,num+n+1,cmp);\n\n    for(int i=1;i<=k-now;i++)\n    {\n        ans+=num[i].b;\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n```\n\n**题解：**贪心问题求最优解，先排序让降低好感度最小的排在前面，先对重复且降低好感度最小的故事提出来，然后再根据要调整的天数来依此相加。\n\n## B: 数学题\n\n**题目描述：**\n\n今天，你向你的心上人表白了，可是 TA 说：\n\n我这里有一个长度为 n(2 ≤ n ≤ 30)的数列，数列的第 i 项是 2i。现在保证数列长度 n 是一个偶数，将数列平均分成两份，如果你能得出两份的最小差值，我就答应你。\n\n看着自己的心上人，你光速的写了一个程序，算出了最小差值。\n\n**输入：**\n\n- 第一行 T (T≤100) 表示 (~~你心上人的个数~~) 有 T 组数据\n\n- 接下来的 T 行每一行有一个 数组长度 n (2 ≤ n ≤ 30)且保证 n 是偶数\n\n**输出：**\n\n对于每一个测试数据都输出最小差值\n\n**样例输入：**\n\n```text\n2\n2\n4\n```\n\n**样例输出：**\n\n```text\n2\n6\n```\n\n**提示：**\n\n用笔算\n\n**参考程序：**\n\n```C\n#include<cstdio>\n#include<iostream>\n#include<math.h>\nusing namespace std;\nlong long sum1,sum2;\nint main(){\n    int t,n,i,step;\n    cin>>t;\n    while(t--){\n        cin>>n;\n        if(n%2!=0)\n        continue;\n        else{\n        sum1=0,sum2=0,step=1;\n        for(i=1;i<=n-1;i++){\n            step=step*2;\n            sum1=sum1+step;\n            }\n            step=1;\n        for(i=1;i<=(n/2)-1;i++){\n            step=step*2;\n            sum2=sum2+step;\n        }\n        cout<<pow(2,n)+2*sum2-sum1<<endl;}\n    }\n    return 0;\n}\n```\n\n**题解：**\n\n<img src=\"https://img.alicdn.com/imgextra/i4/0/O1CN01ZzlH9b1kCpWyEAy3S_!!0-rate.jpg_400x400.jpg\" style=\"width: 100%;\" />\n\n## C: 数的划分\n\n**题目描述：**\n\n将整数 n 分成 k 份，且每份不能为 0，问有多少种不同的分法。注：当 n=7，k=3 时，下面三种分法被视为是相同的\n\n```text\n1 1 5\n1 5 1\n5 1 1\n```\n\n**输入：**\n\n一行两个整数 n，k\n\n**输出：**\n\n一行一个整数，即不同的分法数\n\n**样例输入：**\n\n```text\n7 3\n```\n\n**样例输出：**\n\n```text\n4\n```\n\n**提示：**\n\n对于样例的四种分法：\n\n```text\n1 1 5\n1 2 4\n1 3 3\n2 2 3\n```\n\n0<=n<=200，2<=k<=6\n\n**参考程序：**\n\n```C\n#include<iostream>//(深搜)\nusing namespace std;\nint n,k,ans=0;\nvoid dfs(int past,int cnt,int num)\n{\n    if(cnt==1)\n    {\n        ans++;\n        return;\n    }\n    for(int i=past;i<=num/cnt;i++)\n    dfs(i,cnt-1,num-i);\n}\nint main()\n{\n    cin>>n>>k;\n    dfs(1,k,n);\n    cout<<ans;\n    return 0;\n}\n```\n\n**题解：**\n\n也就是递归+搜索，其中 past 代表当前分出来的数，cnt 代表是剩下还可以分几次，num 代表分完 past 之后\n剩下的数。其实思想是很简单的，只要能理解，用笔写一写就可以知道了，反正懂得都懂。\n\n## D: 扩散\n\n**题目描述：**\n\n一个点每过一个单位时间就会向四个方向扩散一个距离，如图。\n\n![](https://img.alicdn.com/imgextra/i2/0/O1CN016YZY6n1kCpWtycyUL_!!0-rate.jpg_400x400.jpg)\n\n两个点 a、b 连通，记作 e(a,b),当且仅当 a、b 的扩散区域有公共部分。连通块的定义是块内的任意两个点 u、v 都必定存在路径 e(u,a0),e(a0,a1),…,e(ak,v)。给定平面上的 n 给点，问最早什么时刻它们形成一个连通块。\n\n**输入：**\n\n第一行一个数 n，以下 n 行，每行一个点坐标 X[i] Y[i]。\n\n**输出：**\n\n一个数，表示最早的时刻所有点形成连通块。\n\n**样例输入：**\n\n```text\n2\n0 0\n5 5\n```\n\n**样例输出：**\n\n```text\n5\n```\n\n**提示：**\n\n1≤N≤50; 1≤X[i],Y[i]≤10^9\n\n**参考程序：**\n\n```C\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100;\nint n,dis[N][N],anss;\nstruct node{\n    int x,y;\n}a[N];\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    scanf(\"%d%d\",&a[i].x,&a[i].y);\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        dis[i][j]=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);\n    for (int k=1;k<=n;k++)\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++)\n        dis[i][j]=min(dis[i][j],max(dis[i][k],dis[k][j]));\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        anss=max(anss,dis[i][j]);\n    printf(\"%d\\n\",(anss+1)/2);\n    return 0;\n}\n```\n\n**题解：**\n\n先来科普一下曼哈顿距离：**d(i,j)=|xi-xj|+|yi-yj|**，也就是直线距离\n\n我们假设有两个点 A，B，他们的坐标分别为(X1,Y1),(X2,Y2).那么现在我们要这两个点扩散，要多长时间？\n假设 X1< X2,且 Y1< Y2，那么它们想要尽量靠拢就要向对方的方向扩散。那么 A 点每扩散一次，他们之间的距离-1，\n同理 B 点每扩散一次，距离-1。\n\n说明：\n每次扩散 A、B 的曼哈顿距离-2. 1.如果曼哈顿距离（设其为 dis）为奇数，那最后一次距离只差 1。所以需要 dis/2+1 的时间，也就是（dis+1）/2;\n\n2,如果曼哈顿距离为偶数，那正好 dis/2 的时间后他们会正好相遇。而（dis+1）/2 后对结果没有影响（因为是下取整）\n\n假设有三个点 ABC，其中 A 离原点最近，C 离原点最远，假设 AB 我们用了 t1 秒，BC 我们用了 t2 秒，不考虑 B，AC 用了 t3 秒\n，那么就会有 min(t1，t2)< t3,所以我们只需枚举每两个节点，用 ans 更新最大值即可，找到最大值就是答案了。(最远的两个点都扩散完了，\n其他点肯定早他妈扩散完了)\n","source":"_posts/07-ACM-homework-7.22.md","raw":"---\ntitle: 桂林电子科技大学 ACM 暑假课 | 7 月 22 日 ACM 作业题解\ndate: 2025-07-22 08:43:21\ntags:\n  - 作业题解\n  - ACM 算法\ncategories:\n  - 算法入门\n---\n\n## A: 讲故事\n\n**题目描述：**\n\n一天，天上掉下来了一个可爱的小妹妹，小妹妹天天缠着你给她讲故事。并且让你在 N 天内给她讲 K(K ≤ N)个不同小故事。你把你知道的所有 K 个故事从 1 到 K 进行编号。她每天会要求你讲某一个小故事，例如第 i 天她会要求你给他讲第 ai 个小故事。\n\n由于小妹妹有间歇性失忆，所以她可能会在一些天内要求你讲你已经讲过的故事。如果你每天都按照她的要求来的话，可能会出现无法在 N 天内讲完 K 个故事的情况(小妹妹可能没有要求过讲某个故事)\n\n你为了完成任务可能在某些情况下，不得不拒绝她的要求，给她讲其他的小故事。但是你在第 i 天拒绝了小妹妹的请求的话，小妹妹对你的好感度就会下降 b\n\n如何在降低最小好感度的情况下在 N 天内讲完 K 给小故事。请输出最少降低的好感度。\n\n**输入：**\n\n- 第一行两个正整数，N K (1≤ K ≤N ≤ 10^5) N 为总天数，K 为需要讲述的故事个数\n\n- 第二行 N 个正整数 a1 a2 …… an (1 ≤ ai ≤ k) 第 n 天要求的故事序号\n\n- 第三行 N 个正整数 b1 b2 …… bn(1 ≤ bi ≤ 10^9) 第 i 天拒绝要求降低的好感度\n\n**输出：**\n\n一行，**满足条件**的前提下最少降低的好感度。\n\n**样例输入：**\n\n```text\n8 7\n1 1 3 1 5 3 7 1\n5 7 4 8 1 3 5 2\n```\n\n**样例输出：**\n\n```text\n10\n```\n\n**提示：**\n\n- 对样例一，最佳的方案是在 1, 6, 8 天把故事改为 2, 4, 6 号，降低的好感度为 a1 + a6 + a8 = 5 + 3 + 2 = 10\n\n- 对样例二，不需要做调整\n\n**参考程序：**\n\n```C\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ll long long\nstruct data_p{int a;ll b;}num[100005];\nint n,k,maxl[100005],now=0;\nll ans;\nbool cmp(data_p x,data_p y){return x.b<y.b;}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&num[i].a);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&num[i].b);\n\n        if(num[ maxl[ num[i].a ] ].b<num[i].b)\n        maxl[num[i].a]=i;\n    }\n\n    for(int i=1;i<=k;i++)\n    {\n        if(!maxl[i])continue;\n        num[maxl[i]].b=1000000000;\n        now++;\n    }\n\n    sort(num+1,num+n+1,cmp);\n\n    for(int i=1;i<=k-now;i++)\n    {\n        ans+=num[i].b;\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n```\n\n**题解：**贪心问题求最优解，先排序让降低好感度最小的排在前面，先对重复且降低好感度最小的故事提出来，然后再根据要调整的天数来依此相加。\n\n## B: 数学题\n\n**题目描述：**\n\n今天，你向你的心上人表白了，可是 TA 说：\n\n我这里有一个长度为 n(2 ≤ n ≤ 30)的数列，数列的第 i 项是 2i。现在保证数列长度 n 是一个偶数，将数列平均分成两份，如果你能得出两份的最小差值，我就答应你。\n\n看着自己的心上人，你光速的写了一个程序，算出了最小差值。\n\n**输入：**\n\n- 第一行 T (T≤100) 表示 (~~你心上人的个数~~) 有 T 组数据\n\n- 接下来的 T 行每一行有一个 数组长度 n (2 ≤ n ≤ 30)且保证 n 是偶数\n\n**输出：**\n\n对于每一个测试数据都输出最小差值\n\n**样例输入：**\n\n```text\n2\n2\n4\n```\n\n**样例输出：**\n\n```text\n2\n6\n```\n\n**提示：**\n\n用笔算\n\n**参考程序：**\n\n```C\n#include<cstdio>\n#include<iostream>\n#include<math.h>\nusing namespace std;\nlong long sum1,sum2;\nint main(){\n    int t,n,i,step;\n    cin>>t;\n    while(t--){\n        cin>>n;\n        if(n%2!=0)\n        continue;\n        else{\n        sum1=0,sum2=0,step=1;\n        for(i=1;i<=n-1;i++){\n            step=step*2;\n            sum1=sum1+step;\n            }\n            step=1;\n        for(i=1;i<=(n/2)-1;i++){\n            step=step*2;\n            sum2=sum2+step;\n        }\n        cout<<pow(2,n)+2*sum2-sum1<<endl;}\n    }\n    return 0;\n}\n```\n\n**题解：**\n\n<img src=\"https://img.alicdn.com/imgextra/i4/0/O1CN01ZzlH9b1kCpWyEAy3S_!!0-rate.jpg_400x400.jpg\" style=\"width: 100%;\" />\n\n## C: 数的划分\n\n**题目描述：**\n\n将整数 n 分成 k 份，且每份不能为 0，问有多少种不同的分法。注：当 n=7，k=3 时，下面三种分法被视为是相同的\n\n```text\n1 1 5\n1 5 1\n5 1 1\n```\n\n**输入：**\n\n一行两个整数 n，k\n\n**输出：**\n\n一行一个整数，即不同的分法数\n\n**样例输入：**\n\n```text\n7 3\n```\n\n**样例输出：**\n\n```text\n4\n```\n\n**提示：**\n\n对于样例的四种分法：\n\n```text\n1 1 5\n1 2 4\n1 3 3\n2 2 3\n```\n\n0<=n<=200，2<=k<=6\n\n**参考程序：**\n\n```C\n#include<iostream>//(深搜)\nusing namespace std;\nint n,k,ans=0;\nvoid dfs(int past,int cnt,int num)\n{\n    if(cnt==1)\n    {\n        ans++;\n        return;\n    }\n    for(int i=past;i<=num/cnt;i++)\n    dfs(i,cnt-1,num-i);\n}\nint main()\n{\n    cin>>n>>k;\n    dfs(1,k,n);\n    cout<<ans;\n    return 0;\n}\n```\n\n**题解：**\n\n也就是递归+搜索，其中 past 代表当前分出来的数，cnt 代表是剩下还可以分几次，num 代表分完 past 之后\n剩下的数。其实思想是很简单的，只要能理解，用笔写一写就可以知道了，反正懂得都懂。\n\n## D: 扩散\n\n**题目描述：**\n\n一个点每过一个单位时间就会向四个方向扩散一个距离，如图。\n\n![](https://img.alicdn.com/imgextra/i2/0/O1CN016YZY6n1kCpWtycyUL_!!0-rate.jpg_400x400.jpg)\n\n两个点 a、b 连通，记作 e(a,b),当且仅当 a、b 的扩散区域有公共部分。连通块的定义是块内的任意两个点 u、v 都必定存在路径 e(u,a0),e(a0,a1),…,e(ak,v)。给定平面上的 n 给点，问最早什么时刻它们形成一个连通块。\n\n**输入：**\n\n第一行一个数 n，以下 n 行，每行一个点坐标 X[i] Y[i]。\n\n**输出：**\n\n一个数，表示最早的时刻所有点形成连通块。\n\n**样例输入：**\n\n```text\n2\n0 0\n5 5\n```\n\n**样例输出：**\n\n```text\n5\n```\n\n**提示：**\n\n1≤N≤50; 1≤X[i],Y[i]≤10^9\n\n**参考程序：**\n\n```C\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100;\nint n,dis[N][N],anss;\nstruct node{\n    int x,y;\n}a[N];\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    scanf(\"%d%d\",&a[i].x,&a[i].y);\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        dis[i][j]=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);\n    for (int k=1;k<=n;k++)\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=n;j++)\n        dis[i][j]=min(dis[i][j],max(dis[i][k],dis[k][j]));\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        anss=max(anss,dis[i][j]);\n    printf(\"%d\\n\",(anss+1)/2);\n    return 0;\n}\n```\n\n**题解：**\n\n先来科普一下曼哈顿距离：**d(i,j)=|xi-xj|+|yi-yj|**，也就是直线距离\n\n我们假设有两个点 A，B，他们的坐标分别为(X1,Y1),(X2,Y2).那么现在我们要这两个点扩散，要多长时间？\n假设 X1< X2,且 Y1< Y2，那么它们想要尽量靠拢就要向对方的方向扩散。那么 A 点每扩散一次，他们之间的距离-1，\n同理 B 点每扩散一次，距离-1。\n\n说明：\n每次扩散 A、B 的曼哈顿距离-2. 1.如果曼哈顿距离（设其为 dis）为奇数，那最后一次距离只差 1。所以需要 dis/2+1 的时间，也就是（dis+1）/2;\n\n2,如果曼哈顿距离为偶数，那正好 dis/2 的时间后他们会正好相遇。而（dis+1）/2 后对结果没有影响（因为是下取整）\n\n假设有三个点 ABC，其中 A 离原点最近，C 离原点最远，假设 AB 我们用了 t1 秒，BC 我们用了 t2 秒，不考虑 B，AC 用了 t3 秒\n，那么就会有 min(t1，t2)< t3,所以我们只需枚举每两个节点，用 ans 更新最大值即可，找到最大值就是答案了。(最远的两个点都扩散完了，\n其他点肯定早他妈扩散完了)\n","slug":"07-ACM-homework-7.22","published":1,"updated":"2025-07-09T01:11:03.711Z","comments":1,"layout":"post","photos":[],"_id":"cmcvbtktq000614nf2osmcjw2","content":"<h2 id=\"A-讲故事\"><a href=\"#A-讲故事\" class=\"headerlink\" title=\"A: 讲故事\"></a>A: 讲故事</h2><p><strong>题目描述：</strong></p>\n<p>一天，天上掉下来了一个可爱的小妹妹，小妹妹天天缠着你给她讲故事。并且让你在 N 天内给她讲 K(K ≤ N)个不同小故事。你把你知道的所有 K 个故事从 1 到 K 进行编号。她每天会要求你讲某一个小故事，例如第 i 天她会要求你给他讲第 ai 个小故事。</p>\n<p>由于小妹妹有间歇性失忆，所以她可能会在一些天内要求你讲你已经讲过的故事。如果你每天都按照她的要求来的话，可能会出现无法在 N 天内讲完 K 个故事的情况(小妹妹可能没有要求过讲某个故事)</p>\n<p>你为了完成任务可能在某些情况下，不得不拒绝她的要求，给她讲其他的小故事。但是你在第 i 天拒绝了小妹妹的请求的话，小妹妹对你的好感度就会下降 b</p>\n<p>如何在降低最小好感度的情况下在 N 天内讲完 K 给小故事。请输出最少降低的好感度。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>第一行两个正整数，N K (1≤ K ≤N ≤ 10^5) N 为总天数，K 为需要讲述的故事个数</p>\n</li>\n<li><p>第二行 N 个正整数 a1 a2 …… an (1 ≤ ai ≤ k) 第 n 天要求的故事序号</p>\n</li>\n<li><p>第三行 N 个正整数 b1 b2 …… bn(1 ≤ bi ≤ 10^9) 第 i 天拒绝要求降低的好感度</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>一行，<strong>满足条件</strong>的前提下最少降低的好感度。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8 7</span><br><span class=\"line\">1 1 3 1 5 3 7 1</span><br><span class=\"line\">5 7 4 8 1 3 5 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><p>对样例一，最佳的方案是在 1, 6, 8 天把故事改为 2, 4, 6 号，降低的好感度为 a1 + a6 + a8 &#x3D; 5 + 3 + 2 &#x3D; 10</p>\n</li>\n<li><p>对样例二，不需要做调整</p>\n</li>\n</ul>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">data_p</span>&#123;</span><span class=\"type\">int</span> a;ll b;&#125;num[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,maxl[<span class=\"number\">100005</span>],now=<span class=\"number\">0</span>;</span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">cmp</span><span class=\"params\">(data_p x,data_p y)</span>&#123;<span class=\"keyword\">return</span> x.b&lt;y.b;&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num[i].a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num[i].b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[ maxl[ num[i].a ] ].b&lt;num[i].b)</span><br><span class=\"line\">        maxl[num[i].a]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!maxl[i])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        num[maxl[i]].b=<span class=\"number\">1000000000</span>;</span><br><span class=\"line\">        now++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(num+<span class=\"number\">1</span>,num+n+<span class=\"number\">1</span>,cmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k-now;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans+=num[i].b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**题解：**贪心问题求最优解，先排序让降低好感度最小的排在前面，先对重复且降低好感度最小的故事提出来，然后再根据要调整的天数来依此相加。</p>\n<h2 id=\"B-数学题\"><a href=\"#B-数学题\" class=\"headerlink\" title=\"B: 数学题\"></a>B: 数学题</h2><p><strong>题目描述：</strong></p>\n<p>今天，你向你的心上人表白了，可是 TA 说：</p>\n<p>我这里有一个长度为 n(2 ≤ n ≤ 30)的数列，数列的第 i 项是 2i。现在保证数列长度 n 是一个偶数，将数列平均分成两份，如果你能得出两份的最小差值，我就答应你。</p>\n<p>看着自己的心上人，你光速的写了一个程序，算出了最小差值。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>第一行 T (T≤100) 表示 (<del>你心上人的个数</del>) 有 T 组数据</p>\n</li>\n<li><p>接下来的 T 行每一行有一个 数组长度 n (2 ≤ n ≤ 30)且保证 n 是偶数</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>对于每一个测试数据都输出最小差值</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>用笔算</p>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum1,sum2;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t,n,i,step;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        sum1=<span class=\"number\">0</span>,sum2=<span class=\"number\">0</span>,step=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">            step=step*<span class=\"number\">2</span>;</span><br><span class=\"line\">            sum1=sum1+step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            step=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=(n/<span class=\"number\">2</span>)<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">            step=step*<span class=\"number\">2</span>;</span><br><span class=\"line\">            sum2=sum2+step;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,n)+<span class=\"number\">2</span>*sum2-sum1&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<img src=\"https://img.alicdn.com/imgextra/i4/0/O1CN01ZzlH9b1kCpWyEAy3S_!!0-rate.jpg_400x400.jpg\" class=\"lazyload\" data-srcset=\"https://img.alicdn.com/imgextra/i4/0/O1CN01ZzlH9b1kCpWyEAy3S_!!0-rate.jpg_400x400.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\" style=\"width: 100%;\" />\n\n<h2 id=\"C-数的划分\"><a href=\"#C-数的划分\" class=\"headerlink\" title=\"C: 数的划分\"></a>C: 数的划分</h2><p><strong>题目描述：</strong></p>\n<p>将整数 n 分成 k 份，且每份不能为 0，问有多少种不同的分法。注：当 n&#x3D;7，k&#x3D;3 时，下面三种分法被视为是相同的</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1 5</span><br><span class=\"line\">1 5 1</span><br><span class=\"line\">5 1 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入：</strong></p>\n<p>一行两个整数 n，k</p>\n<p><strong>输出：</strong></p>\n<p>一行一个整数，即不同的分法数</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>对于样例的四种分法：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1 5</span><br><span class=\"line\">1 2 4</span><br><span class=\"line\">1 3 3</span><br><span class=\"line\">2 2 3</span><br></pre></td></tr></table></figure>\n\n<p>0&lt;&#x3D;n&lt;&#x3D;200，2&lt;&#x3D;k&lt;&#x3D;6</p>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span><span class=\"comment\">//(深搜)</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> past,<span class=\"type\">int</span> cnt,<span class=\"type\">int</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt==<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=past;i&lt;=num/cnt;i++)</span><br><span class=\"line\">    dfs(i,cnt<span class=\"number\">-1</span>,num-i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,k,n);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>也就是递归+搜索，其中 past 代表当前分出来的数，cnt 代表是剩下还可以分几次，num 代表分完 past 之后<br>剩下的数。其实思想是很简单的，只要能理解，用笔写一写就可以知道了，反正懂得都懂。</p>\n<h2 id=\"D-扩散\"><a href=\"#D-扩散\" class=\"headerlink\" title=\"D: 扩散\"></a>D: 扩散</h2><p><strong>题目描述：</strong></p>\n<p>一个点每过一个单位时间就会向四个方向扩散一个距离，如图。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i2/0/O1CN016YZY6n1kCpWtycyUL_!!0-rate.jpg_400x400.jpg\" class=\"lazyload\" data-srcset=\"https://img.alicdn.com/imgextra/i2/0/O1CN016YZY6n1kCpWtycyUL_!!0-rate.jpg_400x400.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p>两个点 a、b 连通，记作 e(a,b),当且仅当 a、b 的扩散区域有公共部分。连通块的定义是块内的任意两个点 u、v 都必定存在路径 e(u,a0),e(a0,a1),…,e(ak,v)。给定平面上的 n 给点，问最早什么时刻它们形成一个连通块。</p>\n<p><strong>输入：</strong></p>\n<p>第一行一个数 n，以下 n 行，每行一个点坐标 X[i] Y[i]。</p>\n<p><strong>输出：</strong></p>\n<p>一个数，表示最早的时刻所有点形成连通块。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">0 0</span><br><span class=\"line\">5 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>1≤N≤50; 1≤X[i],Y[i]≤10^9</p>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,dis[N][N],anss;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;a[N];</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        dis[i][j]=<span class=\"built_in\">abs</span>(a[i].x-a[j].x)+<span class=\"built_in\">abs</span>(a[i].y-a[j].y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        dis[i][j]=min(dis[i][j],max(dis[i][k],dis[k][j]));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        anss=max(anss,dis[i][j]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,(anss+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>先来科普一下曼哈顿距离：<strong>d(i,j)&#x3D;|xi-xj|+|yi-yj|</strong>，也就是直线距离</p>\n<p>我们假设有两个点 A，B，他们的坐标分别为(X1,Y1),(X2,Y2).那么现在我们要这两个点扩散，要多长时间？<br>假设 X1&lt; X2,且 Y1&lt; Y2，那么它们想要尽量靠拢就要向对方的方向扩散。那么 A 点每扩散一次，他们之间的距离-1，<br>同理 B 点每扩散一次，距离-1。</p>\n<p>说明：<br>每次扩散 A、B 的曼哈顿距离-2. 1.如果曼哈顿距离（设其为 dis）为奇数，那最后一次距离只差 1。所以需要 dis&#x2F;2+1 的时间，也就是（dis+1）&#x2F;2;</p>\n<p>2,如果曼哈顿距离为偶数，那正好 dis&#x2F;2 的时间后他们会正好相遇。而（dis+1）&#x2F;2 后对结果没有影响（因为是下取整）</p>\n<p>假设有三个点 ABC，其中 A 离原点最近，C 离原点最远，假设 AB 我们用了 t1 秒，BC 我们用了 t2 秒，不考虑 B，AC 用了 t3 秒<br>，那么就会有 min(t1，t2)&lt; t3,所以我们只需枚举每两个节点，用 ans 更新最大值即可，找到最大值就是答案了。(最远的两个点都扩散完了，<br>其他点肯定早他妈扩散完了)</p>\n","excerpt":"","more":"<h2 id=\"A-讲故事\"><a href=\"#A-讲故事\" class=\"headerlink\" title=\"A: 讲故事\"></a>A: 讲故事</h2><p><strong>题目描述：</strong></p>\n<p>一天，天上掉下来了一个可爱的小妹妹，小妹妹天天缠着你给她讲故事。并且让你在 N 天内给她讲 K(K ≤ N)个不同小故事。你把你知道的所有 K 个故事从 1 到 K 进行编号。她每天会要求你讲某一个小故事，例如第 i 天她会要求你给他讲第 ai 个小故事。</p>\n<p>由于小妹妹有间歇性失忆，所以她可能会在一些天内要求你讲你已经讲过的故事。如果你每天都按照她的要求来的话，可能会出现无法在 N 天内讲完 K 个故事的情况(小妹妹可能没有要求过讲某个故事)</p>\n<p>你为了完成任务可能在某些情况下，不得不拒绝她的要求，给她讲其他的小故事。但是你在第 i 天拒绝了小妹妹的请求的话，小妹妹对你的好感度就会下降 b</p>\n<p>如何在降低最小好感度的情况下在 N 天内讲完 K 给小故事。请输出最少降低的好感度。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>第一行两个正整数，N K (1≤ K ≤N ≤ 10^5) N 为总天数，K 为需要讲述的故事个数</p>\n</li>\n<li><p>第二行 N 个正整数 a1 a2 …… an (1 ≤ ai ≤ k) 第 n 天要求的故事序号</p>\n</li>\n<li><p>第三行 N 个正整数 b1 b2 …… bn(1 ≤ bi ≤ 10^9) 第 i 天拒绝要求降低的好感度</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>一行，<strong>满足条件</strong>的前提下最少降低的好感度。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8 7</span><br><span class=\"line\">1 1 3 1 5 3 7 1</span><br><span class=\"line\">5 7 4 8 1 3 5 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><p>对样例一，最佳的方案是在 1, 6, 8 天把故事改为 2, 4, 6 号，降低的好感度为 a1 + a6 + a8 &#x3D; 5 + 3 + 2 &#x3D; 10</p>\n</li>\n<li><p>对样例二，不需要做调整</p>\n</li>\n</ul>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">data_p</span>&#123;</span><span class=\"type\">int</span> a;ll b;&#125;num[<span class=\"number\">100005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,maxl[<span class=\"number\">100005</span>],now=<span class=\"number\">0</span>;</span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">cmp</span><span class=\"params\">(data_p x,data_p y)</span>&#123;<span class=\"keyword\">return</span> x.b&lt;y.b;&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num[i].a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;num[i].b);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num[ maxl[ num[i].a ] ].b&lt;num[i].b)</span><br><span class=\"line\">        maxl[num[i].a]=i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!maxl[i])<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        num[maxl[i]].b=<span class=\"number\">1000000000</span>;</span><br><span class=\"line\">        now++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sort(num+<span class=\"number\">1</span>,num+n+<span class=\"number\">1</span>,cmp);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k-now;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans+=num[i].b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld&quot;</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**题解：**贪心问题求最优解，先排序让降低好感度最小的排在前面，先对重复且降低好感度最小的故事提出来，然后再根据要调整的天数来依此相加。</p>\n<h2 id=\"B-数学题\"><a href=\"#B-数学题\" class=\"headerlink\" title=\"B: 数学题\"></a>B: 数学题</h2><p><strong>题目描述：</strong></p>\n<p>今天，你向你的心上人表白了，可是 TA 说：</p>\n<p>我这里有一个长度为 n(2 ≤ n ≤ 30)的数列，数列的第 i 项是 2i。现在保证数列长度 n 是一个偶数，将数列平均分成两份，如果你能得出两份的最小差值，我就答应你。</p>\n<p>看着自己的心上人，你光速的写了一个程序，算出了最小差值。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>第一行 T (T≤100) 表示 (<del>你心上人的个数</del>) 有 T 组数据</p>\n</li>\n<li><p>接下来的 T 行每一行有一个 数组长度 n (2 ≤ n ≤ 30)且保证 n 是偶数</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>对于每一个测试数据都输出最小差值</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>用笔算</p>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum1,sum2;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t,n,i,step;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        sum1=<span class=\"number\">0</span>,sum2=<span class=\"number\">0</span>,step=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">            step=step*<span class=\"number\">2</span>;</span><br><span class=\"line\">            sum1=sum1+step;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            step=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=(n/<span class=\"number\">2</span>)<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">            step=step*<span class=\"number\">2</span>;</span><br><span class=\"line\">            sum2=sum2+step;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,n)+<span class=\"number\">2</span>*sum2-sum1&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<img src=\"https://img.alicdn.com/imgextra/i4/0/O1CN01ZzlH9b1kCpWyEAy3S_!!0-rate.jpg_400x400.jpg\" style=\"width: 100%;\" />\n\n<h2 id=\"C-数的划分\"><a href=\"#C-数的划分\" class=\"headerlink\" title=\"C: 数的划分\"></a>C: 数的划分</h2><p><strong>题目描述：</strong></p>\n<p>将整数 n 分成 k 份，且每份不能为 0，问有多少种不同的分法。注：当 n&#x3D;7，k&#x3D;3 时，下面三种分法被视为是相同的</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1 5</span><br><span class=\"line\">1 5 1</span><br><span class=\"line\">5 1 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入：</strong></p>\n<p>一行两个整数 n，k</p>\n<p><strong>输出：</strong></p>\n<p>一行一个整数，即不同的分法数</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>对于样例的四种分法：</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1 5</span><br><span class=\"line\">1 2 4</span><br><span class=\"line\">1 3 3</span><br><span class=\"line\">2 2 3</span><br></pre></td></tr></table></figure>\n\n<p>0&lt;&#x3D;n&lt;&#x3D;200，2&lt;&#x3D;k&lt;&#x3D;6</p>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span><span class=\"comment\">//(深搜)</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> past,<span class=\"type\">int</span> cnt,<span class=\"type\">int</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt==<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=past;i&lt;=num/cnt;i++)</span><br><span class=\"line\">    dfs(i,cnt<span class=\"number\">-1</span>,num-i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    dfs(<span class=\"number\">1</span>,k,n);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>也就是递归+搜索，其中 past 代表当前分出来的数，cnt 代表是剩下还可以分几次，num 代表分完 past 之后<br>剩下的数。其实思想是很简单的，只要能理解，用笔写一写就可以知道了，反正懂得都懂。</p>\n<h2 id=\"D-扩散\"><a href=\"#D-扩散\" class=\"headerlink\" title=\"D: 扩散\"></a>D: 扩散</h2><p><strong>题目描述：</strong></p>\n<p>一个点每过一个单位时间就会向四个方向扩散一个距离，如图。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i2/0/O1CN016YZY6n1kCpWtycyUL_!!0-rate.jpg_400x400.jpg\"></p>\n<p>两个点 a、b 连通，记作 e(a,b),当且仅当 a、b 的扩散区域有公共部分。连通块的定义是块内的任意两个点 u、v 都必定存在路径 e(u,a0),e(a0,a1),…,e(ak,v)。给定平面上的 n 给点，问最早什么时刻它们形成一个连通块。</p>\n<p><strong>输入：</strong></p>\n<p>第一行一个数 n，以下 n 行，每行一个点坐标 X[i] Y[i]。</p>\n<p><strong>输出：</strong></p>\n<p>一个数，表示最早的时刻所有点形成连通块。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">0 0</span><br><span class=\"line\">5 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>1≤N≤50; 1≤X[i],Y[i]≤10^9</p>\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N=<span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,dis[N][N],anss;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;a[N];</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        dis[i][j]=<span class=\"built_in\">abs</span>(a[i].x-a[j].x)+<span class=\"built_in\">abs</span>(a[i].y-a[j].y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        dis[i][j]=min(dis[i][j],max(dis[i][k],dis[k][j]));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        anss=max(anss,dis[i][j]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,(anss+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>题解：</strong></p>\n<p>先来科普一下曼哈顿距离：<strong>d(i,j)&#x3D;|xi-xj|+|yi-yj|</strong>，也就是直线距离</p>\n<p>我们假设有两个点 A，B，他们的坐标分别为(X1,Y1),(X2,Y2).那么现在我们要这两个点扩散，要多长时间？<br>假设 X1&lt; X2,且 Y1&lt; Y2，那么它们想要尽量靠拢就要向对方的方向扩散。那么 A 点每扩散一次，他们之间的距离-1，<br>同理 B 点每扩散一次，距离-1。</p>\n<p>说明：<br>每次扩散 A、B 的曼哈顿距离-2. 1.如果曼哈顿距离（设其为 dis）为奇数，那最后一次距离只差 1。所以需要 dis&#x2F;2+1 的时间，也就是（dis+1）&#x2F;2;</p>\n<p>2,如果曼哈顿距离为偶数，那正好 dis&#x2F;2 的时间后他们会正好相遇。而（dis+1）&#x2F;2 后对结果没有影响（因为是下取整）</p>\n<p>假设有三个点 ABC，其中 A 离原点最近，C 离原点最远，假设 AB 我们用了 t1 秒，BC 我们用了 t2 秒，不考虑 B，AC 用了 t3 秒<br>，那么就会有 min(t1，t2)&lt; t3,所以我们只需枚举每两个节点，用 ans 更新最大值即可，找到最大值就是答案了。(最远的两个点都扩散完了，<br>其他点肯定早他妈扩散完了)</p>\n"},{"title":"桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解","date":"2025-07-25T00:43:21.000Z","_content":"\n# 桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解\n\n## A: 六皇后\n\n**题目描述：**\n\n一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n\n行号：1 2 3 4 5 6  \n列号：2 4 6 1 3 5\n\n这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  \n并把它们以上面的序列方法输出，解按字典顺序排列。  \n请输出前 3 个解。最后一行是解的总个数。\n\n**输入：**\n\n一行一个正整数 n，6≤n≤13，表示棋盘是 nxn 大小的。\n\n**输出：**\n\n- 前三行为前三个解，每个解的两个数字之间用一个空格隔开。\n\n- 第四行只有一个数字，表示解的总数。\n\n**样例输入：**\n\n```text\n6\n```\n\n**样例输出：**\n\n```text\n2 4 6 1 3 5\n3 6 2 5 1 4\n4 1 5 2 6 3\n4\n```\n\n**参考程序：**\n\n```C\n#include<iostream>\nusing namespace std;\nint count = 0;\nint chess[6][6]={0};\nint notDanger(int row,int col ){\n    int i,k;\n    for(i=0;i<6;i++){\n        if(chess[i][col]==1)\n        return 0;\n    }\n    for(i=row,k=col;i>=0&&k>=0;i--,k--)\n    if(chess[i][k]==1)\n    return 0;\n\n    for(i=row,k=col;i>=0&&k<6;i--,k++)\n    if(chess[i][k]==1)\n    return 0;\n\n    return 1;\n}\n\nvoid Print(){\n    int i,j;\n    for(i=0;i<6;i++){\n        for(j=0;j<6;j++){\n            if(chess[i][j]==1)\n            cout<<j+1<<\" \";\n        }\n    }\n    cout<<endl;\n}\nvoid EightQueen( int row ){\n    int col;\n    if( row>5 ){\n        Print();\n        count++;\n        return ;}\n```\n\n题解：写得十分长，但是该有的东西还是有的，比如判断的函数，还有输出以及循环的函数，这里没用到搜索，只是枚举，详细请见 ACM 之“八皇后”\n\n## B:东南西北\n\n**题目描述：**\n\n给出起点和终点的坐标及接下来 T 个时刻的风向(东南西北)，每次可以选择顺风偏移 1 个单位或者停在原地。求到达终点的最少步数。\n\n如果无法偏移至终点，输出“-1”。\n\n**输入：**\n\n- 第一行两个正整数 x1,y1，表示小明所在位置。\n\n- 第二行两个正整数 x2,y2，表示小明想去的位置。\n\n- 第三行一个整数 T，表示 T 个时刻。1<=T<=50\n\n- 第四至第 N+3 行，每行一个字符，表示风向，即东南西北的英文单词的首字母\n\n**输出：**\n\n最少走多少步。\n\n**样例输入：**\n\n```text\n1 1\n2 2\n5\nE\nN\nW\nW\nN\n```\n\n**样例输出：**\n\n```text\n2\n```\n\n**参考程序：**\n\n```C\n#include <iostream>\nusing namespace std;\nint x,y,x1,y1,n,s=0;\nchar a;\nint l=0;\nint main()\n{\n    cin>>x>>y>>x1>>y1;\n    cin>>n;\n    if(x==x1&&y==y1){cout<<'0';return 0;}\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a;\n        if(x1-x>0&&a=='E')x++,s++;\n        else if(x1-x<0&&a=='W')x--,s++;\n        if(y1-y>0&&a=='N')y++,s++;\n        else if(y1-y<0&&a=='S')y--,s++;\n    }\n    if(x==x1&&y==y1)cout<<s;\n    else cout<<\"-1\";\n    return 0;\n}\n```\n\n题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。\n\n## C:跳马\n\n**题目描述：**\n\n中国象棋半张棋盘如图 11 所示。马自左下角 (0,0)向右上角 (m,n) 跳。规定只能往右跳，不准往左跳。比如图 11 中所示为一种跳行路线，并将路径总数打印出来。\n\n![](https://img.alicdn.com/imgextra/i2/0/O1CN01rKH4Rq1kCpWtyemq1_!!0-rate.jpg_400x400.jpg)\n\n**输入：**\n\n只有一行：两个数 n，m。0<=n,m≤18\n\n**输出：**\n\n输出一个数：马从左下角到右上角的总方案数 total。\n\n**样例输入：**\n\n```text\n4 8\n```\n\n**样例输出：**\n\n```text\n37\n```\n\n**参考程序：**\n\n```C\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nint dx[4]= {1, 2, 1, 2};\nint dy[4]= {2, 1, -2, -1};//四种走法\nint ways=0;//记录路线条数\n\nstruct NODE {\n    int x, y;\n};//记录路线上的点的坐标\n\nbool Valid (NODE h, int m, int n) {\n    if ((h.x<=m)&&(h.y>=1)&&(h.y)<=n)\n        return 1;\n    else\n        return 0;\n}//判断下的这步棋是否符合规则\n\nbool bfs (NODE s, int m, int n) {\n    queue<NODE>q;//建立路线队列\n    NODE now, next;//用于记录当前棋和进入下一步的棋\n    q.push(s);//起点入列\n    while (!q.empty()) {\n        now = q.front();\n        q.pop();//取出当前棋子并出列\n        if ((now.x==m)&&(now.y==n)) {\n            ways++;\n            continue;\n        }//判断是否走到终点\n        for ( int i=0; i<4; i++) {\n            next.x=now.x+dx[i];\n            next.y=now.y+dy[i];//走出四种走法\n            if (Valid(next,m, n))\n                q.push(next);//如果有效则入列\n        }\n    }\n}\n\nint main() {\n    int m, n;\n    scanf (\"%d %d\", &m, &n);\n    NODE s;\n    s= {1,1};//起点\n    bfs (s, n, m);//开始搜索\n    printf (\"%d\\n\", ways);\n    return 0;\n}\n```\n\n题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。\n\n## D:奇怪的电梯\n\n**题目描述：**\n\n呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 i 层楼(1≤i≤N)上有一个数字 K(0≤Ki≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3, 3 ,1 ,2 ,5 代表了 Ki\n(K1=3,K2=3,…)，从 11 楼开始。在 1 楼，按“上”可以到 4 楼，按“下”是不起作用的，因为没有-2 楼。那么，从 A 楼到 B 楼至少要按几次按钮呢？\n\n**输入：**\n\n共二行。\n\n- 第一行,为 3 个用空格隔开的正整数，表示 N,A,B。\n\n- 第二行,为 N 个用空格隔开的非负整数，表示 K_i。\n\n**输出：**\n\n一行，即最少按键次数,若无法到达，则输出 −1。\n\n**样例输入：**\n\n```text\n5 1 5\n3 3 1 2 5\n```\n\n**样例输出：**\n\n```text\n3\n```\n\n**参考程序：**\n\n```C\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main()\n{\n    queue<int> q;  //BFS 实现用队列\n    vector<int> v; //保存每层按钮上的数值\n    vector<int> f; //到达每层最少的按键次数\n    vector<bool> flag;//标记值，表示每层是否被访问过，true代表访问过\n    int n;\n    int start, end;//开始层和结束层\n    int tmp;\n    cin >> n >> start >> end;\n    v.push_back(0);//方便起见，下标从1开始\n    f.push_back(0);\n    flag.push_back(false);\n    for (int  i = 1; i <= n; i++)\n    {\n        cin >> tmp;\n        v.push_back(tmp);\n        if(i == start)\n            f.push_back(0);//初始化,start层开始为按0次,其余层为-1次\n        else\n            f.push_back(-1);\n        flag.push_back(false);\n    }\n    q.push(start);\n\n    while (!q.empty()&& !flag.at(q.front()))//队列不为空，切第q.front()层没有被访问过\n    {\n        flag.at(q.front()) = true;\n        int next = q.front() + v.at(q.front());\n        if (next <= n) //上楼\n        {\n            q.push(next);\n            f.at(next) = f.at(q.front()) + 1;//记下到达每层最少的按键次数\n            if (next == end) //找到end层，退出while循环\n            {\n                break;\n            }\n        }\n        next = q.front() - v.at(q.front());\n        if (next >= 1)//下楼\n        {\n            q.push(next);\n            f.at(next) = f.at(q.front()) + 1;\n            if (next == end)//找到end层，退出while循环\n            {\n                break;\n            }\n        }\n        q.pop();\n    }\n    cout << f.at(end) << endl;\n\n    return 0;\n}\n```\n\n题解：动态分配内存，采用 STL 的 vector 容器来解答，也可以简单的用数组来实现\n","source":"_posts/10-ACM-homework-7-25.md","raw":"---\ntitle: 桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解\ndate: 2025-07-25 08:43:21\ntags:\n  - 作业题解\n  - ACM 算法\ncategories:\n  - 算法入门\n---\n\n# 桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解\n\n## A: 六皇后\n\n**题目描述：**\n\n一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n\n行号：1 2 3 4 5 6  \n列号：2 4 6 1 3 5\n\n这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  \n并把它们以上面的序列方法输出，解按字典顺序排列。  \n请输出前 3 个解。最后一行是解的总个数。\n\n**输入：**\n\n一行一个正整数 n，6≤n≤13，表示棋盘是 nxn 大小的。\n\n**输出：**\n\n- 前三行为前三个解，每个解的两个数字之间用一个空格隔开。\n\n- 第四行只有一个数字，表示解的总数。\n\n**样例输入：**\n\n```text\n6\n```\n\n**样例输出：**\n\n```text\n2 4 6 1 3 5\n3 6 2 5 1 4\n4 1 5 2 6 3\n4\n```\n\n**参考程序：**\n\n```C\n#include<iostream>\nusing namespace std;\nint count = 0;\nint chess[6][6]={0};\nint notDanger(int row,int col ){\n    int i,k;\n    for(i=0;i<6;i++){\n        if(chess[i][col]==1)\n        return 0;\n    }\n    for(i=row,k=col;i>=0&&k>=0;i--,k--)\n    if(chess[i][k]==1)\n    return 0;\n\n    for(i=row,k=col;i>=0&&k<6;i--,k++)\n    if(chess[i][k]==1)\n    return 0;\n\n    return 1;\n}\n\nvoid Print(){\n    int i,j;\n    for(i=0;i<6;i++){\n        for(j=0;j<6;j++){\n            if(chess[i][j]==1)\n            cout<<j+1<<\" \";\n        }\n    }\n    cout<<endl;\n}\nvoid EightQueen( int row ){\n    int col;\n    if( row>5 ){\n        Print();\n        count++;\n        return ;}\n```\n\n题解：写得十分长，但是该有的东西还是有的，比如判断的函数，还有输出以及循环的函数，这里没用到搜索，只是枚举，详细请见 ACM 之“八皇后”\n\n## B:东南西北\n\n**题目描述：**\n\n给出起点和终点的坐标及接下来 T 个时刻的风向(东南西北)，每次可以选择顺风偏移 1 个单位或者停在原地。求到达终点的最少步数。\n\n如果无法偏移至终点，输出“-1”。\n\n**输入：**\n\n- 第一行两个正整数 x1,y1，表示小明所在位置。\n\n- 第二行两个正整数 x2,y2，表示小明想去的位置。\n\n- 第三行一个整数 T，表示 T 个时刻。1<=T<=50\n\n- 第四至第 N+3 行，每行一个字符，表示风向，即东南西北的英文单词的首字母\n\n**输出：**\n\n最少走多少步。\n\n**样例输入：**\n\n```text\n1 1\n2 2\n5\nE\nN\nW\nW\nN\n```\n\n**样例输出：**\n\n```text\n2\n```\n\n**参考程序：**\n\n```C\n#include <iostream>\nusing namespace std;\nint x,y,x1,y1,n,s=0;\nchar a;\nint l=0;\nint main()\n{\n    cin>>x>>y>>x1>>y1;\n    cin>>n;\n    if(x==x1&&y==y1){cout<<'0';return 0;}\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a;\n        if(x1-x>0&&a=='E')x++,s++;\n        else if(x1-x<0&&a=='W')x--,s++;\n        if(y1-y>0&&a=='N')y++,s++;\n        else if(y1-y<0&&a=='S')y--,s++;\n    }\n    if(x==x1&&y==y1)cout<<s;\n    else cout<<\"-1\";\n    return 0;\n}\n```\n\n题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。\n\n## C:跳马\n\n**题目描述：**\n\n中国象棋半张棋盘如图 11 所示。马自左下角 (0,0)向右上角 (m,n) 跳。规定只能往右跳，不准往左跳。比如图 11 中所示为一种跳行路线，并将路径总数打印出来。\n\n![](https://img.alicdn.com/imgextra/i2/0/O1CN01rKH4Rq1kCpWtyemq1_!!0-rate.jpg_400x400.jpg)\n\n**输入：**\n\n只有一行：两个数 n，m。0<=n,m≤18\n\n**输出：**\n\n输出一个数：马从左下角到右上角的总方案数 total。\n\n**样例输入：**\n\n```text\n4 8\n```\n\n**样例输出：**\n\n```text\n37\n```\n\n**参考程序：**\n\n```C\n#include <stdio.h>\n#include <queue>\nusing namespace std;\nint dx[4]= {1, 2, 1, 2};\nint dy[4]= {2, 1, -2, -1};//四种走法\nint ways=0;//记录路线条数\n\nstruct NODE {\n    int x, y;\n};//记录路线上的点的坐标\n\nbool Valid (NODE h, int m, int n) {\n    if ((h.x<=m)&&(h.y>=1)&&(h.y)<=n)\n        return 1;\n    else\n        return 0;\n}//判断下的这步棋是否符合规则\n\nbool bfs (NODE s, int m, int n) {\n    queue<NODE>q;//建立路线队列\n    NODE now, next;//用于记录当前棋和进入下一步的棋\n    q.push(s);//起点入列\n    while (!q.empty()) {\n        now = q.front();\n        q.pop();//取出当前棋子并出列\n        if ((now.x==m)&&(now.y==n)) {\n            ways++;\n            continue;\n        }//判断是否走到终点\n        for ( int i=0; i<4; i++) {\n            next.x=now.x+dx[i];\n            next.y=now.y+dy[i];//走出四种走法\n            if (Valid(next,m, n))\n                q.push(next);//如果有效则入列\n        }\n    }\n}\n\nint main() {\n    int m, n;\n    scanf (\"%d %d\", &m, &n);\n    NODE s;\n    s= {1,1};//起点\n    bfs (s, n, m);//开始搜索\n    printf (\"%d\\n\", ways);\n    return 0;\n}\n```\n\n题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。\n\n## D:奇怪的电梯\n\n**题目描述：**\n\n呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 i 层楼(1≤i≤N)上有一个数字 K(0≤Ki≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3, 3 ,1 ,2 ,5 代表了 Ki\n(K1=3,K2=3,…)，从 11 楼开始。在 1 楼，按“上”可以到 4 楼，按“下”是不起作用的，因为没有-2 楼。那么，从 A 楼到 B 楼至少要按几次按钮呢？\n\n**输入：**\n\n共二行。\n\n- 第一行,为 3 个用空格隔开的正整数，表示 N,A,B。\n\n- 第二行,为 N 个用空格隔开的非负整数，表示 K_i。\n\n**输出：**\n\n一行，即最少按键次数,若无法到达，则输出 −1。\n\n**样例输入：**\n\n```text\n5 1 5\n3 3 1 2 5\n```\n\n**样例输出：**\n\n```text\n3\n```\n\n**参考程序：**\n\n```C\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main()\n{\n    queue<int> q;  //BFS 实现用队列\n    vector<int> v; //保存每层按钮上的数值\n    vector<int> f; //到达每层最少的按键次数\n    vector<bool> flag;//标记值，表示每层是否被访问过，true代表访问过\n    int n;\n    int start, end;//开始层和结束层\n    int tmp;\n    cin >> n >> start >> end;\n    v.push_back(0);//方便起见，下标从1开始\n    f.push_back(0);\n    flag.push_back(false);\n    for (int  i = 1; i <= n; i++)\n    {\n        cin >> tmp;\n        v.push_back(tmp);\n        if(i == start)\n            f.push_back(0);//初始化,start层开始为按0次,其余层为-1次\n        else\n            f.push_back(-1);\n        flag.push_back(false);\n    }\n    q.push(start);\n\n    while (!q.empty()&& !flag.at(q.front()))//队列不为空，切第q.front()层没有被访问过\n    {\n        flag.at(q.front()) = true;\n        int next = q.front() + v.at(q.front());\n        if (next <= n) //上楼\n        {\n            q.push(next);\n            f.at(next) = f.at(q.front()) + 1;//记下到达每层最少的按键次数\n            if (next == end) //找到end层，退出while循环\n            {\n                break;\n            }\n        }\n        next = q.front() - v.at(q.front());\n        if (next >= 1)//下楼\n        {\n            q.push(next);\n            f.at(next) = f.at(q.front()) + 1;\n            if (next == end)//找到end层，退出while循环\n            {\n                break;\n            }\n        }\n        q.pop();\n    }\n    cout << f.at(end) << endl;\n\n    return 0;\n}\n```\n\n题解：动态分配内存，采用 STL 的 vector 容器来解答，也可以简单的用数组来实现\n","slug":"10-ACM-homework-7-25","published":1,"updated":"2025-07-09T02:10:02.080Z","comments":1,"layout":"post","photos":[],"_id":"cmcvbtktq000914nf97vbcy8a","content":"<h1 id=\"桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-作业题解\"><a href=\"#桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-作业题解\" class=\"headerlink\" title=\"桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解\"></a>桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解</h1><h2 id=\"A-六皇后\"><a href=\"#A-六皇后\" class=\"headerlink\" title=\"A: 六皇后\"></a>A: 六皇后</h2><p><strong>题目描述：</strong></p>\n<p>一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。</p>\n<p>行号：1 2 3 4 5 6<br>列号：2 4 6 1 3 5</p>\n<p>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br>并把它们以上面的序列方法输出，解按字典顺序排列。<br>请输出前 3 个解。最后一行是解的总个数。</p>\n<p><strong>输入：</strong></p>\n<p>一行一个正整数 n，6≤n≤13，表示棋盘是 nxn 大小的。</p>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。</p>\n</li>\n<li><p>第四行只有一个数字，表示解的总数。</p>\n</li>\n</ul>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 4 6 1 3 5</span><br><span class=\"line\">3 6 2 5 1 4</span><br><span class=\"line\">4 1 5 2 6 3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> chess[<span class=\"number\">6</span>][<span class=\"number\">6</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">notDanger</span><span class=\"params\">(<span class=\"type\">int</span> row,<span class=\"type\">int</span> col )</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(chess[i][col]==<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=row,k=col;i&gt;=<span class=\"number\">0</span>&amp;&amp;k&gt;=<span class=\"number\">0</span>;i--,k--)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(chess[i][k]==<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=row,k=col;i&gt;=<span class=\"number\">0</span>&amp;&amp;k&lt;<span class=\"number\">6</span>;i--,k++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(chess[i][k]==<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">6</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(chess[i][j]==<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;j+<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EightQueen</span><span class=\"params\">( <span class=\"type\">int</span> row )</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> col;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( row&gt;<span class=\"number\">5</span> )&#123;</span><br><span class=\"line\">        Print();</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：写得十分长，但是该有的东西还是有的，比如判断的函数，还有输出以及循环的函数，这里没用到搜索，只是枚举，详细请见 ACM 之“八皇后”</p>\n<h2 id=\"B-东南西北\"><a href=\"#B-东南西北\" class=\"headerlink\" title=\"B:东南西北\"></a>B:东南西北</h2><p><strong>题目描述：</strong></p>\n<p>给出起点和终点的坐标及接下来 T 个时刻的风向(东南西北)，每次可以选择顺风偏移 1 个单位或者停在原地。求到达终点的最少步数。</p>\n<p>如果无法偏移至终点，输出“-1”。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>第一行两个正整数 x1,y1，表示小明所在位置。</p>\n</li>\n<li><p>第二行两个正整数 x2,y2，表示小明想去的位置。</p>\n</li>\n<li><p>第三行一个整数 T，表示 T 个时刻。1&lt;&#x3D;T&lt;&#x3D;50</p>\n</li>\n<li><p>第四至第 N+3 行，每行一个字符，表示风向，即东南西北的英文单词的首字母</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>最少走多少步。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1</span><br><span class=\"line\">2 2</span><br><span class=\"line\">5</span><br><span class=\"line\">E</span><br><span class=\"line\">N</span><br><span class=\"line\">W</span><br><span class=\"line\">W</span><br><span class=\"line\">N</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> x,y,x1,y1,n,s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> l=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==x1&amp;&amp;y==y1)&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&#x27;0&#x27;</span>;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x1-x&gt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;E&#x27;</span>)x++,s++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x1-x&lt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;W&#x27;</span>)x--,s++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y1-y&gt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;N&#x27;</span>)y++,s++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(y1-y&lt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;S&#x27;</span>)y--,s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==x1&amp;&amp;y==y1)<span class=\"built_in\">cout</span>&lt;&lt;s;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。</p>\n<h2 id=\"C-跳马\"><a href=\"#C-跳马\" class=\"headerlink\" title=\"C:跳马\"></a>C:跳马</h2><p><strong>题目描述：</strong></p>\n<p>中国象棋半张棋盘如图 11 所示。马自左下角 (0,0)向右上角 (m,n) 跳。规定只能往右跳，不准往左跳。比如图 11 中所示为一种跳行路线，并将路径总数打印出来。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i2/0/O1CN01rKH4Rq1kCpWtyemq1_!!0-rate.jpg_400x400.jpg\" class=\"lazyload\" data-srcset=\"https://img.alicdn.com/imgextra/i2/0/O1CN01rKH4Rq1kCpWtyemq1_!!0-rate.jpg_400x400.jpg\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"></p>\n<p><strong>输入：</strong></p>\n<p>只有一行：两个数 n，m。0&lt;&#x3D;n,m≤18</p>\n<p><strong>输出：</strong></p>\n<p>输出一个数：马从左下角到右上角的总方案数 total。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 8</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">37</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">4</span>]= &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[<span class=\"number\">4</span>]= &#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>&#125;;<span class=\"comment\">//四种走法</span></span><br><span class=\"line\"><span class=\"type\">int</span> ways=<span class=\"number\">0</span>;<span class=\"comment\">//记录路线条数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125;;<span class=\"comment\">//记录路线上的点的坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Valid</span> <span class=\"params\">(NODE h, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h.x&lt;=m)&amp;&amp;(h.y&gt;=<span class=\"number\">1</span>)&amp;&amp;(h.y)&lt;=n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//判断下的这步棋是否符合规则</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">bfs</span> <span class=\"params\">(NODE s, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;NODE&gt;q;<span class=\"comment\">//建立路线队列</span></span><br><span class=\"line\">    NODE now, next;<span class=\"comment\">//用于记录当前棋和进入下一步的棋</span></span><br><span class=\"line\">    q.push(s);<span class=\"comment\">//起点入列</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</span><br><span class=\"line\">        now = q.front();</span><br><span class=\"line\">        q.pop();<span class=\"comment\">//取出当前棋子并出列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((now.x==m)&amp;&amp;(now.y==n)) &#123;</span><br><span class=\"line\">            ways++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//判断是否走到终点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            next.x=now.x+dx[i];</span><br><span class=\"line\">            next.y=now.y+dy[i];<span class=\"comment\">//走出四种走法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Valid(next,m, n))</span><br><span class=\"line\">                q.push(next);<span class=\"comment\">//如果有效则入列</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span> (<span class=\"string\">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">    NODE s;</span><br><span class=\"line\">    s= &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//起点</span></span><br><span class=\"line\">    bfs (s, n, m);<span class=\"comment\">//开始搜索</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span> (<span class=\"string\">&quot;%d\\n&quot;</span>, ways);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。</p>\n<h2 id=\"D-奇怪的电梯\"><a href=\"#D-奇怪的电梯\" class=\"headerlink\" title=\"D:奇怪的电梯\"></a>D:奇怪的电梯</h2><p><strong>题目描述：</strong></p>\n<p>呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 i 层楼(1≤i≤N)上有一个数字 K(0≤Ki≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3, 3 ,1 ,2 ,5 代表了 Ki<br>(K1&#x3D;3,K2&#x3D;3,…)，从 11 楼开始。在 1 楼，按“上”可以到 4 楼，按“下”是不起作用的，因为没有-2 楼。那么，从 A 楼到 B 楼至少要按几次按钮呢？</p>\n<p><strong>输入：</strong></p>\n<p>共二行。</p>\n<ul>\n<li><p>第一行,为 3 个用空格隔开的正整数，表示 N,A,B。</p>\n</li>\n<li><p>第二行,为 N 个用空格隔开的非负整数，表示 K_i。</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>一行，即最少按键次数,若无法到达，则输出 −1。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 1 5</span><br><span class=\"line\">3 3 1 2 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"type\">int</span>&gt; q;  <span class=\"comment\">//BFS 实现用队列</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; v; <span class=\"comment\">//保存每层按钮上的数值</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; f; <span class=\"comment\">//到达每层最少的按键次数</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt; flag;<span class=\"comment\">//标记值，表示每层是否被访问过，true代表访问过</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> start, end;<span class=\"comment\">//开始层和结束层</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; start &gt;&gt; end;</span><br><span class=\"line\">    v.push_back(<span class=\"number\">0</span>);<span class=\"comment\">//方便起见，下标从1开始</span></span><br><span class=\"line\">    f.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    flag.push_back(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span>  i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; tmp;</span><br><span class=\"line\">        v.push_back(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == start)</span><br><span class=\"line\">            f.push_back(<span class=\"number\">0</span>);<span class=\"comment\">//初始化,start层开始为按0次,其余层为-1次</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            f.push_back(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        flag.push_back(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.push(start);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()&amp;&amp; !flag.at(q.front()))<span class=\"comment\">//队列不为空，切第q.front()层没有被访问过</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        flag.at(q.front()) = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> next = q.front() + v.at(q.front());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &lt;= n) <span class=\"comment\">//上楼</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q.push(next);</span><br><span class=\"line\">            f.at(next) = f.at(q.front()) + <span class=\"number\">1</span>;<span class=\"comment\">//记下到达每层最少的按键次数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == end) <span class=\"comment\">//找到end层，退出while循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next = q.front() - v.at(q.front());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &gt;= <span class=\"number\">1</span>)<span class=\"comment\">//下楼</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q.push(next);</span><br><span class=\"line\">            f.at(next) = f.at(q.front()) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == end)<span class=\"comment\">//找到end层，退出while循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; f.at(end) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：动态分配内存，采用 STL 的 vector 容器来解答，也可以简单的用数组来实现</p>\n","excerpt":"","more":"<h1 id=\"桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-作业题解\"><a href=\"#桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-作业题解\" class=\"headerlink\" title=\"桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解\"></a>桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 作业题解</h1><h2 id=\"A-六皇后\"><a href=\"#A-六皇后\" class=\"headerlink\" title=\"A: 六皇后\"></a>A: 六皇后</h2><p><strong>题目描述：</strong></p>\n<p>一个如下的 6×6 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。</p>\n<p>行号：1 2 3 4 5 6<br>列号：2 4 6 1 3 5</p>\n<p>这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。<br>并把它们以上面的序列方法输出，解按字典顺序排列。<br>请输出前 3 个解。最后一行是解的总个数。</p>\n<p><strong>输入：</strong></p>\n<p>一行一个正整数 n，6≤n≤13，表示棋盘是 nxn 大小的。</p>\n<p><strong>输出：</strong></p>\n<ul>\n<li><p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。</p>\n</li>\n<li><p>第四行只有一个数字，表示解的总数。</p>\n</li>\n</ul>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">6</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2 4 6 1 3 5</span><br><span class=\"line\">3 6 2 5 1 4</span><br><span class=\"line\">4 1 5 2 6 3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> chess[<span class=\"number\">6</span>][<span class=\"number\">6</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">notDanger</span><span class=\"params\">(<span class=\"type\">int</span> row,<span class=\"type\">int</span> col )</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(chess[i][col]==<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=row,k=col;i&gt;=<span class=\"number\">0</span>&amp;&amp;k&gt;=<span class=\"number\">0</span>;i--,k--)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(chess[i][k]==<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=row,k=col;i&gt;=<span class=\"number\">0</span>&amp;&amp;k&lt;<span class=\"number\">6</span>;i--,k++)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(chess[i][k]==<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Print</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">6</span>;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(chess[i][j]==<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;j+<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">EightQueen</span><span class=\"params\">( <span class=\"type\">int</span> row )</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> col;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( row&gt;<span class=\"number\">5</span> )&#123;</span><br><span class=\"line\">        Print();</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：写得十分长，但是该有的东西还是有的，比如判断的函数，还有输出以及循环的函数，这里没用到搜索，只是枚举，详细请见 ACM 之“八皇后”</p>\n<h2 id=\"B-东南西北\"><a href=\"#B-东南西北\" class=\"headerlink\" title=\"B:东南西北\"></a>B:东南西北</h2><p><strong>题目描述：</strong></p>\n<p>给出起点和终点的坐标及接下来 T 个时刻的风向(东南西北)，每次可以选择顺风偏移 1 个单位或者停在原地。求到达终点的最少步数。</p>\n<p>如果无法偏移至终点，输出“-1”。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li><p>第一行两个正整数 x1,y1，表示小明所在位置。</p>\n</li>\n<li><p>第二行两个正整数 x2,y2，表示小明想去的位置。</p>\n</li>\n<li><p>第三行一个整数 T，表示 T 个时刻。1&lt;&#x3D;T&lt;&#x3D;50</p>\n</li>\n<li><p>第四至第 N+3 行，每行一个字符，表示风向，即东南西北的英文单词的首字母</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>最少走多少步。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 1</span><br><span class=\"line\">2 2</span><br><span class=\"line\">5</span><br><span class=\"line\">E</span><br><span class=\"line\">N</span><br><span class=\"line\">W</span><br><span class=\"line\">W</span><br><span class=\"line\">N</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> x,y,x1,y1,n,s=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> a;</span><br><span class=\"line\"><span class=\"type\">int</span> l=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==x1&amp;&amp;y==y1)&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&#x27;0&#x27;</span>;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span>&gt;&gt;a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x1-x&gt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;E&#x27;</span>)x++,s++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x1-x&lt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;W&#x27;</span>)x--,s++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y1-y&gt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;N&#x27;</span>)y++,s++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(y1-y&lt;<span class=\"number\">0</span>&amp;&amp;a==<span class=\"string\">&#x27;S&#x27;</span>)y--,s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==x1&amp;&amp;y==y1)<span class=\"built_in\">cout</span>&lt;&lt;s;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。</p>\n<h2 id=\"C-跳马\"><a href=\"#C-跳马\" class=\"headerlink\" title=\"C:跳马\"></a>C:跳马</h2><p><strong>题目描述：</strong></p>\n<p>中国象棋半张棋盘如图 11 所示。马自左下角 (0,0)向右上角 (m,n) 跳。规定只能往右跳，不准往左跳。比如图 11 中所示为一种跳行路线，并将路径总数打印出来。</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i2/0/O1CN01rKH4Rq1kCpWtyemq1_!!0-rate.jpg_400x400.jpg\"></p>\n<p><strong>输入：</strong></p>\n<p>只有一行：两个数 n，m。0&lt;&#x3D;n,m≤18</p>\n<p><strong>输出：</strong></p>\n<p>输出一个数：马从左下角到右上角的总方案数 total。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4 8</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">37</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">4</span>]= &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[<span class=\"number\">4</span>]= &#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">-2</span>, <span class=\"number\">-1</span>&#125;;<span class=\"comment\">//四种走法</span></span><br><span class=\"line\"><span class=\"type\">int</span> ways=<span class=\"number\">0</span>;<span class=\"comment\">//记录路线条数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">&#125;;<span class=\"comment\">//记录路线上的点的坐标</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">Valid</span> <span class=\"params\">(NODE h, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((h.x&lt;=m)&amp;&amp;(h.y&gt;=<span class=\"number\">1</span>)&amp;&amp;(h.y)&lt;=n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//判断下的这步棋是否符合规则</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">bfs</span> <span class=\"params\">(NODE s, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;NODE&gt;q;<span class=\"comment\">//建立路线队列</span></span><br><span class=\"line\">    NODE now, next;<span class=\"comment\">//用于记录当前棋和进入下一步的棋</span></span><br><span class=\"line\">    q.push(s);<span class=\"comment\">//起点入列</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()) &#123;</span><br><span class=\"line\">        now = q.front();</span><br><span class=\"line\">        q.pop();<span class=\"comment\">//取出当前棋子并出列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((now.x==m)&amp;&amp;(now.y==n)) &#123;</span><br><span class=\"line\">            ways++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//判断是否走到终点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ( <span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            next.x=now.x+dx[i];</span><br><span class=\"line\">            next.y=now.y+dy[i];<span class=\"comment\">//走出四种走法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Valid(next,m, n))</span><br><span class=\"line\">                q.push(next);<span class=\"comment\">//如果有效则入列</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span> (<span class=\"string\">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class=\"line\">    NODE s;</span><br><span class=\"line\">    s= &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//起点</span></span><br><span class=\"line\">    bfs (s, n, m);<span class=\"comment\">//开始搜索</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span> (<span class=\"string\">&quot;%d\\n&quot;</span>, ways);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：只要边输入边看这个方向是不是朝着终点。如果是，就动。否则就不动。</p>\n<h2 id=\"D-奇怪的电梯\"><a href=\"#D-奇怪的电梯\" class=\"headerlink\" title=\"D:奇怪的电梯\"></a>D:奇怪的电梯</h2><p><strong>题目描述：</strong></p>\n<p>呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 i 层楼(1≤i≤N)上有一个数字 K(0≤Ki≤N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3, 3 ,1 ,2 ,5 代表了 Ki<br>(K1&#x3D;3,K2&#x3D;3,…)，从 11 楼开始。在 1 楼，按“上”可以到 4 楼，按“下”是不起作用的，因为没有-2 楼。那么，从 A 楼到 B 楼至少要按几次按钮呢？</p>\n<p><strong>输入：</strong></p>\n<p>共二行。</p>\n<ul>\n<li><p>第一行,为 3 个用空格隔开的正整数，表示 N,A,B。</p>\n</li>\n<li><p>第二行,为 N 个用空格隔开的非负整数，表示 K_i。</p>\n</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>一行，即最少按键次数,若无法到达，则输出 −1。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5 1 5</span><br><span class=\"line\">3 3 1 2 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">queue</span>&lt;<span class=\"type\">int</span>&gt; q;  <span class=\"comment\">//BFS 实现用队列</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; v; <span class=\"comment\">//保存每层按钮上的数值</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; f; <span class=\"comment\">//到达每层最少的按键次数</span></span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt; flag;<span class=\"comment\">//标记值，表示每层是否被访问过，true代表访问过</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> start, end;<span class=\"comment\">//开始层和结束层</span></span><br><span class=\"line\">    <span class=\"type\">int</span> tmp;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; start &gt;&gt; end;</span><br><span class=\"line\">    v.push_back(<span class=\"number\">0</span>);<span class=\"comment\">//方便起见，下标从1开始</span></span><br><span class=\"line\">    f.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    flag.push_back(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span>  i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; tmp;</span><br><span class=\"line\">        v.push_back(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == start)</span><br><span class=\"line\">            f.push_back(<span class=\"number\">0</span>);<span class=\"comment\">//初始化,start层开始为按0次,其余层为-1次</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            f.push_back(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        flag.push_back(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.push(start);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.empty()&amp;&amp; !flag.at(q.front()))<span class=\"comment\">//队列不为空，切第q.front()层没有被访问过</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        flag.at(q.front()) = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> next = q.front() + v.at(q.front());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &lt;= n) <span class=\"comment\">//上楼</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q.push(next);</span><br><span class=\"line\">            f.at(next) = f.at(q.front()) + <span class=\"number\">1</span>;<span class=\"comment\">//记下到达每层最少的按键次数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == end) <span class=\"comment\">//找到end层，退出while循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next = q.front() - v.at(q.front());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next &gt;= <span class=\"number\">1</span>)<span class=\"comment\">//下楼</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            q.push(next);</span><br><span class=\"line\">            f.at(next) = f.at(q.front()) + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == end)<span class=\"comment\">//找到end层，退出while循环</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; f.at(end) &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>题解：动态分配内存，采用 STL 的 vector 容器来解答，也可以简单的用数组来实现</p>\n"},{"title":"桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解","date":"2025-07-25T01:50:00.000Z","_content":"\n# 桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解\n\n## A: 奇数和数组\n\n**题目描述：**\n\n给你一个由 n 个整数组成的数组 a。  \n在一次移动中，您可以选择两个下标 \\(1 \\leq i, j \\leq n\\)，且 \\(i \\neq j\\)，并且设置 \\(a_i := a_j\\)。  \n您可以执行这样的移动任意次数（可能是零次）。您可以在不同的操作中选择不同的下标。  \n操作 := 是赋值的操作（即选择 i 和 j 并用 \\(a_j\\) 替换 \\(a_i\\)）。  \n你的任务是判断是否有可能得到一个元素之和为奇数（不能被 2 整除）的数组。\n\n**输入：**\n\n- 第一行包含一个整数 t（\\(1 \\leq t \\leq 2000\\)）——测试用例的数量。\n- 接下来的 2t 行描述了测试用例。\n- 测试用例的第一行包含一个整数 n（\\(1 \\leq n \\leq 2000\\)）——数组中元素的数量。\n- 测试用例的第二行包含 n 个整数 \\(a_1, a_2, \\dots, a_n\\)（\\(1 \\leq a_i \\leq 2000\\)），保证所有测试用例的 n 之和不超过 2000（\\(\\sum n \\leq 2000\\)）。\n\n**输出：**\n\n对于每个测试用例，如果能得到一个奇数元素和的数组，输出 `\"YES\"`（不加引号），否则输出 `\"NO\"`。\n\n**样例输入：**\n\n```text\n5\n2\n2 3\n4\n2 2 8 8\n3\n3 3 3\n4\n5 5 5 5\n4\n1 1 1 1\n```\n\n**样例输出：**\n\n```text\nYES\nNO\nYES\nNO\nNO\n```\n\n## B: 暗箱操作\n\n**题目描述：**\n\n有两个英语菜鸡 lzh 和 xzy，每个人所能解决的问题都不一样。每个学期的英语考试到了，对于每一个英语题目都有一个相应的分数且每道题的相应分数 \\(p_i\\) 不能小于 1。  \n所有题目的分数总和最低的人就获得挂科重修再来一次，作为 lzh 好朋友的你，为了让 lzh 的英语考试分数比 xzy 高，你需要偷偷操控每题的分数 \\(p_i\\)。  \n但是如果 \\(p_i\\) 太大，lzh 就会因为作弊被抓住，所以你要做的就是最小化所有英语题目中的最大分数 \\(p_i\\)。\n\n**输入：**\n\n- 第一行包含一个整数 n（\\(1 \\leq n \\leq 100\\)），代表英语题目的数量。\n- 第二行有 n 个整数 \\(r_1, r_2, \\dots, r_n\\)（0 ≤ \\(r_i\\) ≤ 1），\\(r_i = 1\\) 意味着 lzh 会第 i 题，\\(r_i = 0\\) 意味着不会。\n- 第三行有 n 个整数 \\(b_1, b_2, \\dots, b_n\\)（0 ≤ \\(b_i\\) ≤ 1），\\(b_i = 1\\) 意味着 xzy 会第 i 题，\\(b_i = 0\\) 意味着不会。\n\n**输出：**\n\n- 如果不能通过任何手段让 lzh 的分数大于 xzy 就输出 `-1`。\n- 否则输出你在所有项目中修改分数的最大值。\n\n**样例输入：**\n\n```text\n5\n1 1 1 0 0\n0 1 1 1 1\n```\n\n**样例输出：**\n\n```text\n3\n```\n\n**提示：**\n\n对于样例来说，你只需要把第一道题的分数改为 3，第二道题的分数改为 1，第三道题的分数改为 3，第四道题的分数改为 1，第五题的分数改为 1。  \n那么 lzh 的得分就是 3+1+3=7，而 xzy 的得分是 1+3+1+1=6，lzh 的分数就比 xzy 的高了。\n\n## C: 简简单单 A+B\n\n**题目描述：**\n\n给出三个整数 A, B, N； \\(1 < A, B, N < 10^9\\)。  \n我们可以进行如下操作：\n\n- 操作 1：让 \\(A = A + B\\)。\n- 操作 2：让 \\(B = A + B\\)。\n\n问最少需要多少次操作，可以使 \\(\\max(A, B)\\) 严格大于 N。  \n\\(\\max(a,b)\\) 为 \\(A,B\\) 中较大的那个。\n\n**输入：**\n\n- 第一行一个整数 T 代表测试组数（\\(1 < T < 100\\)）。\n- 接下来 T 行，每行三个整数 A, B, N。\n\n**输出：**\n\n输出 T 行，每行一个整数，代表所需要的最少操作次数。\n\n**样例输入：**\n\n```text\n2\n1 2 3\n5 4 100\n```\n\n**样例输出：**\n\n```text\n2\n7\n```\n\n## D: 淘淘的暗号\n\n**题目描述：**\n\n淘淘的暗号为一串由 n 个小写字母组成的字符串 b，原文 a 生成 b 的方法为 a 中从左到右将每个长度为 2 的子串加入到 b 中，例如 a 串为 \"abcd\"，那么子串从左到右的顺序为 \"ab\", \"bc\", \"cd\"，则 b 为 \"abbccd\"。\n\n**输入：**\n\n输入长度为 n（\\(3 \\leq n \\leq 100000\\)）的暗号 b。\n\n**输出：**\n\n输出原文 a。\n\n**样例输入：**\n\n```text\nabbaac\n```\n\n**样例输出：**\n\n```text\nabac\n```\n\n**参考程序：**\n\n```C\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    char s[100001];\n    gets(s);\n    n = strlen(s);\n    int i = 0;\n    while(i <= n - 1) {\n        cout << s[i];\n        i += 2;\n    }\n    cout << s[n - 1];\n    return 0;\n}\n```\n\n## E: 淘淘的序列\n\n**题目描述：**\n\n对于一个长为 n 的数字序列中的每个数字 a_i\n​\n，若当\n𝑖\ni 为奇数时\n𝑎\n𝑖\na\ni\n​\n也为奇数，则称它为淘淘序列。\n同时，淘淘每次可以将序列中两个任意数字交换位置，求出淘淘需要多少次交换能将一个序列变为淘淘序列。\n\n注意：\n𝑖\ni 从 0 开始。\n","source":"_posts/11-ACM-middlecollege-7-25.md","raw":"---\ntitle: 桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解\ndate: 2025-07-25 09:50:00\ntags:\n  - 作业题解\n  - ACM 算法\ncategories:\n  - 算法入门\n---\n\n# 桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解\n\n## A: 奇数和数组\n\n**题目描述：**\n\n给你一个由 n 个整数组成的数组 a。  \n在一次移动中，您可以选择两个下标 \\(1 \\leq i, j \\leq n\\)，且 \\(i \\neq j\\)，并且设置 \\(a_i := a_j\\)。  \n您可以执行这样的移动任意次数（可能是零次）。您可以在不同的操作中选择不同的下标。  \n操作 := 是赋值的操作（即选择 i 和 j 并用 \\(a_j\\) 替换 \\(a_i\\)）。  \n你的任务是判断是否有可能得到一个元素之和为奇数（不能被 2 整除）的数组。\n\n**输入：**\n\n- 第一行包含一个整数 t（\\(1 \\leq t \\leq 2000\\)）——测试用例的数量。\n- 接下来的 2t 行描述了测试用例。\n- 测试用例的第一行包含一个整数 n（\\(1 \\leq n \\leq 2000\\)）——数组中元素的数量。\n- 测试用例的第二行包含 n 个整数 \\(a_1, a_2, \\dots, a_n\\)（\\(1 \\leq a_i \\leq 2000\\)），保证所有测试用例的 n 之和不超过 2000（\\(\\sum n \\leq 2000\\)）。\n\n**输出：**\n\n对于每个测试用例，如果能得到一个奇数元素和的数组，输出 `\"YES\"`（不加引号），否则输出 `\"NO\"`。\n\n**样例输入：**\n\n```text\n5\n2\n2 3\n4\n2 2 8 8\n3\n3 3 3\n4\n5 5 5 5\n4\n1 1 1 1\n```\n\n**样例输出：**\n\n```text\nYES\nNO\nYES\nNO\nNO\n```\n\n## B: 暗箱操作\n\n**题目描述：**\n\n有两个英语菜鸡 lzh 和 xzy，每个人所能解决的问题都不一样。每个学期的英语考试到了，对于每一个英语题目都有一个相应的分数且每道题的相应分数 \\(p_i\\) 不能小于 1。  \n所有题目的分数总和最低的人就获得挂科重修再来一次，作为 lzh 好朋友的你，为了让 lzh 的英语考试分数比 xzy 高，你需要偷偷操控每题的分数 \\(p_i\\)。  \n但是如果 \\(p_i\\) 太大，lzh 就会因为作弊被抓住，所以你要做的就是最小化所有英语题目中的最大分数 \\(p_i\\)。\n\n**输入：**\n\n- 第一行包含一个整数 n（\\(1 \\leq n \\leq 100\\)），代表英语题目的数量。\n- 第二行有 n 个整数 \\(r_1, r_2, \\dots, r_n\\)（0 ≤ \\(r_i\\) ≤ 1），\\(r_i = 1\\) 意味着 lzh 会第 i 题，\\(r_i = 0\\) 意味着不会。\n- 第三行有 n 个整数 \\(b_1, b_2, \\dots, b_n\\)（0 ≤ \\(b_i\\) ≤ 1），\\(b_i = 1\\) 意味着 xzy 会第 i 题，\\(b_i = 0\\) 意味着不会。\n\n**输出：**\n\n- 如果不能通过任何手段让 lzh 的分数大于 xzy 就输出 `-1`。\n- 否则输出你在所有项目中修改分数的最大值。\n\n**样例输入：**\n\n```text\n5\n1 1 1 0 0\n0 1 1 1 1\n```\n\n**样例输出：**\n\n```text\n3\n```\n\n**提示：**\n\n对于样例来说，你只需要把第一道题的分数改为 3，第二道题的分数改为 1，第三道题的分数改为 3，第四道题的分数改为 1，第五题的分数改为 1。  \n那么 lzh 的得分就是 3+1+3=7，而 xzy 的得分是 1+3+1+1=6，lzh 的分数就比 xzy 的高了。\n\n## C: 简简单单 A+B\n\n**题目描述：**\n\n给出三个整数 A, B, N； \\(1 < A, B, N < 10^9\\)。  \n我们可以进行如下操作：\n\n- 操作 1：让 \\(A = A + B\\)。\n- 操作 2：让 \\(B = A + B\\)。\n\n问最少需要多少次操作，可以使 \\(\\max(A, B)\\) 严格大于 N。  \n\\(\\max(a,b)\\) 为 \\(A,B\\) 中较大的那个。\n\n**输入：**\n\n- 第一行一个整数 T 代表测试组数（\\(1 < T < 100\\)）。\n- 接下来 T 行，每行三个整数 A, B, N。\n\n**输出：**\n\n输出 T 行，每行一个整数，代表所需要的最少操作次数。\n\n**样例输入：**\n\n```text\n2\n1 2 3\n5 4 100\n```\n\n**样例输出：**\n\n```text\n2\n7\n```\n\n## D: 淘淘的暗号\n\n**题目描述：**\n\n淘淘的暗号为一串由 n 个小写字母组成的字符串 b，原文 a 生成 b 的方法为 a 中从左到右将每个长度为 2 的子串加入到 b 中，例如 a 串为 \"abcd\"，那么子串从左到右的顺序为 \"ab\", \"bc\", \"cd\"，则 b 为 \"abbccd\"。\n\n**输入：**\n\n输入长度为 n（\\(3 \\leq n \\leq 100000\\)）的暗号 b。\n\n**输出：**\n\n输出原文 a。\n\n**样例输入：**\n\n```text\nabbaac\n```\n\n**样例输出：**\n\n```text\nabac\n```\n\n**参考程序：**\n\n```C\n#include <string.h>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int n;\n    char s[100001];\n    gets(s);\n    n = strlen(s);\n    int i = 0;\n    while(i <= n - 1) {\n        cout << s[i];\n        i += 2;\n    }\n    cout << s[n - 1];\n    return 0;\n}\n```\n\n## E: 淘淘的序列\n\n**题目描述：**\n\n对于一个长为 n 的数字序列中的每个数字 a_i\n​\n，若当\n𝑖\ni 为奇数时\n𝑎\n𝑖\na\ni\n​\n也为奇数，则称它为淘淘序列。\n同时，淘淘每次可以将序列中两个任意数字交换位置，求出淘淘需要多少次交换能将一个序列变为淘淘序列。\n\n注意：\n𝑖\ni 从 0 开始。\n","slug":"11-ACM-middlecollege-7-25","published":1,"updated":"2025-07-09T02:10:04.920Z","comments":1,"layout":"post","photos":[],"_id":"cmcvbtktr000b14nf1bth1l47","content":"<h1 id=\"桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-期中考试题解\"><a href=\"#桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-期中考试题解\" class=\"headerlink\" title=\"桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解\"></a>桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解</h1><h2 id=\"A-奇数和数组\"><a href=\"#A-奇数和数组\" class=\"headerlink\" title=\"A: 奇数和数组\"></a>A: 奇数和数组</h2><p><strong>题目描述：</strong></p>\n<p>给你一个由 n 个整数组成的数组 a。<br>在一次移动中，您可以选择两个下标 (1 \\leq i, j \\leq n)，且 (i \\neq j)，并且设置 (a_i :&#x3D; a_j)。<br>您可以执行这样的移动任意次数（可能是零次）。您可以在不同的操作中选择不同的下标。<br>操作 :&#x3D; 是赋值的操作（即选择 i 和 j 并用 (a_j) 替换 (a_i)）。<br>你的任务是判断是否有可能得到一个元素之和为奇数（不能被 2 整除）的数组。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>第一行包含一个整数 t（(1 \\leq t \\leq 2000)）——测试用例的数量。</li>\n<li>接下来的 2t 行描述了测试用例。</li>\n<li>测试用例的第一行包含一个整数 n（(1 \\leq n \\leq 2000)）——数组中元素的数量。</li>\n<li>测试用例的第二行包含 n 个整数 (a_1, a_2, \\dots, a_n)（(1 \\leq a_i \\leq 2000)），保证所有测试用例的 n 之和不超过 2000（(\\sum n \\leq 2000)）。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>对于每个测试用例，如果能得到一个奇数元素和的数组，输出 <code>&quot;YES&quot;</code>（不加引号），否则输出 <code>&quot;NO&quot;</code>。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">2</span><br><span class=\"line\">2 3</span><br><span class=\"line\">4</span><br><span class=\"line\">2 2 8 8</span><br><span class=\"line\">3</span><br><span class=\"line\">3 3 3</span><br><span class=\"line\">4</span><br><span class=\"line\">5 5 5 5</span><br><span class=\"line\">4</span><br><span class=\"line\">1 1 1 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"B-暗箱操作\"><a href=\"#B-暗箱操作\" class=\"headerlink\" title=\"B: 暗箱操作\"></a>B: 暗箱操作</h2><p><strong>题目描述：</strong></p>\n<p>有两个英语菜鸡 lzh 和 xzy，每个人所能解决的问题都不一样。每个学期的英语考试到了，对于每一个英语题目都有一个相应的分数且每道题的相应分数 (p_i) 不能小于 1。<br>所有题目的分数总和最低的人就获得挂科重修再来一次，作为 lzh 好朋友的你，为了让 lzh 的英语考试分数比 xzy 高，你需要偷偷操控每题的分数 (p_i)。<br>但是如果 (p_i) 太大，lzh 就会因为作弊被抓住，所以你要做的就是最小化所有英语题目中的最大分数 (p_i)。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>第一行包含一个整数 n（(1 \\leq n \\leq 100)），代表英语题目的数量。</li>\n<li>第二行有 n 个整数 (r_1, r_2, \\dots, r_n)（0 ≤ (r_i) ≤ 1），(r_i &#x3D; 1) 意味着 lzh 会第 i 题，(r_i &#x3D; 0) 意味着不会。</li>\n<li>第三行有 n 个整数 (b_1, b_2, \\dots, b_n)（0 ≤ (b_i) ≤ 1），(b_i &#x3D; 1) 意味着 xzy 会第 i 题，(b_i &#x3D; 0) 意味着不会。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li>如果不能通过任何手段让 lzh 的分数大于 xzy 就输出 <code>-1</code>。</li>\n<li>否则输出你在所有项目中修改分数的最大值。</li>\n</ul>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 1 1 0 0</span><br><span class=\"line\">0 1 1 1 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>对于样例来说，你只需要把第一道题的分数改为 3，第二道题的分数改为 1，第三道题的分数改为 3，第四道题的分数改为 1，第五题的分数改为 1。<br>那么 lzh 的得分就是 3+1+3&#x3D;7，而 xzy 的得分是 1+3+1+1&#x3D;6，lzh 的分数就比 xzy 的高了。</p>\n<h2 id=\"C-简简单单-A-B\"><a href=\"#C-简简单单-A-B\" class=\"headerlink\" title=\"C: 简简单单 A+B\"></a>C: 简简单单 A+B</h2><p><strong>题目描述：</strong></p>\n<p>给出三个整数 A, B, N； (1 &lt; A, B, N &lt; 10^9)。<br>我们可以进行如下操作：</p>\n<ul>\n<li>操作 1：让 (A &#x3D; A + B)。</li>\n<li>操作 2：让 (B &#x3D; A + B)。</li>\n</ul>\n<p>问最少需要多少次操作，可以使 (\\max(A, B)) 严格大于 N。<br>(\\max(a,b)) 为 (A,B) 中较大的那个。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>第一行一个整数 T 代表测试组数（(1 &lt; T &lt; 100)）。</li>\n<li>接下来 T 行，每行三个整数 A, B, N。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>输出 T 行，每行一个整数，代表所需要的最少操作次数。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">5 4 100</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">7</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"D-淘淘的暗号\"><a href=\"#D-淘淘的暗号\" class=\"headerlink\" title=\"D: 淘淘的暗号\"></a>D: 淘淘的暗号</h2><p><strong>题目描述：</strong></p>\n<p>淘淘的暗号为一串由 n 个小写字母组成的字符串 b，原文 a 生成 b 的方法为 a 中从左到右将每个长度为 2 的子串加入到 b 中，例如 a 串为 “abcd”，那么子串从左到右的顺序为 “ab”, “bc”, “cd”，则 b 为 “abbccd”。</p>\n<p><strong>输入：</strong></p>\n<p>输入长度为 n（(3 \\leq n \\leq 100000)）的暗号 b。</p>\n<p><strong>输出：</strong></p>\n<p>输出原文 a。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abbaac</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abac</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">char</span> s[<span class=\"number\">100001</span>];</span><br><span class=\"line\">    gets(s);</span><br><span class=\"line\">    n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; s[i];</span><br><span class=\"line\">        i += <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"E-淘淘的序列\"><a href=\"#E-淘淘的序列\" class=\"headerlink\" title=\"E: 淘淘的序列\"></a>E: 淘淘的序列</h2><p><strong>题目描述：</strong></p>\n<p>对于一个长为 n 的数字序列中的每个数字 a_i<br>​<br>，若当<br>𝑖<br>i 为奇数时<br>𝑎<br>𝑖<br>a<br>i<br>​<br>也为奇数，则称它为淘淘序列。<br>同时，淘淘每次可以将序列中两个任意数字交换位置，求出淘淘需要多少次交换能将一个序列变为淘淘序列。</p>\n<p>注意：<br>𝑖<br>i 从 0 开始。</p>\n","excerpt":"","more":"<h1 id=\"桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-期中考试题解\"><a href=\"#桂林电子科技大学-ACM-暑假课-7-月-25-日-ACM-期中考试题解\" class=\"headerlink\" title=\"桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解\"></a>桂林电子科技大学 ACM 暑假课 | 7 月 25 日 ACM 期中考试题解</h1><h2 id=\"A-奇数和数组\"><a href=\"#A-奇数和数组\" class=\"headerlink\" title=\"A: 奇数和数组\"></a>A: 奇数和数组</h2><p><strong>题目描述：</strong></p>\n<p>给你一个由 n 个整数组成的数组 a。<br>在一次移动中，您可以选择两个下标 (1 \\leq i, j \\leq n)，且 (i \\neq j)，并且设置 (a_i :&#x3D; a_j)。<br>您可以执行这样的移动任意次数（可能是零次）。您可以在不同的操作中选择不同的下标。<br>操作 :&#x3D; 是赋值的操作（即选择 i 和 j 并用 (a_j) 替换 (a_i)）。<br>你的任务是判断是否有可能得到一个元素之和为奇数（不能被 2 整除）的数组。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>第一行包含一个整数 t（(1 \\leq t \\leq 2000)）——测试用例的数量。</li>\n<li>接下来的 2t 行描述了测试用例。</li>\n<li>测试用例的第一行包含一个整数 n（(1 \\leq n \\leq 2000)）——数组中元素的数量。</li>\n<li>测试用例的第二行包含 n 个整数 (a_1, a_2, \\dots, a_n)（(1 \\leq a_i \\leq 2000)），保证所有测试用例的 n 之和不超过 2000（(\\sum n \\leq 2000)）。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>对于每个测试用例，如果能得到一个奇数元素和的数组，输出 <code>&quot;YES&quot;</code>（不加引号），否则输出 <code>&quot;NO&quot;</code>。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">2</span><br><span class=\"line\">2 3</span><br><span class=\"line\">4</span><br><span class=\"line\">2 2 8 8</span><br><span class=\"line\">3</span><br><span class=\"line\">3 3 3</span><br><span class=\"line\">4</span><br><span class=\"line\">5 5 5 5</span><br><span class=\"line\">4</span><br><span class=\"line\">1 1 1 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">YES</span><br><span class=\"line\">NO</span><br><span class=\"line\">NO</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"B-暗箱操作\"><a href=\"#B-暗箱操作\" class=\"headerlink\" title=\"B: 暗箱操作\"></a>B: 暗箱操作</h2><p><strong>题目描述：</strong></p>\n<p>有两个英语菜鸡 lzh 和 xzy，每个人所能解决的问题都不一样。每个学期的英语考试到了，对于每一个英语题目都有一个相应的分数且每道题的相应分数 (p_i) 不能小于 1。<br>所有题目的分数总和最低的人就获得挂科重修再来一次，作为 lzh 好朋友的你，为了让 lzh 的英语考试分数比 xzy 高，你需要偷偷操控每题的分数 (p_i)。<br>但是如果 (p_i) 太大，lzh 就会因为作弊被抓住，所以你要做的就是最小化所有英语题目中的最大分数 (p_i)。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>第一行包含一个整数 n（(1 \\leq n \\leq 100)），代表英语题目的数量。</li>\n<li>第二行有 n 个整数 (r_1, r_2, \\dots, r_n)（0 ≤ (r_i) ≤ 1），(r_i &#x3D; 1) 意味着 lzh 会第 i 题，(r_i &#x3D; 0) 意味着不会。</li>\n<li>第三行有 n 个整数 (b_1, b_2, \\dots, b_n)（0 ≤ (b_i) ≤ 1），(b_i &#x3D; 1) 意味着 xzy 会第 i 题，(b_i &#x3D; 0) 意味着不会。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<ul>\n<li>如果不能通过任何手段让 lzh 的分数大于 xzy 就输出 <code>-1</code>。</li>\n<li>否则输出你在所有项目中修改分数的最大值。</li>\n</ul>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">1 1 1 0 0</span><br><span class=\"line\">0 1 1 1 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<p>对于样例来说，你只需要把第一道题的分数改为 3，第二道题的分数改为 1，第三道题的分数改为 3，第四道题的分数改为 1，第五题的分数改为 1。<br>那么 lzh 的得分就是 3+1+3&#x3D;7，而 xzy 的得分是 1+3+1+1&#x3D;6，lzh 的分数就比 xzy 的高了。</p>\n<h2 id=\"C-简简单单-A-B\"><a href=\"#C-简简单单-A-B\" class=\"headerlink\" title=\"C: 简简单单 A+B\"></a>C: 简简单单 A+B</h2><p><strong>题目描述：</strong></p>\n<p>给出三个整数 A, B, N； (1 &lt; A, B, N &lt; 10^9)。<br>我们可以进行如下操作：</p>\n<ul>\n<li>操作 1：让 (A &#x3D; A + B)。</li>\n<li>操作 2：让 (B &#x3D; A + B)。</li>\n</ul>\n<p>问最少需要多少次操作，可以使 (\\max(A, B)) 严格大于 N。<br>(\\max(a,b)) 为 (A,B) 中较大的那个。</p>\n<p><strong>输入：</strong></p>\n<ul>\n<li>第一行一个整数 T 代表测试组数（(1 &lt; T &lt; 100)）。</li>\n<li>接下来 T 行，每行三个整数 A, B, N。</li>\n</ul>\n<p><strong>输出：</strong></p>\n<p>输出 T 行，每行一个整数，代表所需要的最少操作次数。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">5 4 100</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">7</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"D-淘淘的暗号\"><a href=\"#D-淘淘的暗号\" class=\"headerlink\" title=\"D: 淘淘的暗号\"></a>D: 淘淘的暗号</h2><p><strong>题目描述：</strong></p>\n<p>淘淘的暗号为一串由 n 个小写字母组成的字符串 b，原文 a 生成 b 的方法为 a 中从左到右将每个长度为 2 的子串加入到 b 中，例如 a 串为 “abcd”，那么子串从左到右的顺序为 “ab”, “bc”, “cd”，则 b 为 “abbccd”。</p>\n<p><strong>输入：</strong></p>\n<p>输入长度为 n（(3 \\leq n \\leq 100000)）的暗号 b。</p>\n<p><strong>输出：</strong></p>\n<p>输出原文 a。</p>\n<p><strong>样例输入：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abbaac</span><br></pre></td></tr></table></figure>\n\n<p><strong>样例输出：</strong></p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abac</span><br></pre></td></tr></table></figure>\n\n<p><strong>参考程序：</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">char</span> s[<span class=\"number\">100001</span>];</span><br><span class=\"line\">    gets(s);</span><br><span class=\"line\">    n = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; s[i];</span><br><span class=\"line\">        i += <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s[n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"E-淘淘的序列\"><a href=\"#E-淘淘的序列\" class=\"headerlink\" title=\"E: 淘淘的序列\"></a>E: 淘淘的序列</h2><p><strong>题目描述：</strong></p>\n<p>对于一个长为 n 的数字序列中的每个数字 a_i<br>​<br>，若当<br>𝑖<br>i 为奇数时<br>𝑎<br>𝑖<br>a<br>i<br>​<br>也为奇数，则称它为淘淘序列。<br>同时，淘淘每次可以将序列中两个任意数字交换位置，求出淘淘需要多少次交换能将一个序列变为淘淘序列。</p>\n<p>注意：<br>𝑖<br>i 从 0 开始。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmcqyxcah000258nf059u7xg8","category_id":"cmcr40e180001mwnf4phl9wh8","_id":"cmcr40e1a0005mwnfazocd64k"},{"post_id":"cmcr40e170000mwnfastr8wef","category_id":"cmcr40e180001mwnf4phl9wh8","_id":"cmcr40e1b0008mwnff5840mv1"},{"post_id":"cmcr40e1c000emwnf8enf4h7v","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcr40e1d000lmwnf8cjn3we4"},{"post_id":"cmcr40e1c000dmwnfefrbds0u","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcr40e1d000omwnf6zdp39cc"},{"post_id":"cmcr40e1c000dmwnfefrbds0u","category_id":"cmcr40e1d000jmwnfcgr45w6n","_id":"cmcr40e1e000rmwnf115cfq50"},{"post_id":"cmcvbtktk000014nf75446rdb","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtktq000514nf8murabgw"},{"post_id":"cmcvbtktn000114nfbjeq5u89","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtktq000714nfaq5delsl"},{"post_id":"cmcvbtktp000314nf32czgrne","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtktr000a14nffx551jg3"},{"post_id":"cmcvbtktp000414nf645215d1","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtktr000c14nf87pngl8j"},{"post_id":"cmcvbtktq000614nf2osmcjw2","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtkts000f14nf0lb5fbej"},{"post_id":"cmcvbtktq000914nf97vbcy8a","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtkts000h14nfd531710n"},{"post_id":"cmcvbtktr000b14nf1bth1l47","category_id":"cmcr40e1c000fmwnf83d10mar","_id":"cmcvbtkts000k14nfgnlzckec"}],"PostTag":[{"post_id":"cmcqyxcah000258nf059u7xg8","tag_id":"cmcr40e190002mwnfcm828cxg","_id":"cmcr40e1b0007mwnfctcs0q4k"},{"post_id":"cmcqyxcah000258nf059u7xg8","tag_id":"cmcr40e190004mwnf8kq8fhtb","_id":"cmcr40e1b0009mwnf6um85gvz"},{"post_id":"cmcr40e170000mwnfastr8wef","tag_id":"cmcr40e1a0006mwnf7lrz0nk4","_id":"cmcr40e1b000bmwnfc02q2wjg"},{"post_id":"cmcr40e170000mwnfastr8wef","tag_id":"cmcr40e190004mwnf8kq8fhtb","_id":"cmcr40e1b000cmwnfgg9wgg4e"},{"post_id":"cmcr40e1c000dmwnfefrbds0u","tag_id":"cmcr40e1d000gmwnf564p8cku","_id":"cmcr40e1d000nmwnf56zt5p1u"},{"post_id":"cmcr40e1c000dmwnfefrbds0u","tag_id":"cmcr40e1d000imwnf2j1rahqx","_id":"cmcr40e1d000pmwnf2c13ef8p"},{"post_id":"cmcr40e1c000dmwnfefrbds0u","tag_id":"cmcr40e1d000kmwnfdkiq36i9","_id":"cmcr40e1e000smwnf3ph44esn"},{"post_id":"cmcr40e1c000emwnf8enf4h7v","tag_id":"cmcr40e1d000mmwnf3cx8d8pv","_id":"cmcr40e1e000tmwnfdytkbl5c"},{"post_id":"cmcr40e1c000emwnf8enf4h7v","tag_id":"cmcr40e1d000kmwnfdkiq36i9","_id":"cmcr40e1e000umwnf000a7e0e"},{"post_id":"cmcvbtktq000914nf97vbcy8a","tag_id":"cmcvbtkto000214nf3dhtb634","_id":"cmcvbtkts000e14nfajzhbns3"},{"post_id":"cmcvbtktq000914nf97vbcy8a","tag_id":"cmcvbtktq000814nf0edh9wn8","_id":"cmcvbtkts000g14nfe1mh0khq"},{"post_id":"cmcvbtktk000014nf75446rdb","tag_id":"cmcvbtkto000214nf3dhtb634","_id":"cmcvbtkts000j14nf4pse8lix"},{"post_id":"cmcvbtktk000014nf75446rdb","tag_id":"cmcvbtktq000814nf0edh9wn8","_id":"cmcvbtkts000l14nfgp43647t"},{"post_id":"cmcvbtktr000b14nf1bth1l47","tag_id":"cmcvbtkto000214nf3dhtb634","_id":"cmcvbtkts000m14nfelcc111x"},{"post_id":"cmcvbtktr000b14nf1bth1l47","tag_id":"cmcvbtktq000814nf0edh9wn8","_id":"cmcvbtktt000o14nfczc41wgg"},{"post_id":"cmcvbtktn000114nfbjeq5u89","tag_id":"cmcvbtktr000d14nf6xqjgfk8","_id":"cmcvbtktt000p14nf2bdzgzeu"},{"post_id":"cmcvbtktn000114nfbjeq5u89","tag_id":"cmcvbtkts000i14nf1emd2wwo","_id":"cmcvbtktt000r14nf1ax8a02k"},{"post_id":"cmcvbtktp000314nf32czgrne","tag_id":"cmcvbtkto000214nf3dhtb634","_id":"cmcvbtktt000t14nf5div9rz0"},{"post_id":"cmcvbtktp000314nf32czgrne","tag_id":"cmcvbtktq000814nf0edh9wn8","_id":"cmcvbtktt000u14nf3kan5u4m"},{"post_id":"cmcvbtktp000414nf645215d1","tag_id":"cmcvbtktr000d14nf6xqjgfk8","_id":"cmcvbtktu000x14nf32to1dhh"},{"post_id":"cmcvbtktp000414nf645215d1","tag_id":"cmcvbtkts000i14nf1emd2wwo","_id":"cmcvbtktu000y14nfdzktgxkg"},{"post_id":"cmcvbtktq000614nf2osmcjw2","tag_id":"cmcvbtkto000214nf3dhtb634","_id":"cmcvbtktu000z14nferpx3ifm"},{"post_id":"cmcvbtktq000614nf2osmcjw2","tag_id":"cmcvbtktq000814nf0edh9wn8","_id":"cmcvbtktu001014nf1gvs0jg6"}],"Tag":[{"name":"游戏开发","_id":"cmcr40e190002mwnfcm828cxg"},{"name":"碎碎念","_id":"cmcr40e190004mwnf8kq8fhtb"},{"name":"前端开发","_id":"cmcr40e1a0006mwnf7lrz0nk4"},{"name":"杭电OJ","_id":"cmcr40e1d000gmwnf564p8cku"},{"name":"刷题顺序","_id":"cmcr40e1d000imwnf2j1rahqx"},{"name":"ACM算法","_id":"cmcr40e1d000kmwnfdkiq36i9"},{"name":"递归","_id":"cmcr40e1d000mmwnf3cx8d8pv"},{"name":"作业题解","_id":"cmcvbtkto000214nf3dhtb634"},{"name":"ACM 算法","_id":"cmcvbtktq000814nf0edh9wn8"},{"name":"贪心算法","_id":"cmcvbtktr000d14nf6xqjgfk8"},{"name":"ACM竞赛入门算法","_id":"cmcvbtkts000i14nf1emd2wwo"}]}}